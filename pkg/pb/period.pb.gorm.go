// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/kodesmil/ks-model/period.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

package pb

import context "context"
import fmt "fmt"
import time "time"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import ptypes1 "github.com/golang/protobuf/ptypes"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"

import math "math"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/envoyproxy/protoc-gen-validate/validate"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type PeriodInfoORM struct {
	AccountID          string
	CreatedAt          *time.Time
	CycleLengthInDays  int32
	Id                 int64 `gorm:"type:serial;primary_key"`
	PeriodLengthInDays int32
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (PeriodInfoORM) TableName() string {
	return "period_infos"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PeriodInfo) ToORM(ctx context.Context) (PeriodInfoORM, error) {
	to := PeriodInfoORM{}
	var err error
	if prehook, ok := interface{}(m).(PeriodInfoWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&PeriodInfo{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.PeriodLengthInDays = m.PeriodLengthInDays
	to.CycleLengthInDays = m.CycleLengthInDays
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(PeriodInfoWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PeriodInfoORM) ToPB(ctx context.Context) (PeriodInfo, error) {
	to := PeriodInfo{}
	var err error
	if prehook, ok := interface{}(m).(PeriodInfoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&PeriodInfo{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.PeriodLengthInDays = m.PeriodLengthInDays
	to.CycleLengthInDays = m.CycleLengthInDays
	if posthook, ok := interface{}(m).(PeriodInfoWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PeriodInfo the arg will be the target, the caller the one being converted from

// PeriodInfoBeforeToORM called before default ToORM code
type PeriodInfoWithBeforeToORM interface {
	BeforeToORM(context.Context, *PeriodInfoORM) error
}

// PeriodInfoAfterToORM called after default ToORM code
type PeriodInfoWithAfterToORM interface {
	AfterToORM(context.Context, *PeriodInfoORM) error
}

// PeriodInfoBeforeToPB called before default ToPB code
type PeriodInfoWithBeforeToPB interface {
	BeforeToPB(context.Context, *PeriodInfo) error
}

// PeriodInfoAfterToPB called after default ToPB code
type PeriodInfoWithAfterToPB interface {
	AfterToPB(context.Context, *PeriodInfo) error
}

type PeriodDailyEntryORM struct {
	AccountID string
	CreatedAt *time.Time
	Day       *time.Time
	Id        int64 `gorm:"type:serial;primary_key"`
	Severity  int32
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (PeriodDailyEntryORM) TableName() string {
	return "period_daily_entries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PeriodDailyEntry) ToORM(ctx context.Context) (PeriodDailyEntryORM, error) {
	to := PeriodDailyEntryORM{}
	var err error
	if prehook, ok := interface{}(m).(PeriodDailyEntryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&PeriodDailyEntry{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Day != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.Day); err != nil {
			return to, err
		}
		to.Day = &t
	}
	to.Severity = int32(m.Severity)
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(PeriodDailyEntryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PeriodDailyEntryORM) ToPB(ctx context.Context) (PeriodDailyEntry, error) {
	to := PeriodDailyEntry{}
	var err error
	if prehook, ok := interface{}(m).(PeriodDailyEntryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&PeriodDailyEntry{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Day != nil {
		if to.Day, err = ptypes1.TimestampProto(*m.Day); err != nil {
			return to, err
		}
	}
	to.Severity = PeriodDailyEntry_Severity(m.Severity)
	if posthook, ok := interface{}(m).(PeriodDailyEntryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PeriodDailyEntry the arg will be the target, the caller the one being converted from

// PeriodDailyEntryBeforeToORM called before default ToORM code
type PeriodDailyEntryWithBeforeToORM interface {
	BeforeToORM(context.Context, *PeriodDailyEntryORM) error
}

// PeriodDailyEntryAfterToORM called after default ToORM code
type PeriodDailyEntryWithAfterToORM interface {
	AfterToORM(context.Context, *PeriodDailyEntryORM) error
}

// PeriodDailyEntryBeforeToPB called before default ToPB code
type PeriodDailyEntryWithBeforeToPB interface {
	BeforeToPB(context.Context, *PeriodDailyEntry) error
}

// PeriodDailyEntryAfterToPB called after default ToPB code
type PeriodDailyEntryWithAfterToPB interface {
	AfterToPB(context.Context, *PeriodDailyEntry) error
}

// DefaultCreatePeriodInfo executes a basic gorm create call
func DefaultCreatePeriodInfo(ctx context.Context, in *PeriodInfo, db *gorm1.DB) (*PeriodInfo, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PeriodInfoORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadPeriodInfo executes a basic gorm read call
func DefaultReadPeriodInfo(ctx context.Context, in *PeriodInfo, db *gorm1.DB) (*PeriodInfo, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &PeriodInfoORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PeriodInfoORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PeriodInfoORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PeriodInfoORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeletePeriodInfo(ctx context.Context, in *PeriodInfo, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PeriodInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PeriodInfoORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeletePeriodInfoSet(ctx context.Context, in []*PeriodInfo, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PeriodInfoORM{})).(PeriodInfoORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&PeriodInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PeriodInfoORM{})).(PeriodInfoORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PeriodInfoORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PeriodInfo, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PeriodInfo, *gorm1.DB) error
}

// DefaultStrictUpdatePeriodInfo clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePeriodInfo(ctx context.Context, in *PeriodInfo, db *gorm1.DB) (*PeriodInfo, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePeriodInfo")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &PeriodInfoORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PeriodInfoORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchPeriodInfo executes a basic gorm update call with patch behavior
func DefaultPatchPeriodInfo(ctx context.Context, in *PeriodInfo, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*PeriodInfo, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj PeriodInfo
	var err error
	if hook, ok := interface{}(&pbObj).(PeriodInfoWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPeriodInfo(ctx, &PeriodInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PeriodInfoWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPeriodInfo(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PeriodInfoWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePeriodInfo(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PeriodInfoWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PeriodInfoWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PeriodInfo, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PeriodInfo, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PeriodInfo, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodInfoWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PeriodInfo, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetPeriodInfo executes a bulk gorm update call with patch behavior
func DefaultPatchSetPeriodInfo(ctx context.Context, objects []*PeriodInfo, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*PeriodInfo, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PeriodInfo, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPeriodInfo(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPeriodInfo patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPeriodInfo(ctx context.Context, patchee *PeriodInfo, patcher *PeriodInfo, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*PeriodInfo, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"PeriodLengthInDays" {
			patchee.PeriodLengthInDays = patcher.PeriodLengthInDays
			continue
		}
		if f == prefix+"CycleLengthInDays" {
			patchee.CycleLengthInDays = patcher.CycleLengthInDays
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPeriodInfo executes a gorm list call
func DefaultListPeriodInfo(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*PeriodInfo, error) {
	in := PeriodInfo{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &PeriodInfoORM{}, &PeriodInfo{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PeriodInfoORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodInfoORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PeriodInfo{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PeriodInfoORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type PeriodInfoORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type PeriodInfoORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]PeriodInfoORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreatePeriodDailyEntry executes a basic gorm create call
func DefaultCreatePeriodDailyEntry(ctx context.Context, in *PeriodDailyEntry, db *gorm1.DB) (*PeriodDailyEntry, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PeriodDailyEntryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadPeriodDailyEntry executes a basic gorm read call
func DefaultReadPeriodDailyEntry(ctx context.Context, in *PeriodDailyEntry, db *gorm1.DB) (*PeriodDailyEntry, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &PeriodDailyEntryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PeriodDailyEntryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PeriodDailyEntryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PeriodDailyEntryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeletePeriodDailyEntry(ctx context.Context, in *PeriodDailyEntry, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PeriodDailyEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PeriodDailyEntryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeletePeriodDailyEntrySet(ctx context.Context, in []*PeriodDailyEntry, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PeriodDailyEntryORM{})).(PeriodDailyEntryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&PeriodDailyEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PeriodDailyEntryORM{})).(PeriodDailyEntryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PeriodDailyEntryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PeriodDailyEntry, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PeriodDailyEntry, *gorm1.DB) error
}

// DefaultStrictUpdatePeriodDailyEntry clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePeriodDailyEntry(ctx context.Context, in *PeriodDailyEntry, db *gorm1.DB) (*PeriodDailyEntry, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePeriodDailyEntry")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &PeriodDailyEntryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PeriodDailyEntryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchPeriodDailyEntry executes a basic gorm update call with patch behavior
func DefaultPatchPeriodDailyEntry(ctx context.Context, in *PeriodDailyEntry, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*PeriodDailyEntry, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj PeriodDailyEntry
	var err error
	if hook, ok := interface{}(&pbObj).(PeriodDailyEntryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPeriodDailyEntry(ctx, &PeriodDailyEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PeriodDailyEntryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPeriodDailyEntry(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PeriodDailyEntryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePeriodDailyEntry(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PeriodDailyEntryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PeriodDailyEntryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PeriodDailyEntry, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PeriodDailyEntry, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PeriodDailyEntry, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PeriodDailyEntryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PeriodDailyEntry, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetPeriodDailyEntry executes a bulk gorm update call with patch behavior
func DefaultPatchSetPeriodDailyEntry(ctx context.Context, objects []*PeriodDailyEntry, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*PeriodDailyEntry, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PeriodDailyEntry, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPeriodDailyEntry(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPeriodDailyEntry patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPeriodDailyEntry(ctx context.Context, patchee *PeriodDailyEntry, patcher *PeriodDailyEntry, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*PeriodDailyEntry, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Day" {
			patchee.Day = patcher.Day
			continue
		}
		if f == prefix+"Severity" {
			patchee.Severity = patcher.Severity
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPeriodDailyEntry executes a gorm list call
func DefaultListPeriodDailyEntry(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*PeriodDailyEntry, error) {
	in := PeriodDailyEntry{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &PeriodDailyEntryORM{}, &PeriodDailyEntry{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PeriodDailyEntryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PeriodDailyEntryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PeriodDailyEntry{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PeriodDailyEntryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type PeriodDailyEntryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type PeriodDailyEntryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]PeriodDailyEntryORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type PeriodDefaultServer struct {
	DB *gorm1.DB
}

// CreatePeriodDailyEntry ...
func (m *PeriodDefaultServer) CreatePeriodDailyEntry(ctx context.Context, in *CreatePeriodDailyEntryRequest) (*CreatePeriodDailyEntryResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithBeforeCreatePeriodDailyEntry); ok {
		var err error
		if db, err = custom.BeforeCreatePeriodDailyEntry(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreatePeriodDailyEntry(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreatePeriodDailyEntryResponse{Result: res}
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithAfterCreatePeriodDailyEntry); ok {
		var err error
		if err = custom.AfterCreatePeriodDailyEntry(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodDailyEntryWithBeforeCreatePeriodDailyEntry called before DefaultCreatePeriodDailyEntryPeriodDailyEntry in the default CreatePeriodDailyEntry handler
type PeriodPeriodDailyEntryWithBeforeCreatePeriodDailyEntry interface {
	BeforeCreatePeriodDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodDailyEntryWithAfterCreatePeriodDailyEntry called before DefaultCreatePeriodDailyEntryPeriodDailyEntry in the default CreatePeriodDailyEntry handler
type PeriodPeriodDailyEntryWithAfterCreatePeriodDailyEntry interface {
	AfterCreatePeriodDailyEntry(context.Context, *CreatePeriodDailyEntryResponse, *gorm1.DB) error
}

// ReadPeriodDailyEntry ...
func (m *PeriodDefaultServer) ReadPeriodDailyEntry(ctx context.Context, in *ReadPeriodDailyEntryRequest) (*ReadPeriodDailyEntryResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithBeforeReadPeriodDailyEntry); ok {
		var err error
		if db, err = custom.BeforeReadPeriodDailyEntry(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadPeriodDailyEntry(ctx, &PeriodDailyEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadPeriodDailyEntryResponse{Result: res}
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithAfterReadPeriodDailyEntry); ok {
		var err error
		if err = custom.AfterReadPeriodDailyEntry(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodDailyEntryWithBeforeReadPeriodDailyEntry called before DefaultReadPeriodDailyEntryPeriodDailyEntry in the default ReadPeriodDailyEntry handler
type PeriodPeriodDailyEntryWithBeforeReadPeriodDailyEntry interface {
	BeforeReadPeriodDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodDailyEntryWithAfterReadPeriodDailyEntry called before DefaultReadPeriodDailyEntryPeriodDailyEntry in the default ReadPeriodDailyEntry handler
type PeriodPeriodDailyEntryWithAfterReadPeriodDailyEntry interface {
	AfterReadPeriodDailyEntry(context.Context, *ReadPeriodDailyEntryResponse, *gorm1.DB) error
}

// UpdatePeriodDailyEntry ...
func (m *PeriodDefaultServer) UpdatePeriodDailyEntry(ctx context.Context, in *UpdatePeriodDailyEntryRequest) (*UpdatePeriodDailyEntryResponse, error) {
	var err error
	var res *PeriodDailyEntry
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithBeforeUpdatePeriodDailyEntry); ok {
		var err error
		if db, err = custom.BeforeUpdatePeriodDailyEntry(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdatePeriodDailyEntry(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdatePeriodDailyEntryResponse{Result: res}
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithAfterUpdatePeriodDailyEntry); ok {
		var err error
		if err = custom.AfterUpdatePeriodDailyEntry(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodDailyEntryWithBeforeUpdatePeriodDailyEntry called before DefaultUpdatePeriodDailyEntryPeriodDailyEntry in the default UpdatePeriodDailyEntry handler
type PeriodPeriodDailyEntryWithBeforeUpdatePeriodDailyEntry interface {
	BeforeUpdatePeriodDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodDailyEntryWithAfterUpdatePeriodDailyEntry called before DefaultUpdatePeriodDailyEntryPeriodDailyEntry in the default UpdatePeriodDailyEntry handler
type PeriodPeriodDailyEntryWithAfterUpdatePeriodDailyEntry interface {
	AfterUpdatePeriodDailyEntry(context.Context, *UpdatePeriodDailyEntryResponse, *gorm1.DB) error
}

// DeletePeriodDailyEntry ...
func (m *PeriodDefaultServer) DeletePeriodDailyEntry(ctx context.Context, in *DeletePeriodDailyEntryRequest) (*DeletePeriodDailyEntryResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithBeforeDeletePeriodDailyEntry); ok {
		var err error
		if db, err = custom.BeforeDeletePeriodDailyEntry(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeletePeriodDailyEntry(ctx, &PeriodDailyEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeletePeriodDailyEntryResponse{}
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithAfterDeletePeriodDailyEntry); ok {
		var err error
		if err = custom.AfterDeletePeriodDailyEntry(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodDailyEntryWithBeforeDeletePeriodDailyEntry called before DefaultDeletePeriodDailyEntryPeriodDailyEntry in the default DeletePeriodDailyEntry handler
type PeriodPeriodDailyEntryWithBeforeDeletePeriodDailyEntry interface {
	BeforeDeletePeriodDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodDailyEntryWithAfterDeletePeriodDailyEntry called before DefaultDeletePeriodDailyEntryPeriodDailyEntry in the default DeletePeriodDailyEntry handler
type PeriodPeriodDailyEntryWithAfterDeletePeriodDailyEntry interface {
	AfterDeletePeriodDailyEntry(context.Context, *DeletePeriodDailyEntryResponse, *gorm1.DB) error
}

// ListPeriodDailyEntry ...
func (m *PeriodDefaultServer) ListPeriodDailyEntry(ctx context.Context, in *ListPeriodDailyEntryRequest) (*ListPeriodDailyEntryResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithBeforeListPeriodDailyEntry); ok {
		var err error
		if db, err = custom.BeforeListPeriodDailyEntry(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListPeriodDailyEntry(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListPeriodDailyEntryResponse{Results: res}
	if custom, ok := interface{}(in).(PeriodPeriodDailyEntryWithAfterListPeriodDailyEntry); ok {
		var err error
		if err = custom.AfterListPeriodDailyEntry(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodDailyEntryWithBeforeListPeriodDailyEntry called before DefaultListPeriodDailyEntryPeriodDailyEntry in the default ListPeriodDailyEntry handler
type PeriodPeriodDailyEntryWithBeforeListPeriodDailyEntry interface {
	BeforeListPeriodDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodDailyEntryWithAfterListPeriodDailyEntry called before DefaultListPeriodDailyEntryPeriodDailyEntry in the default ListPeriodDailyEntry handler
type PeriodPeriodDailyEntryWithAfterListPeriodDailyEntry interface {
	AfterListPeriodDailyEntry(context.Context, *ListPeriodDailyEntryResponse, *gorm1.DB) error
}

// CreatePeriodInfo ...
func (m *PeriodDefaultServer) CreatePeriodInfo(ctx context.Context, in *CreatePeriodInfoRequest) (*CreatePeriodInfoResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithBeforeCreatePeriodInfo); ok {
		var err error
		if db, err = custom.BeforeCreatePeriodInfo(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreatePeriodInfo(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreatePeriodInfoResponse{Result: res}
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithAfterCreatePeriodInfo); ok {
		var err error
		if err = custom.AfterCreatePeriodInfo(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodInfoWithBeforeCreatePeriodInfo called before DefaultCreatePeriodInfoPeriodInfo in the default CreatePeriodInfo handler
type PeriodPeriodInfoWithBeforeCreatePeriodInfo interface {
	BeforeCreatePeriodInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodInfoWithAfterCreatePeriodInfo called before DefaultCreatePeriodInfoPeriodInfo in the default CreatePeriodInfo handler
type PeriodPeriodInfoWithAfterCreatePeriodInfo interface {
	AfterCreatePeriodInfo(context.Context, *CreatePeriodInfoResponse, *gorm1.DB) error
}

// ReadPeriodInfo ...
func (m *PeriodDefaultServer) ReadPeriodInfo(ctx context.Context, in *ReadPeriodInfoRequest) (*ReadPeriodInfoResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithBeforeReadPeriodInfo); ok {
		var err error
		if db, err = custom.BeforeReadPeriodInfo(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadPeriodInfo(ctx, &PeriodInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadPeriodInfoResponse{Result: res}
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithAfterReadPeriodInfo); ok {
		var err error
		if err = custom.AfterReadPeriodInfo(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodInfoWithBeforeReadPeriodInfo called before DefaultReadPeriodInfoPeriodInfo in the default ReadPeriodInfo handler
type PeriodPeriodInfoWithBeforeReadPeriodInfo interface {
	BeforeReadPeriodInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodInfoWithAfterReadPeriodInfo called before DefaultReadPeriodInfoPeriodInfo in the default ReadPeriodInfo handler
type PeriodPeriodInfoWithAfterReadPeriodInfo interface {
	AfterReadPeriodInfo(context.Context, *ReadPeriodInfoResponse, *gorm1.DB) error
}

// UpdatePeriodInfo ...
func (m *PeriodDefaultServer) UpdatePeriodInfo(ctx context.Context, in *UpdatePeriodInfoRequest) (*UpdatePeriodInfoResponse, error) {
	var err error
	var res *PeriodInfo
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithBeforeUpdatePeriodInfo); ok {
		var err error
		if db, err = custom.BeforeUpdatePeriodInfo(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdatePeriodInfo(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdatePeriodInfoResponse{Result: res}
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithAfterUpdatePeriodInfo); ok {
		var err error
		if err = custom.AfterUpdatePeriodInfo(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodInfoWithBeforeUpdatePeriodInfo called before DefaultUpdatePeriodInfoPeriodInfo in the default UpdatePeriodInfo handler
type PeriodPeriodInfoWithBeforeUpdatePeriodInfo interface {
	BeforeUpdatePeriodInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodInfoWithAfterUpdatePeriodInfo called before DefaultUpdatePeriodInfoPeriodInfo in the default UpdatePeriodInfo handler
type PeriodPeriodInfoWithAfterUpdatePeriodInfo interface {
	AfterUpdatePeriodInfo(context.Context, *UpdatePeriodInfoResponse, *gorm1.DB) error
}

// DeletePeriodInfo ...
func (m *PeriodDefaultServer) DeletePeriodInfo(ctx context.Context, in *DeletePeriodInfoRequest) (*DeletePeriodInfoResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithBeforeDeletePeriodInfo); ok {
		var err error
		if db, err = custom.BeforeDeletePeriodInfo(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeletePeriodInfo(ctx, &PeriodInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeletePeriodInfoResponse{}
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithAfterDeletePeriodInfo); ok {
		var err error
		if err = custom.AfterDeletePeriodInfo(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodInfoWithBeforeDeletePeriodInfo called before DefaultDeletePeriodInfoPeriodInfo in the default DeletePeriodInfo handler
type PeriodPeriodInfoWithBeforeDeletePeriodInfo interface {
	BeforeDeletePeriodInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodInfoWithAfterDeletePeriodInfo called before DefaultDeletePeriodInfoPeriodInfo in the default DeletePeriodInfo handler
type PeriodPeriodInfoWithAfterDeletePeriodInfo interface {
	AfterDeletePeriodInfo(context.Context, *DeletePeriodInfoResponse, *gorm1.DB) error
}

// ListPeriodInfo ...
func (m *PeriodDefaultServer) ListPeriodInfo(ctx context.Context, in *ListPeriodInfoRequest) (*ListPeriodInfoResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithBeforeListPeriodInfo); ok {
		var err error
		if db, err = custom.BeforeListPeriodInfo(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListPeriodInfo(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListPeriodInfoResponse{Results: res}
	if custom, ok := interface{}(in).(PeriodPeriodInfoWithAfterListPeriodInfo); ok {
		var err error
		if err = custom.AfterListPeriodInfo(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// PeriodPeriodInfoWithBeforeListPeriodInfo called before DefaultListPeriodInfoPeriodInfo in the default ListPeriodInfo handler
type PeriodPeriodInfoWithBeforeListPeriodInfo interface {
	BeforeListPeriodInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// PeriodPeriodInfoWithAfterListPeriodInfo called before DefaultListPeriodInfoPeriodInfo in the default ListPeriodInfo handler
type PeriodPeriodInfoWithAfterListPeriodInfo interface {
	AfterListPeriodInfo(context.Context, *ListPeriodInfoResponse, *gorm1.DB) error
}

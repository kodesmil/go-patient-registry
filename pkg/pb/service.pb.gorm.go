// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/kodesmil/go-patient-registry/pkg/pb/service.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/kodesmil/go-patient-registry/pkg/pb/service.proto

It has these top-level messages:
	ChatMessage
	CreateChatMessageRequest
	CreateChatMessageResponse
	ListChatMessageRequest
	ListChatMessageResponse
	StreamConnectRequest
	StreamChatEvent
	EventNone
	EventJoin
	EventLeave
	EventLog
	LogActivity
	JournalSubject
	JournalEntry
	CreateJournalEntryRequest
	CreateJournalEntryResponse
	ReadJournalEntryRequest
	ReadJournalEntryResponse
	UpdateJournalEntryRequest
	UpdateJournalEntryResponse
	DeleteJournalEntryRequest
	DeleteJournalEntryResponse
	ListJournalEntryRequest
	ListJournalEntryResponse
	ListJournalSubjectRequest
	ListJournalSubjectResponse
	FeedTag
	FeedAuthor
	FeedArticleDetail
	ReadFeedArticleDetailsRequest
	ReadFeedArticleDetailsResponse
	FeedArticle
	ListFeedArticleRequest
	ListFeedArticleResponse
	NotificationSetting
	CreateNotificationSettingRequest
	CreateNotificationSettingResponse
	ReadNotificationSettingRequest
	ReadNotificationSettingResponse
	UpdateNotificationSettingRequest
	UpdateNotificationSettingResponse
	DeleteNotificationSettingRequest
	DeleteNotificationSettingResponse
	ListNotificationSettingRequest
	ListNotificationSettingResponse
	NotificationDevice
	CreateNotificationDeviceRequest
	CreateNotificationDeviceResponse
	Profile
	CreateProfileRequest
	CreateProfileResponse
	ReadProfileRequest
	ReadProfileResponse
	UpdateProfileRequest
	UpdateProfileResponse
	DeleteProfileRequest
	DeleteProfileResponse
	ListProfileRequest
	ListProfileResponse
	Group
	CreateGroupRequest
	CreateGroupResponse
	ReadGroupRequest
	ReadGroupResponse
	UpdateGroupRequest
	UpdateGroupResponse
	DeleteGroupRequest
	DeleteGroupResponse
	ListGroupRequest
	ListGroupResponse
*/
package pb

import context "context"
import fmt "fmt"
import strings "strings"
import time "time"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import ptypes1 "github.com/golang/protobuf/ptypes"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"

import math "math"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/lyft/protoc-gen-validate/validate"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type ChatMessageORM struct {
	AccountID string
	Author    *ProfileORM `gorm:"foreignkey:ChatMessageId;association_foreignkey:Id"`
	CreatedAt *time.Time
	Id        string `gorm:"type:uuid;primary_key"`
	Text      string
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ChatMessageORM) TableName() string {
	return "chat_messages"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ChatMessage) ToORM(ctx context.Context) (ChatMessageORM, error) {
	to := ChatMessageORM{}
	var err error
	if prehook, ok := interface{}(m).(ChatMessageWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ChatMessage{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Text = m.Text
	if m.Author != nil {
		tempAuthor, err := m.Author.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Author = &tempAuthor
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ChatMessageWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ChatMessageORM) ToPB(ctx context.Context) (ChatMessage, error) {
	to := ChatMessage{}
	var err error
	if prehook, ok := interface{}(m).(ChatMessageWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ChatMessage{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Text = m.Text
	if m.Author != nil {
		tempAuthor, err := m.Author.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Author = &tempAuthor
	}
	if posthook, ok := interface{}(m).(ChatMessageWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ChatMessage the arg will be the target, the caller the one being converted from

// ChatMessageBeforeToORM called before default ToORM code
type ChatMessageWithBeforeToORM interface {
	BeforeToORM(context.Context, *ChatMessageORM) error
}

// ChatMessageAfterToORM called after default ToORM code
type ChatMessageWithAfterToORM interface {
	AfterToORM(context.Context, *ChatMessageORM) error
}

// ChatMessageBeforeToPB called before default ToPB code
type ChatMessageWithBeforeToPB interface {
	BeforeToPB(context.Context, *ChatMessage) error
}

// ChatMessageAfterToPB called after default ToPB code
type ChatMessageWithAfterToPB interface {
	AfterToPB(context.Context, *ChatMessage) error
}

type LogActivityORM struct {
	AccountID string
	CreatedAt *time.Time
	Id        int64 `gorm:"type:serial;primary_key"`
	Ip        string
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (LogActivityORM) TableName() string {
	return "log_activities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LogActivity) ToORM(ctx context.Context) (LogActivityORM, error) {
	to := LogActivityORM{}
	var err error
	if prehook, ok := interface{}(m).(LogActivityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&LogActivity{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Ip = m.Ip
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(LogActivityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LogActivityORM) ToPB(ctx context.Context) (LogActivity, error) {
	to := LogActivity{}
	var err error
	if prehook, ok := interface{}(m).(LogActivityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&LogActivity{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Ip = m.Ip
	if posthook, ok := interface{}(m).(LogActivityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LogActivity the arg will be the target, the caller the one being converted from

// LogActivityBeforeToORM called before default ToORM code
type LogActivityWithBeforeToORM interface {
	BeforeToORM(context.Context, *LogActivityORM) error
}

// LogActivityAfterToORM called after default ToORM code
type LogActivityWithAfterToORM interface {
	AfterToORM(context.Context, *LogActivityORM) error
}

// LogActivityBeforeToPB called before default ToPB code
type LogActivityWithBeforeToPB interface {
	BeforeToPB(context.Context, *LogActivity) error
}

// LogActivityAfterToPB called after default ToPB code
type LogActivityWithAfterToPB interface {
	AfterToPB(context.Context, *LogActivity) error
}

type JournalSubjectORM struct {
	Id   int64 `gorm:"type:serial;primary_key"`
	Key  string
	Name string
	Type int32
}

// TableName overrides the default tablename generated by GORM
func (JournalSubjectORM) TableName() string {
	return "journal_subjects"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *JournalSubject) ToORM(ctx context.Context) (JournalSubjectORM, error) {
	to := JournalSubjectORM{}
	var err error
	if prehook, ok := interface{}(m).(JournalSubjectWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&JournalSubject{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	to.Type = int32(m.Type)
	if posthook, ok := interface{}(m).(JournalSubjectWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *JournalSubjectORM) ToPB(ctx context.Context) (JournalSubject, error) {
	to := JournalSubject{}
	var err error
	if prehook, ok := interface{}(m).(JournalSubjectWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&JournalSubject{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	to.Type = JournalSubject_Type(m.Type)
	if posthook, ok := interface{}(m).(JournalSubjectWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type JournalSubject the arg will be the target, the caller the one being converted from

// JournalSubjectBeforeToORM called before default ToORM code
type JournalSubjectWithBeforeToORM interface {
	BeforeToORM(context.Context, *JournalSubjectORM) error
}

// JournalSubjectAfterToORM called after default ToORM code
type JournalSubjectWithAfterToORM interface {
	AfterToORM(context.Context, *JournalSubjectORM) error
}

// JournalSubjectBeforeToPB called before default ToPB code
type JournalSubjectWithBeforeToPB interface {
	BeforeToPB(context.Context, *JournalSubject) error
}

// JournalSubjectAfterToPB called after default ToPB code
type JournalSubjectWithAfterToPB interface {
	AfterToPB(context.Context, *JournalSubject) error
}

type JournalEntryORM struct {
	AccountID        string
	CreatedAt        *time.Time
	Id               int64 `gorm:"type:serial;primary_key"`
	JournalSubjectId int64
	Note             string
	Severity         int32
}

// TableName overrides the default tablename generated by GORM
func (JournalEntryORM) TableName() string {
	return "journal_entries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *JournalEntry) ToORM(ctx context.Context) (JournalEntryORM, error) {
	to := JournalEntryORM{}
	var err error
	if prehook, ok := interface{}(m).(JournalEntryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&JournalEntry{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Severity = int32(m.Severity)
	to.Note = m.Note
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	to.JournalSubjectId = m.JournalSubjectId
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(JournalEntryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *JournalEntryORM) ToPB(ctx context.Context) (JournalEntry, error) {
	to := JournalEntry{}
	var err error
	if prehook, ok := interface{}(m).(JournalEntryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&JournalEntry{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Severity = JournalEntry_Severity(m.Severity)
	to.Note = m.Note
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	to.JournalSubjectId = m.JournalSubjectId
	if posthook, ok := interface{}(m).(JournalEntryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type JournalEntry the arg will be the target, the caller the one being converted from

// JournalEntryBeforeToORM called before default ToORM code
type JournalEntryWithBeforeToORM interface {
	BeforeToORM(context.Context, *JournalEntryORM) error
}

// JournalEntryAfterToORM called after default ToORM code
type JournalEntryWithAfterToORM interface {
	AfterToORM(context.Context, *JournalEntryORM) error
}

// JournalEntryBeforeToPB called before default ToPB code
type JournalEntryWithBeforeToPB interface {
	BeforeToPB(context.Context, *JournalEntry) error
}

// JournalEntryAfterToPB called after default ToPB code
type JournalEntryWithAfterToPB interface {
	AfterToPB(context.Context, *JournalEntry) error
}

type FeedTagORM struct {
	FeedArticles []*FeedArticleORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:feed_articles_feed_tags;jointable_foreignkey:feed_tag_id;association_jointable_foreignkey:feed_article_id"`
	Id           int64             `gorm:"type:serial;primary_key"`
	Key          string            `gorm:"unique"`
	Name         string
}

// TableName overrides the default tablename generated by GORM
func (FeedTagORM) TableName() string {
	return "feed_tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FeedTag) ToORM(ctx context.Context) (FeedTagORM, error) {
	to := FeedTagORM{}
	var err error
	if prehook, ok := interface{}(m).(FeedTagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&FeedTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	for _, v := range m.FeedArticles {
		if v != nil {
			if tempFeedArticles, cErr := v.ToORM(ctx); cErr == nil {
				to.FeedArticles = append(to.FeedArticles, &tempFeedArticles)
			} else {
				return to, cErr
			}
		} else {
			to.FeedArticles = append(to.FeedArticles, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeedTagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeedTagORM) ToPB(ctx context.Context) (FeedTag, error) {
	to := FeedTag{}
	var err error
	if prehook, ok := interface{}(m).(FeedTagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&FeedTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	for _, v := range m.FeedArticles {
		if v != nil {
			if tempFeedArticles, cErr := v.ToPB(ctx); cErr == nil {
				to.FeedArticles = append(to.FeedArticles, &tempFeedArticles)
			} else {
				return to, cErr
			}
		} else {
			to.FeedArticles = append(to.FeedArticles, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeedTagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FeedTag the arg will be the target, the caller the one being converted from

// FeedTagBeforeToORM called before default ToORM code
type FeedTagWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeedTagORM) error
}

// FeedTagAfterToORM called after default ToORM code
type FeedTagWithAfterToORM interface {
	AfterToORM(context.Context, *FeedTagORM) error
}

// FeedTagBeforeToPB called before default ToPB code
type FeedTagWithBeforeToPB interface {
	BeforeToPB(context.Context, *FeedTag) error
}

// FeedTagAfterToPB called after default ToPB code
type FeedTagWithAfterToPB interface {
	AfterToPB(context.Context, *FeedTag) error
}

type FeedAuthorORM struct {
	Bio             string
	FeedArticles    []*FeedArticleORM `gorm:"foreignkey:FeedAuthorId;association_foreignkey:Id"`
	Id              int64             `gorm:"type:serial;primary_key"`
	Name            string
	ProfilePhotoUrl string
}

// TableName overrides the default tablename generated by GORM
func (FeedAuthorORM) TableName() string {
	return "feed_authors"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FeedAuthor) ToORM(ctx context.Context) (FeedAuthorORM, error) {
	to := FeedAuthorORM{}
	var err error
	if prehook, ok := interface{}(m).(FeedAuthorWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&FeedAuthor{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.ProfilePhotoUrl = m.ProfilePhotoUrl
	to.Bio = m.Bio
	for _, v := range m.FeedArticles {
		if v != nil {
			if tempFeedArticles, cErr := v.ToORM(ctx); cErr == nil {
				to.FeedArticles = append(to.FeedArticles, &tempFeedArticles)
			} else {
				return to, cErr
			}
		} else {
			to.FeedArticles = append(to.FeedArticles, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeedAuthorWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeedAuthorORM) ToPB(ctx context.Context) (FeedAuthor, error) {
	to := FeedAuthor{}
	var err error
	if prehook, ok := interface{}(m).(FeedAuthorWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&FeedAuthor{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.ProfilePhotoUrl = m.ProfilePhotoUrl
	to.Bio = m.Bio
	for _, v := range m.FeedArticles {
		if v != nil {
			if tempFeedArticles, cErr := v.ToPB(ctx); cErr == nil {
				to.FeedArticles = append(to.FeedArticles, &tempFeedArticles)
			} else {
				return to, cErr
			}
		} else {
			to.FeedArticles = append(to.FeedArticles, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeedAuthorWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FeedAuthor the arg will be the target, the caller the one being converted from

// FeedAuthorBeforeToORM called before default ToORM code
type FeedAuthorWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeedAuthorORM) error
}

// FeedAuthorAfterToORM called after default ToORM code
type FeedAuthorWithAfterToORM interface {
	AfterToORM(context.Context, *FeedAuthorORM) error
}

// FeedAuthorBeforeToPB called before default ToPB code
type FeedAuthorWithBeforeToPB interface {
	BeforeToPB(context.Context, *FeedAuthor) error
}

// FeedAuthorAfterToPB called after default ToPB code
type FeedAuthorWithAfterToPB interface {
	AfterToPB(context.Context, *FeedAuthor) error
}

type FeedArticleDetailORM struct {
	Content     string
	FeedArticle *FeedArticleORM `gorm:"foreignkey:FeedArticleDetailId;association_foreignkey:Id;preload:false"`
	Id          int64           `gorm:"type:serial;primary_key"`
}

// TableName overrides the default tablename generated by GORM
func (FeedArticleDetailORM) TableName() string {
	return "feed_article_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FeedArticleDetail) ToORM(ctx context.Context) (FeedArticleDetailORM, error) {
	to := FeedArticleDetailORM{}
	var err error
	if prehook, ok := interface{}(m).(FeedArticleDetailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&FeedArticleDetail{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Content = m.Content
	if m.FeedArticle != nil {
		tempFeedArticle, err := m.FeedArticle.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.FeedArticle = &tempFeedArticle
	}
	if posthook, ok := interface{}(m).(FeedArticleDetailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeedArticleDetailORM) ToPB(ctx context.Context) (FeedArticleDetail, error) {
	to := FeedArticleDetail{}
	var err error
	if prehook, ok := interface{}(m).(FeedArticleDetailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&FeedArticleDetail{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Content = m.Content
	if m.FeedArticle != nil {
		tempFeedArticle, err := m.FeedArticle.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.FeedArticle = &tempFeedArticle
	}
	if posthook, ok := interface{}(m).(FeedArticleDetailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FeedArticleDetail the arg will be the target, the caller the one being converted from

// FeedArticleDetailBeforeToORM called before default ToORM code
type FeedArticleDetailWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeedArticleDetailORM) error
}

// FeedArticleDetailAfterToORM called after default ToORM code
type FeedArticleDetailWithAfterToORM interface {
	AfterToORM(context.Context, *FeedArticleDetailORM) error
}

// FeedArticleDetailBeforeToPB called before default ToPB code
type FeedArticleDetailWithBeforeToPB interface {
	BeforeToPB(context.Context, *FeedArticleDetail) error
}

// FeedArticleDetailAfterToPB called after default ToPB code
type FeedArticleDetailWithAfterToPB interface {
	AfterToPB(context.Context, *FeedArticleDetail) error
}

type FeedArticleORM struct {
	Content             string
	CoverPictureUrl     string
	CreatedAt           *time.Time
	FeedArticleDetailId *int64
	FeedAuthor          *FeedAuthorORM `gorm:"foreignkey:FeedAuthorId;association_foreignkey:Id"`
	FeedAuthorId        *int64
	FeedTags            []*FeedTagORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:feed_articles_feed_tags;jointable_foreignkey:feed_article_id;association_jointable_foreignkey:feed_tag_id"`
	Id                  int64         `gorm:"type:serial;primary_key"`
	Subtitle            string
	Title               string
}

// TableName overrides the default tablename generated by GORM
func (FeedArticleORM) TableName() string {
	return "feed_articles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FeedArticle) ToORM(ctx context.Context) (FeedArticleORM, error) {
	to := FeedArticleORM{}
	var err error
	if prehook, ok := interface{}(m).(FeedArticleWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&FeedArticle{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	to.Title = m.Title
	to.Subtitle = m.Subtitle
	to.CoverPictureUrl = m.CoverPictureUrl
	to.Content = m.Content
	for _, v := range m.FeedTags {
		if v != nil {
			if tempFeedTags, cErr := v.ToORM(ctx); cErr == nil {
				to.FeedTags = append(to.FeedTags, &tempFeedTags)
			} else {
				return to, cErr
			}
		} else {
			to.FeedTags = append(to.FeedTags, nil)
		}
	}
	if m.FeedAuthor != nil {
		tempFeedAuthor, err := m.FeedAuthor.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.FeedAuthor = &tempFeedAuthor
	}
	if posthook, ok := interface{}(m).(FeedArticleWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeedArticleORM) ToPB(ctx context.Context) (FeedArticle, error) {
	to := FeedArticle{}
	var err error
	if prehook, ok := interface{}(m).(FeedArticleWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&FeedArticle{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	to.Title = m.Title
	to.Subtitle = m.Subtitle
	to.CoverPictureUrl = m.CoverPictureUrl
	to.Content = m.Content
	for _, v := range m.FeedTags {
		if v != nil {
			if tempFeedTags, cErr := v.ToPB(ctx); cErr == nil {
				to.FeedTags = append(to.FeedTags, &tempFeedTags)
			} else {
				return to, cErr
			}
		} else {
			to.FeedTags = append(to.FeedTags, nil)
		}
	}
	if m.FeedAuthor != nil {
		tempFeedAuthor, err := m.FeedAuthor.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.FeedAuthor = &tempFeedAuthor
	}
	if posthook, ok := interface{}(m).(FeedArticleWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FeedArticle the arg will be the target, the caller the one being converted from

// FeedArticleBeforeToORM called before default ToORM code
type FeedArticleWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeedArticleORM) error
}

// FeedArticleAfterToORM called after default ToORM code
type FeedArticleWithAfterToORM interface {
	AfterToORM(context.Context, *FeedArticleORM) error
}

// FeedArticleBeforeToPB called before default ToPB code
type FeedArticleWithBeforeToPB interface {
	BeforeToPB(context.Context, *FeedArticle) error
}

// FeedArticleAfterToPB called after default ToPB code
type FeedArticleWithAfterToPB interface {
	AfterToPB(context.Context, *FeedArticle) error
}

type NotificationSettingORM struct {
	AccountID             string
	CreatedAt             *time.Time
	CronJournalReminder   string
	EnableJournalReminder bool
	EnableNotifications   bool
	Id                    int64 `gorm:"type:serial;primary_key"`
	UpdatedAt             *time.Time
}

// TableName overrides the default tablename generated by GORM
func (NotificationSettingORM) TableName() string {
	return "notification_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationSetting) ToORM(ctx context.Context) (NotificationSettingORM, error) {
	to := NotificationSettingORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSettingWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&NotificationSetting{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.EnableNotifications = m.EnableNotifications
	to.EnableJournalReminder = m.EnableJournalReminder
	to.CronJournalReminder = m.CronJournalReminder
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(NotificationSettingWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationSettingORM) ToPB(ctx context.Context) (NotificationSetting, error) {
	to := NotificationSetting{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSettingWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&NotificationSetting{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.EnableNotifications = m.EnableNotifications
	to.EnableJournalReminder = m.EnableJournalReminder
	to.CronJournalReminder = m.CronJournalReminder
	if posthook, ok := interface{}(m).(NotificationSettingWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationSetting the arg will be the target, the caller the one being converted from

// NotificationSettingBeforeToORM called before default ToORM code
type NotificationSettingWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationSettingORM) error
}

// NotificationSettingAfterToORM called after default ToORM code
type NotificationSettingWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationSettingORM) error
}

// NotificationSettingBeforeToPB called before default ToPB code
type NotificationSettingWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationSetting) error
}

// NotificationSettingAfterToPB called after default ToPB code
type NotificationSettingWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationSetting) error
}

type NotificationDeviceORM struct {
	AccountID   string
	CreatedAt   *time.Time
	DeviceToken string `gorm:"unique"`
	Id          int64  `gorm:"type:serial;primary_key;not null"`
	UpdatedAt   *time.Time
}

// TableName overrides the default tablename generated by GORM
func (NotificationDeviceORM) TableName() string {
	return "notification_devices"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationDevice) ToORM(ctx context.Context) (NotificationDeviceORM, error) {
	to := NotificationDeviceORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationDeviceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&NotificationDevice{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.DeviceToken = m.DeviceToken
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(NotificationDeviceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationDeviceORM) ToPB(ctx context.Context) (NotificationDevice, error) {
	to := NotificationDevice{}
	var err error
	if prehook, ok := interface{}(m).(NotificationDeviceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&NotificationDevice{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.DeviceToken = m.DeviceToken
	if posthook, ok := interface{}(m).(NotificationDeviceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationDevice the arg will be the target, the caller the one being converted from

// NotificationDeviceBeforeToORM called before default ToORM code
type NotificationDeviceWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationDeviceORM) error
}

// NotificationDeviceAfterToORM called after default ToORM code
type NotificationDeviceWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationDeviceORM) error
}

// NotificationDeviceBeforeToPB called before default ToPB code
type NotificationDeviceWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationDevice) error
}

// NotificationDeviceAfterToPB called after default ToPB code
type NotificationDeviceWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationDevice) error
}

type ProfileORM struct {
	AccountID     string
	ChatMessageId *string
	FirstName     string
	Groups        []*GroupORM `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	Id            string      `gorm:"type:text;primary_key;not null"`
	LastName      string
	Notes         string
	PrimaryEmail  string `gorm:"unique"`
}

// TableName overrides the default tablename generated by GORM
func (ProfileORM) TableName() string {
	return "profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Profile) ToORM(ctx context.Context) (ProfileORM, error) {
	to := ProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&Profile{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Notes = m.Notes
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.PrimaryEmail = m.PrimaryEmail
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToORM(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ProfileORM) ToPB(ctx context.Context) (Profile, error) {
	to := Profile{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Profile{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Notes = m.Notes
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.PrimaryEmail = m.PrimaryEmail
	for _, v := range m.Groups {
		if v != nil {
			if tempGroups, cErr := v.ToPB(ctx); cErr == nil {
				to.Groups = append(to.Groups, &tempGroups)
			} else {
				return to, cErr
			}
		} else {
			to.Groups = append(to.Groups, nil)
		}
	}
	if posthook, ok := interface{}(m).(ProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Profile the arg will be the target, the caller the one being converted from

// ProfileBeforeToORM called before default ToORM code
type ProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *ProfileORM) error
}

// ProfileAfterToORM called after default ToORM code
type ProfileWithAfterToORM interface {
	AfterToORM(context.Context, *ProfileORM) error
}

// ProfileBeforeToPB called before default ToPB code
type ProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *Profile) error
}

// ProfileAfterToPB called after default ToPB code
type ProfileWithAfterToPB interface {
	AfterToPB(context.Context, *Profile) error
}

type GroupORM struct {
	AccountID string
	Id        int64 `gorm:"type:serial;primary_key"`
	Name      string
	Notes     string
	ProfileId *string
}

// TableName overrides the default tablename generated by GORM
func (GroupORM) TableName() string {
	return "groups"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Group) ToORM(ctx context.Context) (GroupORM, error) {
	to := GroupORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Group{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	if m.ProfileId != nil {
		if v, err := resource1.Decode(&Profile{}, m.ProfileId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ProfileId = &vv
		}
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(GroupWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupORM) ToPB(ctx context.Context) (Group, error) {
	to := Group{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Group{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Notes = m.Notes
	if m.ProfileId != nil {
		if v, err := resource1.Encode(&Profile{}, *m.ProfileId); err != nil {
			return to, err
		} else {
			to.ProfileId = v
		}
	}
	if posthook, ok := interface{}(m).(GroupWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Group the arg will be the target, the caller the one being converted from

// GroupBeforeToORM called before default ToORM code
type GroupWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupORM) error
}

// GroupAfterToORM called after default ToORM code
type GroupWithAfterToORM interface {
	AfterToORM(context.Context, *GroupORM) error
}

// GroupBeforeToPB called before default ToPB code
type GroupWithBeforeToPB interface {
	BeforeToPB(context.Context, *Group) error
}

// GroupAfterToPB called after default ToPB code
type GroupWithAfterToPB interface {
	AfterToPB(context.Context, *Group) error
}

// DefaultCreateChatMessage executes a basic gorm create call
func DefaultCreateChatMessage(ctx context.Context, in *ChatMessage, db *gorm1.DB) (*ChatMessage, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ChatMessageORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadChatMessage executes a basic gorm read call
func DefaultReadChatMessage(ctx context.Context, in *ChatMessage, db *gorm1.DB) (*ChatMessage, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ChatMessageORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ChatMessageORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ChatMessageORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ChatMessageORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteChatMessage(ctx context.Context, in *ChatMessage, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ChatMessageORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ChatMessageORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteChatMessageSet(ctx context.Context, in []*ChatMessage, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ChatMessageORM{})).(ChatMessageORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ChatMessageORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ChatMessageORM{})).(ChatMessageORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ChatMessageORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ChatMessage, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ChatMessage, *gorm1.DB) error
}

// DefaultStrictUpdateChatMessage clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateChatMessage(ctx context.Context, in *ChatMessage, db *gorm1.DB) (*ChatMessage, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateChatMessage")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ChatMessageORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAuthor := ProfileORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterAuthor.ChatMessageId = new(string)
	*filterAuthor.ChatMessageId = ormObj.Id
	if err = db.Where(filterAuthor).Delete(ProfileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ChatMessageORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchChatMessage executes a basic gorm update call with patch behavior
func DefaultPatchChatMessage(ctx context.Context, in *ChatMessage, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ChatMessage, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ChatMessage
	var err error
	if hook, ok := interface{}(&pbObj).(ChatMessageWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadChatMessage(ctx, &ChatMessage{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ChatMessageWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskChatMessage(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ChatMessageWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateChatMessage(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ChatMessageWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ChatMessageWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ChatMessage, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ChatMessage, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ChatMessage, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ChatMessageWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ChatMessage, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetChatMessage executes a bulk gorm update call with patch behavior
func DefaultPatchSetChatMessage(ctx context.Context, objects []*ChatMessage, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ChatMessage, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ChatMessage, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchChatMessage(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskChatMessage patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskChatMessage(ctx context.Context, patchee *ChatMessage, patcher *ChatMessage, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ChatMessage, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedAuthor bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Text" {
			patchee.Text = patcher.Text
			continue
		}
		if !updatedAuthor && strings.HasPrefix(f, prefix+"Author.") {
			updatedAuthor = true
			if patcher.Author == nil {
				patchee.Author = nil
				continue
			}
			if patchee.Author == nil {
				patchee.Author = &Profile{}
			}
			if o, err := DefaultApplyFieldMaskProfile(ctx, patchee.Author, patcher.Author, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Author.", db); err != nil {
				return nil, err
			} else {
				patchee.Author = o
			}
			continue
		}
		if f == prefix+"Author" {
			updatedAuthor = true
			patchee.Author = patcher.Author
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListChatMessage executes a gorm list call
func DefaultListChatMessage(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ChatMessage, error) {
	in := ChatMessage{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ChatMessageORM{}, &ChatMessage{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ChatMessageORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ChatMessageORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ChatMessage{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ChatMessageORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChatMessageORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ChatMessageORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ChatMessageORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateLogActivity executes a basic gorm create call
func DefaultCreateLogActivity(ctx context.Context, in *LogActivity, db *gorm1.DB) (*LogActivity, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LogActivityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadLogActivity executes a basic gorm read call
func DefaultReadLogActivity(ctx context.Context, in *LogActivity, db *gorm1.DB) (*LogActivity, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &LogActivityORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LogActivityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LogActivityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LogActivityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteLogActivity(ctx context.Context, in *LogActivity, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LogActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LogActivityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteLogActivitySet(ctx context.Context, in []*LogActivity, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LogActivityORM{})).(LogActivityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&LogActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LogActivityORM{})).(LogActivityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LogActivityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LogActivity, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LogActivity, *gorm1.DB) error
}

// DefaultStrictUpdateLogActivity clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLogActivity(ctx context.Context, in *LogActivity, db *gorm1.DB) (*LogActivity, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLogActivity")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &LogActivityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LogActivityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchLogActivity executes a basic gorm update call with patch behavior
func DefaultPatchLogActivity(ctx context.Context, in *LogActivity, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*LogActivity, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj LogActivity
	var err error
	if hook, ok := interface{}(&pbObj).(LogActivityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLogActivity(ctx, &LogActivity{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LogActivityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLogActivity(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LogActivityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLogActivity(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LogActivityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LogActivityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LogActivity, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LogActivity, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LogActivity, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LogActivity, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetLogActivity executes a bulk gorm update call with patch behavior
func DefaultPatchSetLogActivity(ctx context.Context, objects []*LogActivity, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*LogActivity, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LogActivity, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLogActivity(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLogActivity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLogActivity(ctx context.Context, patchee *LogActivity, patcher *LogActivity, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*LogActivity, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Ip" {
			patchee.Ip = patcher.Ip
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLogActivity executes a gorm list call
func DefaultListLogActivity(ctx context.Context, db *gorm1.DB) ([]*LogActivity, error) {
	in := LogActivity{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &LogActivityORM{}, &LogActivity{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LogActivityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LogActivityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LogActivity{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LogActivityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LogActivityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]LogActivityORM) error
}

// DefaultCreateJournalSubject executes a basic gorm create call
func DefaultCreateJournalSubject(ctx context.Context, in *JournalSubject, db *gorm1.DB) (*JournalSubject, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type JournalSubjectORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadJournalSubject executes a basic gorm read call
func DefaultReadJournalSubject(ctx context.Context, in *JournalSubject, db *gorm1.DB) (*JournalSubject, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &JournalSubjectORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := JournalSubjectORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(JournalSubjectORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type JournalSubjectORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteJournalSubject(ctx context.Context, in *JournalSubject, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&JournalSubjectORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type JournalSubjectORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteJournalSubjectSet(ctx context.Context, in []*JournalSubject, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&JournalSubjectORM{})).(JournalSubjectORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&JournalSubjectORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&JournalSubjectORM{})).(JournalSubjectORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type JournalSubjectORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*JournalSubject, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*JournalSubject, *gorm1.DB) error
}

// DefaultStrictUpdateJournalSubject clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateJournalSubject(ctx context.Context, in *JournalSubject, db *gorm1.DB) (*JournalSubject, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateJournalSubject")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &JournalSubjectORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type JournalSubjectORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchJournalSubject executes a basic gorm update call with patch behavior
func DefaultPatchJournalSubject(ctx context.Context, in *JournalSubject, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*JournalSubject, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj JournalSubject
	var err error
	if hook, ok := interface{}(&pbObj).(JournalSubjectWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadJournalSubject(ctx, &JournalSubject{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(JournalSubjectWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskJournalSubject(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(JournalSubjectWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateJournalSubject(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(JournalSubjectWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type JournalSubjectWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *JournalSubject, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *JournalSubject, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *JournalSubject, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type JournalSubjectWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *JournalSubject, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetJournalSubject executes a bulk gorm update call with patch behavior
func DefaultPatchSetJournalSubject(ctx context.Context, objects []*JournalSubject, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*JournalSubject, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*JournalSubject, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchJournalSubject(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskJournalSubject patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskJournalSubject(ctx context.Context, patchee *JournalSubject, patcher *JournalSubject, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*JournalSubject, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListJournalSubject executes a gorm list call
func DefaultListJournalSubject(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*JournalSubject, error) {
	in := JournalSubject{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &JournalSubjectORM{}, &JournalSubject{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []JournalSubjectORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalSubjectORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*JournalSubject{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type JournalSubjectORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type JournalSubjectORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type JournalSubjectORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]JournalSubjectORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateJournalEntry executes a basic gorm create call
func DefaultCreateJournalEntry(ctx context.Context, in *JournalEntry, db *gorm1.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type JournalEntryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadJournalEntry executes a basic gorm read call
func DefaultReadJournalEntry(ctx context.Context, in *JournalEntry, db *gorm1.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &JournalEntryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := JournalEntryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(JournalEntryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type JournalEntryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteJournalEntry(ctx context.Context, in *JournalEntry, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&JournalEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type JournalEntryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteJournalEntrySet(ctx context.Context, in []*JournalEntry, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&JournalEntryORM{})).(JournalEntryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&JournalEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&JournalEntryORM{})).(JournalEntryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type JournalEntryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*JournalEntry, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*JournalEntry, *gorm1.DB) error
}

// DefaultStrictUpdateJournalEntry clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateJournalEntry(ctx context.Context, in *JournalEntry, db *gorm1.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateJournalEntry")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &JournalEntryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type JournalEntryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchJournalEntry executes a basic gorm update call with patch behavior
func DefaultPatchJournalEntry(ctx context.Context, in *JournalEntry, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj JournalEntry
	var err error
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadJournalEntry(ctx, &JournalEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskJournalEntry(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateJournalEntry(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(JournalEntryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type JournalEntryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *JournalEntry, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *JournalEntry, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *JournalEntry, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type JournalEntryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *JournalEntry, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetJournalEntry executes a bulk gorm update call with patch behavior
func DefaultPatchSetJournalEntry(ctx context.Context, objects []*JournalEntry, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*JournalEntry, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*JournalEntry, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchJournalEntry(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskJournalEntry patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskJournalEntry(ctx context.Context, patchee *JournalEntry, patcher *JournalEntry, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*JournalEntry, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Severity" {
			patchee.Severity = patcher.Severity
			continue
		}
		if f == prefix+"Note" {
			patchee.Note = patcher.Note
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"JournalSubjectId" {
			patchee.JournalSubjectId = patcher.JournalSubjectId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListJournalEntry executes a gorm list call
func DefaultListJournalEntry(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*JournalEntry, error) {
	in := JournalEntry{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &JournalEntryORM{}, &JournalEntry{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []JournalEntryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*JournalEntry{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type JournalEntryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type JournalEntryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type JournalEntryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]JournalEntryORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateFeedTag executes a basic gorm create call
func DefaultCreateFeedTag(ctx context.Context, in *FeedTag, db *gorm1.DB) (*FeedTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeedTagORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFeedTag executes a basic gorm read call
func DefaultReadFeedTag(ctx context.Context, in *FeedTag, db *gorm1.DB) (*FeedTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FeedTagORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeedTagORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeedTagORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeedTagORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedTag(ctx context.Context, in *FeedTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeedTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeedTagORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedTagSet(ctx context.Context, in []*FeedTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeedTagORM{})).(FeedTagORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeedTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeedTagORM{})).(FeedTagORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeedTagORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FeedTag, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FeedTag, *gorm1.DB) error
}

// DefaultStrictUpdateFeedTag clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeedTag(ctx context.Context, in *FeedTag, db *gorm1.DB) (*FeedTag, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeedTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeedTagORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeedTagORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFeedTag executes a basic gorm update call with patch behavior
func DefaultPatchFeedTag(ctx context.Context, in *FeedTag, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*FeedTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj FeedTag
	var err error
	if hook, ok := interface{}(&pbObj).(FeedTagWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeedTag(ctx, &FeedTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeedTagWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeedTag(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeedTagWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeedTag(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeedTagWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeedTagWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FeedTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FeedTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FeedTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FeedTag, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFeedTag executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeedTag(ctx context.Context, objects []*FeedTag, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*FeedTag, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FeedTag, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeedTag(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeedTag patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeedTag(ctx context.Context, patchee *FeedTag, patcher *FeedTag, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*FeedTag, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"FeedArticles" {
			patchee.FeedArticles = patcher.FeedArticles
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeedTag executes a gorm list call
func DefaultListFeedTag(ctx context.Context, db *gorm1.DB) ([]*FeedTag, error) {
	in := FeedTag{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FeedTagORM{}, &FeedTag{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeedTagORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FeedTag{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeedTagORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FeedTagORM) error
}

// DefaultCreateFeedAuthor executes a basic gorm create call
func DefaultCreateFeedAuthor(ctx context.Context, in *FeedAuthor, db *gorm1.DB) (*FeedAuthor, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeedAuthorORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFeedAuthor executes a basic gorm read call
func DefaultReadFeedAuthor(ctx context.Context, in *FeedAuthor, db *gorm1.DB) (*FeedAuthor, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FeedAuthorORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeedAuthorORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeedAuthorORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeedAuthorORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedAuthor(ctx context.Context, in *FeedAuthor, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeedAuthorORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeedAuthorORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedAuthorSet(ctx context.Context, in []*FeedAuthor, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeedAuthorORM{})).(FeedAuthorORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeedAuthorORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeedAuthorORM{})).(FeedAuthorORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeedAuthorORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FeedAuthor, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FeedAuthor, *gorm1.DB) error
}

// DefaultStrictUpdateFeedAuthor clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeedAuthor(ctx context.Context, in *FeedAuthor, db *gorm1.DB) (*FeedAuthor, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeedAuthor")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeedAuthorORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFeedArticles := FeedArticleORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterFeedArticles.FeedAuthorId = new(int64)
	*filterFeedArticles.FeedAuthorId = ormObj.Id
	if err = db.Where(filterFeedArticles).Delete(FeedArticleORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeedAuthorORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFeedAuthor executes a basic gorm update call with patch behavior
func DefaultPatchFeedAuthor(ctx context.Context, in *FeedAuthor, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*FeedAuthor, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj FeedAuthor
	var err error
	if hook, ok := interface{}(&pbObj).(FeedAuthorWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeedAuthor(ctx, &FeedAuthor{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeedAuthorWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeedAuthor(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeedAuthorWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeedAuthor(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeedAuthorWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeedAuthorWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FeedAuthor, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FeedAuthor, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FeedAuthor, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FeedAuthor, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFeedAuthor executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeedAuthor(ctx context.Context, objects []*FeedAuthor, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*FeedAuthor, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FeedAuthor, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeedAuthor(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeedAuthor patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeedAuthor(ctx context.Context, patchee *FeedAuthor, patcher *FeedAuthor, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*FeedAuthor, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"ProfilePhotoUrl" {
			patchee.ProfilePhotoUrl = patcher.ProfilePhotoUrl
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"FeedArticles" {
			patchee.FeedArticles = patcher.FeedArticles
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeedAuthor executes a gorm list call
func DefaultListFeedAuthor(ctx context.Context, db *gorm1.DB) ([]*FeedAuthor, error) {
	in := FeedAuthor{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FeedAuthorORM{}, &FeedAuthor{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeedAuthorORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FeedAuthor{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeedAuthorORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FeedAuthorORM) error
}

// DefaultCreateFeedArticleDetail executes a basic gorm create call
func DefaultCreateFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, db *gorm1.DB) (*FeedArticleDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeedArticleDetailORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFeedArticleDetail executes a basic gorm read call
func DefaultReadFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, db *gorm1.DB) (*FeedArticleDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FeedArticleDetailORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeedArticleDetailORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeedArticleDetailORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeedArticleDetailORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeedArticleDetailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeedArticleDetailORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedArticleDetailSet(ctx context.Context, in []*FeedArticleDetail, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeedArticleDetailORM{})).(FeedArticleDetailORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeedArticleDetailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeedArticleDetailORM{})).(FeedArticleDetailORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeedArticleDetailORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FeedArticleDetail, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FeedArticleDetail, *gorm1.DB) error
}

// DefaultStrictUpdateFeedArticleDetail clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, db *gorm1.DB) (*FeedArticleDetail, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeedArticleDetail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeedArticleDetailORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFeedArticle := FeedArticleORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterFeedArticle.FeedArticleDetailId = new(int64)
	*filterFeedArticle.FeedArticleDetailId = ormObj.Id
	if err = db.Where(filterFeedArticle).Delete(FeedArticleORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeedArticleDetailORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFeedArticleDetail executes a basic gorm update call with patch behavior
func DefaultPatchFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*FeedArticleDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj FeedArticleDetail
	var err error
	if hook, ok := interface{}(&pbObj).(FeedArticleDetailWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeedArticleDetail(ctx, &FeedArticleDetail{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeedArticleDetailWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeedArticleDetail(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeedArticleDetailWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeedArticleDetail(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeedArticleDetailWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeedArticleDetailWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FeedArticleDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FeedArticleDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FeedArticleDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FeedArticleDetail, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFeedArticleDetail executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeedArticleDetail(ctx context.Context, objects []*FeedArticleDetail, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*FeedArticleDetail, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FeedArticleDetail, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeedArticleDetail(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeedArticleDetail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeedArticleDetail(ctx context.Context, patchee *FeedArticleDetail, patcher *FeedArticleDetail, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*FeedArticleDetail, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedFeedArticle bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if !updatedFeedArticle && strings.HasPrefix(f, prefix+"FeedArticle.") {
			updatedFeedArticle = true
			if patcher.FeedArticle == nil {
				patchee.FeedArticle = nil
				continue
			}
			if patchee.FeedArticle == nil {
				patchee.FeedArticle = &FeedArticle{}
			}
			if o, err := DefaultApplyFieldMaskFeedArticle(ctx, patchee.FeedArticle, patcher.FeedArticle, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"FeedArticle.", db); err != nil {
				return nil, err
			} else {
				patchee.FeedArticle = o
			}
			continue
		}
		if f == prefix+"FeedArticle" {
			updatedFeedArticle = true
			patchee.FeedArticle = patcher.FeedArticle
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeedArticleDetail executes a gorm list call
func DefaultListFeedArticleDetail(ctx context.Context, db *gorm1.DB) ([]*FeedArticleDetail, error) {
	in := FeedArticleDetail{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FeedArticleDetailORM{}, &FeedArticleDetail{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeedArticleDetailORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FeedArticleDetail{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeedArticleDetailORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FeedArticleDetailORM) error
}

// DefaultCreateFeedArticle executes a basic gorm create call
func DefaultCreateFeedArticle(ctx context.Context, in *FeedArticle, db *gorm1.DB) (*FeedArticle, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeedArticleORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFeedArticle executes a basic gorm read call
func DefaultReadFeedArticle(ctx context.Context, in *FeedArticle, db *gorm1.DB) (*FeedArticle, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FeedArticleORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeedArticleORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeedArticleORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeedArticleORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedArticle(ctx context.Context, in *FeedArticle, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeedArticleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeedArticleORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedArticleSet(ctx context.Context, in []*FeedArticle, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeedArticleORM{})).(FeedArticleORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeedArticleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeedArticleORM{})).(FeedArticleORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeedArticleORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FeedArticle, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FeedArticle, *gorm1.DB) error
}

// DefaultStrictUpdateFeedArticle clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeedArticle(ctx context.Context, in *FeedArticle, db *gorm1.DB) (*FeedArticle, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeedArticle")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeedArticleORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeedArticleORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFeedArticle executes a basic gorm update call with patch behavior
func DefaultPatchFeedArticle(ctx context.Context, in *FeedArticle, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*FeedArticle, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj FeedArticle
	var err error
	if hook, ok := interface{}(&pbObj).(FeedArticleWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeedArticle(ctx, &FeedArticle{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeedArticleWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeedArticle(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeedArticleWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeedArticle(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeedArticleWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeedArticleWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FeedArticle, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FeedArticle, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FeedArticle, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FeedArticle, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFeedArticle executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeedArticle(ctx context.Context, objects []*FeedArticle, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*FeedArticle, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FeedArticle, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeedArticle(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeedArticle patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeedArticle(ctx context.Context, patchee *FeedArticle, patcher *FeedArticle, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*FeedArticle, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedFeedAuthor bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"Subtitle" {
			patchee.Subtitle = patcher.Subtitle
			continue
		}
		if f == prefix+"CoverPictureUrl" {
			patchee.CoverPictureUrl = patcher.CoverPictureUrl
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if f == prefix+"FeedTags" {
			patchee.FeedTags = patcher.FeedTags
			continue
		}
		if !updatedFeedAuthor && strings.HasPrefix(f, prefix+"FeedAuthor.") {
			updatedFeedAuthor = true
			if patcher.FeedAuthor == nil {
				patchee.FeedAuthor = nil
				continue
			}
			if patchee.FeedAuthor == nil {
				patchee.FeedAuthor = &FeedAuthor{}
			}
			if o, err := DefaultApplyFieldMaskFeedAuthor(ctx, patchee.FeedAuthor, patcher.FeedAuthor, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"FeedAuthor.", db); err != nil {
				return nil, err
			} else {
				patchee.FeedAuthor = o
			}
			continue
		}
		if f == prefix+"FeedAuthor" {
			updatedFeedAuthor = true
			patchee.FeedAuthor = patcher.FeedAuthor
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeedArticle executes a gorm list call
func DefaultListFeedArticle(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*FeedArticle, error) {
	in := FeedArticle{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FeedArticleORM{}, &FeedArticle{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeedArticleORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FeedArticle{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeedArticleORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type FeedArticleORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FeedArticleORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateNotificationSetting executes a basic gorm create call
func DefaultCreateNotificationSetting(ctx context.Context, in *NotificationSetting, db *gorm1.DB) (*NotificationSetting, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSettingORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadNotificationSetting executes a basic gorm read call
func DefaultReadNotificationSetting(ctx context.Context, in *NotificationSetting, db *gorm1.DB) (*NotificationSetting, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &NotificationSettingORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationSettingORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationSettingORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSettingORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteNotificationSetting(ctx context.Context, in *NotificationSetting, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationSettingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationSettingORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteNotificationSettingSet(ctx context.Context, in []*NotificationSetting, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NotificationSettingORM{})).(NotificationSettingORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&NotificationSettingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationSettingORM{})).(NotificationSettingORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationSettingORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationSetting, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationSetting, *gorm1.DB) error
}

// DefaultStrictUpdateNotificationSetting clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationSetting(ctx context.Context, in *NotificationSetting, db *gorm1.DB) (*NotificationSetting, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationSetting")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &NotificationSettingORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationSettingORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchNotificationSetting executes a basic gorm update call with patch behavior
func DefaultPatchNotificationSetting(ctx context.Context, in *NotificationSetting, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*NotificationSetting, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj NotificationSetting
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationSettingWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNotificationSetting(ctx, &NotificationSetting{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NotificationSettingWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationSetting(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationSettingWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationSetting(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationSettingWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationSettingWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationSetting, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationSetting, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationSetting, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationSettingWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationSetting, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetNotificationSetting executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationSetting(ctx context.Context, objects []*NotificationSetting, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*NotificationSetting, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationSetting, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationSetting(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationSetting patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationSetting(ctx context.Context, patchee *NotificationSetting, patcher *NotificationSetting, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*NotificationSetting, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"EnableNotifications" {
			patchee.EnableNotifications = patcher.EnableNotifications
			continue
		}
		if f == prefix+"EnableJournalReminder" {
			patchee.EnableJournalReminder = patcher.EnableJournalReminder
			continue
		}
		if f == prefix+"CronJournalReminder" {
			patchee.CronJournalReminder = patcher.CronJournalReminder
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationSetting executes a gorm list call
func DefaultListNotificationSetting(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*NotificationSetting, error) {
	in := NotificationSetting{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &NotificationSettingORM{}, &NotificationSetting{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NotificationSettingORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationSetting{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationSettingORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type NotificationSettingORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type NotificationSettingORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]NotificationSettingORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateNotificationDevice executes a basic gorm create call
func DefaultCreateNotificationDevice(ctx context.Context, in *NotificationDevice, db *gorm1.DB) (*NotificationDevice, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationDeviceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadNotificationDevice executes a basic gorm read call
func DefaultReadNotificationDevice(ctx context.Context, in *NotificationDevice, db *gorm1.DB) (*NotificationDevice, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &NotificationDeviceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationDeviceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationDeviceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationDeviceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteNotificationDevice(ctx context.Context, in *NotificationDevice, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationDeviceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationDeviceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteNotificationDeviceSet(ctx context.Context, in []*NotificationDevice, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NotificationDeviceORM{})).(NotificationDeviceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&NotificationDeviceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationDeviceORM{})).(NotificationDeviceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationDeviceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationDevice, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationDevice, *gorm1.DB) error
}

// DefaultStrictUpdateNotificationDevice clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationDevice(ctx context.Context, in *NotificationDevice, db *gorm1.DB) (*NotificationDevice, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationDevice")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &NotificationDeviceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationDeviceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchNotificationDevice executes a basic gorm update call with patch behavior
func DefaultPatchNotificationDevice(ctx context.Context, in *NotificationDevice, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*NotificationDevice, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj NotificationDevice
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationDeviceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNotificationDevice(ctx, &NotificationDevice{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NotificationDeviceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationDevice(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationDeviceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationDevice(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationDeviceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationDeviceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationDevice, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationDevice, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationDevice, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationDevice, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetNotificationDevice executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationDevice(ctx context.Context, objects []*NotificationDevice, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*NotificationDevice, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationDevice, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationDevice(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationDevice patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationDevice(ctx context.Context, patchee *NotificationDevice, patcher *NotificationDevice, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*NotificationDevice, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeviceToken" {
			patchee.DeviceToken = patcher.DeviceToken
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationDevice executes a gorm list call
func DefaultListNotificationDevice(ctx context.Context, db *gorm1.DB) ([]*NotificationDevice, error) {
	in := NotificationDevice{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &NotificationDeviceORM{}, &NotificationDevice{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NotificationDeviceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationDeviceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationDevice{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationDeviceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationDeviceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]NotificationDeviceORM) error
}

// DefaultCreateProfile executes a basic gorm create call
func DefaultCreateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadProfile executes a basic gorm read call
func DefaultReadProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteProfile(ctx context.Context, in *Profile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteProfileSet(ctx context.Context, in []*Profile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ProfileORM{})).(ProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ProfileORM{})).(ProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Profile, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Profile, *gorm1.DB) error
}

// DefaultStrictUpdateProfile clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterGroups := GroupORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterGroups.ProfileId = new(string)
	*filterGroups.ProfileId = ormObj.Id
	if err = db.Where(filterGroups).Delete(GroupORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchProfile executes a basic gorm update call with patch behavior
func DefaultPatchProfile(ctx context.Context, in *Profile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Profile
	var err error
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadProfile(ctx, &Profile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetProfile(ctx context.Context, objects []*Profile, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Profile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Profile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskProfile(ctx context.Context, patchee *Profile, patcher *Profile, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Profile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"PrimaryEmail" {
			patchee.PrimaryEmail = patcher.PrimaryEmail
			continue
		}
		if f == prefix+"Groups" {
			patchee.Groups = patcher.Groups
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListProfile executes a gorm list call
func DefaultListProfile(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Profile, error) {
	in := Profile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ProfileORM{}, &Profile{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Profile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ProfileORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateGroup executes a basic gorm create call
func DefaultCreateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadGroup executes a basic gorm read call
func DefaultReadGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &GroupORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := GroupORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(GroupORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteGroup(ctx context.Context, in *Group, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type GroupORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteGroupSet(ctx context.Context, in []*Group, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type GroupORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Group, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Group, *gorm1.DB) error
}

// DefaultStrictUpdateGroup clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &GroupORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type GroupORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchGroup executes a basic gorm update call with patch behavior
func DefaultPatchGroup(ctx context.Context, in *Group, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Group
	var err error
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskGroup(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateGroup(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(GroupWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type GroupWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetGroup executes a bulk gorm update call with patch behavior
func DefaultPatchSetGroup(ctx context.Context, objects []*Group, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Group, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Group, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchGroup(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskGroup patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroup(ctx context.Context, patchee *Group, patcher *Group, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Group, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if f == prefix+"ProfileId" {
			patchee.ProfileId = patcher.ProfileId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroup executes a gorm list call
func DefaultListGroup(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Group, error) {
	in := Group{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &GroupORM{}, &Group{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []GroupORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Group{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type GroupORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type GroupORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type GroupORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]GroupORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type ChatMessagesDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ChatMessagesDefaultServer) Create(ctx context.Context, in *CreateChatMessageRequest) (*CreateChatMessageResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ChatMessagesChatMessageWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateChatMessage(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateChatMessageResponse{Result: res}
	if custom, ok := interface{}(in).(ChatMessagesChatMessageWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChatMessagesChatMessageWithBeforeCreate called before DefaultCreateChatMessage in the default Create handler
type ChatMessagesChatMessageWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChatMessagesChatMessageWithAfterCreate called before DefaultCreateChatMessage in the default Create handler
type ChatMessagesChatMessageWithAfterCreate interface {
	AfterCreate(context.Context, *CreateChatMessageResponse, *gorm1.DB) error
}

// List ...
func (m *ChatMessagesDefaultServer) List(ctx context.Context, in *ListChatMessageRequest) (*ListChatMessageResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ChatMessagesChatMessageWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListChatMessage(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListChatMessageResponse{Results: res}
	if custom, ok := interface{}(in).(ChatMessagesChatMessageWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ChatMessagesChatMessageWithBeforeList called before DefaultListChatMessage in the default List handler
type ChatMessagesChatMessageWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ChatMessagesChatMessageWithAfterList called before DefaultListChatMessage in the default List handler
type ChatMessagesChatMessageWithAfterList interface {
	AfterList(context.Context, *ListChatMessageResponse, *gorm1.DB) error
}

// Stream ...
func (m *ChatMessagesDefaultServer) Stream(ctx context.Context, in *StreamConnectRequest) (*StreamChatEvent, error) {
	out := &StreamChatEvent{}
	return out, nil
}

type JournalEntriesDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *JournalEntriesDefaultServer) Create(ctx context.Context, in *CreateJournalEntryRequest) (*CreateJournalEntryResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateJournalEntry(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateJournalEntryResponse{Result: res}
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// JournalEntriesJournalEntryWithBeforeCreate called before DefaultCreateJournalEntry in the default Create handler
type JournalEntriesJournalEntryWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// JournalEntriesJournalEntryWithAfterCreate called before DefaultCreateJournalEntry in the default Create handler
type JournalEntriesJournalEntryWithAfterCreate interface {
	AfterCreate(context.Context, *CreateJournalEntryResponse, *gorm1.DB) error
}

// Read ...
func (m *JournalEntriesDefaultServer) Read(ctx context.Context, in *ReadJournalEntryRequest) (*ReadJournalEntryResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadJournalEntry(ctx, &JournalEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadJournalEntryResponse{Result: res}
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// JournalEntriesJournalEntryWithBeforeRead called before DefaultReadJournalEntry in the default Read handler
type JournalEntriesJournalEntryWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// JournalEntriesJournalEntryWithAfterRead called before DefaultReadJournalEntry in the default Read handler
type JournalEntriesJournalEntryWithAfterRead interface {
	AfterRead(context.Context, *ReadJournalEntryResponse, *gorm1.DB) error
}

// Update ...
func (m *JournalEntriesDefaultServer) Update(ctx context.Context, in *UpdateJournalEntryRequest) (*UpdateJournalEntryResponse, error) {
	var err error
	var res *JournalEntry
	db := m.DB
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateJournalEntry(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateJournalEntryResponse{Result: res}
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// JournalEntriesJournalEntryWithBeforeUpdate called before DefaultUpdateJournalEntry in the default Update handler
type JournalEntriesJournalEntryWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// JournalEntriesJournalEntryWithAfterUpdate called before DefaultUpdateJournalEntry in the default Update handler
type JournalEntriesJournalEntryWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateJournalEntryResponse, *gorm1.DB) error
}

// Delete ...
func (m *JournalEntriesDefaultServer) Delete(ctx context.Context, in *DeleteJournalEntryRequest) (*DeleteJournalEntryResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteJournalEntry(ctx, &JournalEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteJournalEntryResponse{}
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// JournalEntriesJournalEntryWithBeforeDelete called before DefaultDeleteJournalEntry in the default Delete handler
type JournalEntriesJournalEntryWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// JournalEntriesJournalEntryWithAfterDelete called before DefaultDeleteJournalEntry in the default Delete handler
type JournalEntriesJournalEntryWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteJournalEntryResponse, *gorm1.DB) error
}

// List ...
func (m *JournalEntriesDefaultServer) List(ctx context.Context, in *ListJournalEntryRequest) (*ListJournalEntryResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListJournalEntry(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListJournalEntryResponse{Results: res}
	if custom, ok := interface{}(in).(JournalEntriesJournalEntryWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// JournalEntriesJournalEntryWithBeforeList called before DefaultListJournalEntry in the default List handler
type JournalEntriesJournalEntryWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// JournalEntriesJournalEntryWithAfterList called before DefaultListJournalEntry in the default List handler
type JournalEntriesJournalEntryWithAfterList interface {
	AfterList(context.Context, *ListJournalEntryResponse, *gorm1.DB) error
}
type JournalSubjectsDefaultServer struct {
	DB *gorm1.DB
}

// List ...
func (m *JournalSubjectsDefaultServer) List(ctx context.Context, in *ListJournalSubjectRequest) (*ListJournalSubjectResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(JournalSubjectsJournalSubjectWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListJournalSubject(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListJournalSubjectResponse{Results: res}
	if custom, ok := interface{}(in).(JournalSubjectsJournalSubjectWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// JournalSubjectsJournalSubjectWithBeforeList called before DefaultListJournalSubject in the default List handler
type JournalSubjectsJournalSubjectWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// JournalSubjectsJournalSubjectWithAfterList called before DefaultListJournalSubject in the default List handler
type JournalSubjectsJournalSubjectWithAfterList interface {
	AfterList(context.Context, *ListJournalSubjectResponse, *gorm1.DB) error
}
type FeedArticlesDefaultServer struct {
	DB *gorm1.DB
}

// List ...
func (m *FeedArticlesDefaultServer) List(ctx context.Context, in *ListFeedArticleRequest) (*ListFeedArticleResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(FeedArticlesFeedArticleWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListFeedArticle(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListFeedArticleResponse{Results: res}
	if custom, ok := interface{}(in).(FeedArticlesFeedArticleWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// FeedArticlesFeedArticleWithBeforeList called before DefaultListFeedArticle in the default List handler
type FeedArticlesFeedArticleWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// FeedArticlesFeedArticleWithAfterList called before DefaultListFeedArticle in the default List handler
type FeedArticlesFeedArticleWithAfterList interface {
	AfterList(context.Context, *ListFeedArticleResponse, *gorm1.DB) error
}
type FeedArticleDetailsDefaultServer struct {
	DB *gorm1.DB
}

// Read ...
func (m *FeedArticleDetailsDefaultServer) Read(ctx context.Context, in *ReadFeedArticleDetailsRequest) (*ReadFeedArticleDetailsResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(FeedArticleDetailsFeedArticleDetailWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadFeedArticleDetail(ctx, &FeedArticleDetail{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadFeedArticleDetailsResponse{Result: res}
	if custom, ok := interface{}(in).(FeedArticleDetailsFeedArticleDetailWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// FeedArticleDetailsFeedArticleDetailWithBeforeRead called before DefaultReadFeedArticleDetail in the default Read handler
type FeedArticleDetailsFeedArticleDetailWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// FeedArticleDetailsFeedArticleDetailWithAfterRead called before DefaultReadFeedArticleDetail in the default Read handler
type FeedArticleDetailsFeedArticleDetailWithAfterRead interface {
	AfterRead(context.Context, *ReadFeedArticleDetailsResponse, *gorm1.DB) error
}
type NotificationSettingsDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *NotificationSettingsDefaultServer) Create(ctx context.Context, in *CreateNotificationSettingRequest) (*CreateNotificationSettingResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateNotificationSetting(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateNotificationSettingResponse{Result: res}
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NotificationSettingsNotificationSettingWithBeforeCreate called before DefaultCreateNotificationSetting in the default Create handler
type NotificationSettingsNotificationSettingWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NotificationSettingsNotificationSettingWithAfterCreate called before DefaultCreateNotificationSetting in the default Create handler
type NotificationSettingsNotificationSettingWithAfterCreate interface {
	AfterCreate(context.Context, *CreateNotificationSettingResponse, *gorm1.DB) error
}

// Read ...
func (m *NotificationSettingsDefaultServer) Read(ctx context.Context, in *ReadNotificationSettingRequest) (*ReadNotificationSettingResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadNotificationSetting(ctx, &NotificationSetting{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadNotificationSettingResponse{Result: res}
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NotificationSettingsNotificationSettingWithBeforeRead called before DefaultReadNotificationSetting in the default Read handler
type NotificationSettingsNotificationSettingWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NotificationSettingsNotificationSettingWithAfterRead called before DefaultReadNotificationSetting in the default Read handler
type NotificationSettingsNotificationSettingWithAfterRead interface {
	AfterRead(context.Context, *ReadNotificationSettingResponse, *gorm1.DB) error
}

// Update ...
func (m *NotificationSettingsDefaultServer) Update(ctx context.Context, in *UpdateNotificationSettingRequest) (*UpdateNotificationSettingResponse, error) {
	var err error
	var res *NotificationSetting
	db := m.DB
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateNotificationSetting(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateNotificationSettingResponse{Result: res}
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NotificationSettingsNotificationSettingWithBeforeUpdate called before DefaultUpdateNotificationSetting in the default Update handler
type NotificationSettingsNotificationSettingWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NotificationSettingsNotificationSettingWithAfterUpdate called before DefaultUpdateNotificationSetting in the default Update handler
type NotificationSettingsNotificationSettingWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateNotificationSettingResponse, *gorm1.DB) error
}

// Delete ...
func (m *NotificationSettingsDefaultServer) Delete(ctx context.Context, in *DeleteNotificationSettingRequest) (*DeleteNotificationSettingResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteNotificationSetting(ctx, &NotificationSetting{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteNotificationSettingResponse{}
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NotificationSettingsNotificationSettingWithBeforeDelete called before DefaultDeleteNotificationSetting in the default Delete handler
type NotificationSettingsNotificationSettingWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NotificationSettingsNotificationSettingWithAfterDelete called before DefaultDeleteNotificationSetting in the default Delete handler
type NotificationSettingsNotificationSettingWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteNotificationSettingResponse, *gorm1.DB) error
}

// List ...
func (m *NotificationSettingsDefaultServer) List(ctx context.Context, in *ListNotificationSettingRequest) (*ListNotificationSettingResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListNotificationSetting(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListNotificationSettingResponse{Results: res}
	if custom, ok := interface{}(in).(NotificationSettingsNotificationSettingWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NotificationSettingsNotificationSettingWithBeforeList called before DefaultListNotificationSetting in the default List handler
type NotificationSettingsNotificationSettingWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NotificationSettingsNotificationSettingWithAfterList called before DefaultListNotificationSetting in the default List handler
type NotificationSettingsNotificationSettingWithAfterList interface {
	AfterList(context.Context, *ListNotificationSettingResponse, *gorm1.DB) error
}
type NotificationDevicesDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *NotificationDevicesDefaultServer) Create(ctx context.Context, in *CreateNotificationDeviceRequest) (*CreateNotificationDeviceResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(NotificationDevicesNotificationDeviceWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateNotificationDevice(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateNotificationDeviceResponse{Result: res}
	if custom, ok := interface{}(in).(NotificationDevicesNotificationDeviceWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// NotificationDevicesNotificationDeviceWithBeforeCreate called before DefaultCreateNotificationDevice in the default Create handler
type NotificationDevicesNotificationDeviceWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// NotificationDevicesNotificationDeviceWithAfterCreate called before DefaultCreateNotificationDevice in the default Create handler
type NotificationDevicesNotificationDeviceWithAfterCreate interface {
	AfterCreate(context.Context, *CreateNotificationDeviceResponse, *gorm1.DB) error
}
type ProfilesDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *ProfilesDefaultServer) Create(ctx context.Context, in *CreateProfileRequest) (*CreateProfileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateProfile(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateProfileResponse{Result: res}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeCreate called before DefaultCreateProfile in the default Create handler
type ProfilesProfileWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterCreate called before DefaultCreateProfile in the default Create handler
type ProfilesProfileWithAfterCreate interface {
	AfterCreate(context.Context, *CreateProfileResponse, *gorm1.DB) error
}

// Read ...
func (m *ProfilesDefaultServer) Read(ctx context.Context, in *ReadProfileRequest) (*ReadProfileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadProfile(ctx, &Profile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadProfileResponse{Result: res}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeRead called before DefaultReadProfile in the default Read handler
type ProfilesProfileWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterRead called before DefaultReadProfile in the default Read handler
type ProfilesProfileWithAfterRead interface {
	AfterRead(context.Context, *ReadProfileResponse, *gorm1.DB) error
}

// Update ...
func (m *ProfilesDefaultServer) Update(ctx context.Context, in *UpdateProfileRequest) (*UpdateProfileResponse, error) {
	var err error
	var res *Profile
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateProfile(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateProfileResponse{Result: res}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeUpdate called before DefaultUpdateProfile in the default Update handler
type ProfilesProfileWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterUpdate called before DefaultUpdateProfile in the default Update handler
type ProfilesProfileWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateProfileResponse, *gorm1.DB) error
}

// Delete ...
func (m *ProfilesDefaultServer) Delete(ctx context.Context, in *DeleteProfileRequest) (*DeleteProfileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteProfile(ctx, &Profile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteProfileResponse{}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeDelete called before DefaultDeleteProfile in the default Delete handler
type ProfilesProfileWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterDelete called before DefaultDeleteProfile in the default Delete handler
type ProfilesProfileWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteProfileResponse, *gorm1.DB) error
}

// List ...
func (m *ProfilesDefaultServer) List(ctx context.Context, in *ListProfileRequest) (*ListProfileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ProfilesProfileWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListProfile(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListProfileResponse{Results: res}
	if custom, ok := interface{}(in).(ProfilesProfileWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ProfilesProfileWithBeforeList called before DefaultListProfile in the default List handler
type ProfilesProfileWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ProfilesProfileWithAfterList called before DefaultListProfile in the default List handler
type ProfilesProfileWithAfterList interface {
	AfterList(context.Context, *ListProfileResponse, *gorm1.DB) error
}
type GroupsDefaultServer struct {
	DB *gorm1.DB
}

// Create ...
func (m *GroupsDefaultServer) Create(ctx context.Context, in *CreateGroupRequest) (*CreateGroupResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeCreate); ok {
		var err error
		if db, err = custom.BeforeCreate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateGroup(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateGroupResponse{Result: res}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterCreate); ok {
		var err error
		if err = custom.AfterCreate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeCreate called before DefaultCreateGroup in the default Create handler
type GroupsGroupWithBeforeCreate interface {
	BeforeCreate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterCreate called before DefaultCreateGroup in the default Create handler
type GroupsGroupWithAfterCreate interface {
	AfterCreate(context.Context, *CreateGroupResponse, *gorm1.DB) error
}

// Read ...
func (m *GroupsDefaultServer) Read(ctx context.Context, in *ReadGroupRequest) (*ReadGroupResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadGroupResponse{Result: res}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeRead called before DefaultReadGroup in the default Read handler
type GroupsGroupWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterRead called before DefaultReadGroup in the default Read handler
type GroupsGroupWithAfterRead interface {
	AfterRead(context.Context, *ReadGroupResponse, *gorm1.DB) error
}

// Update ...
func (m *GroupsDefaultServer) Update(ctx context.Context, in *UpdateGroupRequest) (*UpdateGroupResponse, error) {
	var err error
	var res *Group
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeUpdate); ok {
		var err error
		if db, err = custom.BeforeUpdate(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateGroup(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateGroupResponse{Result: res}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterUpdate); ok {
		var err error
		if err = custom.AfterUpdate(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeUpdate called before DefaultUpdateGroup in the default Update handler
type GroupsGroupWithBeforeUpdate interface {
	BeforeUpdate(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterUpdate called before DefaultUpdateGroup in the default Update handler
type GroupsGroupWithAfterUpdate interface {
	AfterUpdate(context.Context, *UpdateGroupResponse, *gorm1.DB) error
}

// Delete ...
func (m *GroupsDefaultServer) Delete(ctx context.Context, in *DeleteGroupRequest) (*DeleteGroupResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeDelete); ok {
		var err error
		if db, err = custom.BeforeDelete(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteGroupResponse{}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterDelete); ok {
		var err error
		if err = custom.AfterDelete(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeDelete called before DefaultDeleteGroup in the default Delete handler
type GroupsGroupWithBeforeDelete interface {
	BeforeDelete(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterDelete called before DefaultDeleteGroup in the default Delete handler
type GroupsGroupWithAfterDelete interface {
	AfterDelete(context.Context, *DeleteGroupResponse, *gorm1.DB) error
}

// List ...
func (m *GroupsDefaultServer) List(ctx context.Context, in *ListGroupRequest) (*ListGroupResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(GroupsGroupWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListGroup(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListGroupResponse{Results: res}
	if custom, ok := interface{}(in).(GroupsGroupWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// GroupsGroupWithBeforeList called before DefaultListGroup in the default List handler
type GroupsGroupWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// GroupsGroupWithAfterList called before DefaultListGroup in the default List handler
type GroupsGroupWithAfterList interface {
	AfterList(context.Context, *ListGroupResponse, *gorm1.DB) error
}

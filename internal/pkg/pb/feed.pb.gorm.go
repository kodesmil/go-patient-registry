// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/kodesmil/ks-model/feed.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

package pb

import context "context"
import fmt "fmt"
import strings "strings"
import time "time"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import json1 "encoding/json"
import ptypes1 "github.com/golang/protobuf/ptypes"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"
import trace1 "go.opencensus.io/trace"

import math "math"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/envoyproxy/protoc-gen-validate/validate"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type FeedTagORM struct {
	FeedArticles []*FeedArticleORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:feed_articles_feed_tags;jointable_foreignkey:feed_tag_id;association_jointable_foreignkey:feed_article_id"`
	Id           int64             `gorm:"type:serial;primary_key"`
	Key          string            `gorm:"unique"`
	Name         string
}

// TableName overrides the default tablename generated by GORM
func (FeedTagORM) TableName() string {
	return "feed_tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FeedTag) ToORM(ctx context.Context) (FeedTagORM, error) {
	to := FeedTagORM{}
	var err error
	if prehook, ok := interface{}(m).(FeedTagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&FeedTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	for _, v := range m.FeedArticles {
		if v != nil {
			if tempFeedArticles, cErr := v.ToORM(ctx); cErr == nil {
				to.FeedArticles = append(to.FeedArticles, &tempFeedArticles)
			} else {
				return to, cErr
			}
		} else {
			to.FeedArticles = append(to.FeedArticles, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeedTagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeedTagORM) ToPB(ctx context.Context) (FeedTag, error) {
	to := FeedTag{}
	var err error
	if prehook, ok := interface{}(m).(FeedTagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&FeedTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	for _, v := range m.FeedArticles {
		if v != nil {
			if tempFeedArticles, cErr := v.ToPB(ctx); cErr == nil {
				to.FeedArticles = append(to.FeedArticles, &tempFeedArticles)
			} else {
				return to, cErr
			}
		} else {
			to.FeedArticles = append(to.FeedArticles, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeedTagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FeedTag the arg will be the target, the caller the one being converted from

// FeedTagBeforeToORM called before default ToORM code
type FeedTagWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeedTagORM) error
}

// FeedTagAfterToORM called after default ToORM code
type FeedTagWithAfterToORM interface {
	AfterToORM(context.Context, *FeedTagORM) error
}

// FeedTagBeforeToPB called before default ToPB code
type FeedTagWithBeforeToPB interface {
	BeforeToPB(context.Context, *FeedTag) error
}

// FeedTagAfterToPB called after default ToPB code
type FeedTagWithAfterToPB interface {
	AfterToPB(context.Context, *FeedTag) error
}

type FeedAuthorORM struct {
	Bio             string
	FeedArticles    []*FeedArticleORM `gorm:"foreignkey:FeedAuthorId;association_foreignkey:Id"`
	Id              int64             `gorm:"type:serial;primary_key"`
	Name            string
	ProfilePhotoUrl string
}

// TableName overrides the default tablename generated by GORM
func (FeedAuthorORM) TableName() string {
	return "feed_authors"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FeedAuthor) ToORM(ctx context.Context) (FeedAuthorORM, error) {
	to := FeedAuthorORM{}
	var err error
	if prehook, ok := interface{}(m).(FeedAuthorWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&FeedAuthor{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.ProfilePhotoUrl = m.ProfilePhotoUrl
	to.Bio = m.Bio
	for _, v := range m.FeedArticles {
		if v != nil {
			if tempFeedArticles, cErr := v.ToORM(ctx); cErr == nil {
				to.FeedArticles = append(to.FeedArticles, &tempFeedArticles)
			} else {
				return to, cErr
			}
		} else {
			to.FeedArticles = append(to.FeedArticles, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeedAuthorWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeedAuthorORM) ToPB(ctx context.Context) (FeedAuthor, error) {
	to := FeedAuthor{}
	var err error
	if prehook, ok := interface{}(m).(FeedAuthorWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&FeedAuthor{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.ProfilePhotoUrl = m.ProfilePhotoUrl
	to.Bio = m.Bio
	for _, v := range m.FeedArticles {
		if v != nil {
			if tempFeedArticles, cErr := v.ToPB(ctx); cErr == nil {
				to.FeedArticles = append(to.FeedArticles, &tempFeedArticles)
			} else {
				return to, cErr
			}
		} else {
			to.FeedArticles = append(to.FeedArticles, nil)
		}
	}
	if posthook, ok := interface{}(m).(FeedAuthorWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FeedAuthor the arg will be the target, the caller the one being converted from

// FeedAuthorBeforeToORM called before default ToORM code
type FeedAuthorWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeedAuthorORM) error
}

// FeedAuthorAfterToORM called after default ToORM code
type FeedAuthorWithAfterToORM interface {
	AfterToORM(context.Context, *FeedAuthorORM) error
}

// FeedAuthorBeforeToPB called before default ToPB code
type FeedAuthorWithBeforeToPB interface {
	BeforeToPB(context.Context, *FeedAuthor) error
}

// FeedAuthorAfterToPB called after default ToPB code
type FeedAuthorWithAfterToPB interface {
	AfterToPB(context.Context, *FeedAuthor) error
}

type FeedArticleDetailORM struct {
	Content     string
	FeedArticle *FeedArticleORM `gorm:"foreignkey:FeedArticleDetailId;association_foreignkey:Id;preload:false"`
	Id          int64           `gorm:"type:serial;primary_key"`
}

// TableName overrides the default tablename generated by GORM
func (FeedArticleDetailORM) TableName() string {
	return "feed_article_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FeedArticleDetail) ToORM(ctx context.Context) (FeedArticleDetailORM, error) {
	to := FeedArticleDetailORM{}
	var err error
	if prehook, ok := interface{}(m).(FeedArticleDetailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&FeedArticleDetail{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Content = m.Content
	if m.FeedArticle != nil {
		tempFeedArticle, err := m.FeedArticle.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.FeedArticle = &tempFeedArticle
	}
	if posthook, ok := interface{}(m).(FeedArticleDetailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeedArticleDetailORM) ToPB(ctx context.Context) (FeedArticleDetail, error) {
	to := FeedArticleDetail{}
	var err error
	if prehook, ok := interface{}(m).(FeedArticleDetailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&FeedArticleDetail{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Content = m.Content
	if m.FeedArticle != nil {
		tempFeedArticle, err := m.FeedArticle.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.FeedArticle = &tempFeedArticle
	}
	if posthook, ok := interface{}(m).(FeedArticleDetailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FeedArticleDetail the arg will be the target, the caller the one being converted from

// FeedArticleDetailBeforeToORM called before default ToORM code
type FeedArticleDetailWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeedArticleDetailORM) error
}

// FeedArticleDetailAfterToORM called after default ToORM code
type FeedArticleDetailWithAfterToORM interface {
	AfterToORM(context.Context, *FeedArticleDetailORM) error
}

// FeedArticleDetailBeforeToPB called before default ToPB code
type FeedArticleDetailWithBeforeToPB interface {
	BeforeToPB(context.Context, *FeedArticleDetail) error
}

// FeedArticleDetailAfterToPB called after default ToPB code
type FeedArticleDetailWithAfterToPB interface {
	AfterToPB(context.Context, *FeedArticleDetail) error
}

type FeedArticleORM struct {
	Content             string
	CoverPictureUrl     string
	CreatedAt           *time.Time
	FeedArticleDetailId *int64
	FeedAuthor          *FeedAuthorORM `gorm:"foreignkey:FeedAuthorId;association_foreignkey:Id"`
	FeedAuthorId        *int64
	FeedTags            []*FeedTagORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:feed_articles_feed_tags;jointable_foreignkey:feed_article_id;association_jointable_foreignkey:feed_tag_id"`
	Id                  int64         `gorm:"type:serial;primary_key"`
	Subtitle            string
	Title               string
}

// TableName overrides the default tablename generated by GORM
func (FeedArticleORM) TableName() string {
	return "feed_articles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FeedArticle) ToORM(ctx context.Context) (FeedArticleORM, error) {
	to := FeedArticleORM{}
	var err error
	if prehook, ok := interface{}(m).(FeedArticleWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&FeedArticle{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	to.Title = m.Title
	to.Subtitle = m.Subtitle
	to.CoverPictureUrl = m.CoverPictureUrl
	to.Content = m.Content
	for _, v := range m.FeedTags {
		if v != nil {
			if tempFeedTags, cErr := v.ToORM(ctx); cErr == nil {
				to.FeedTags = append(to.FeedTags, &tempFeedTags)
			} else {
				return to, cErr
			}
		} else {
			to.FeedTags = append(to.FeedTags, nil)
		}
	}
	if m.FeedAuthor != nil {
		tempFeedAuthor, err := m.FeedAuthor.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.FeedAuthor = &tempFeedAuthor
	}
	if posthook, ok := interface{}(m).(FeedArticleWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FeedArticleORM) ToPB(ctx context.Context) (FeedArticle, error) {
	to := FeedArticle{}
	var err error
	if prehook, ok := interface{}(m).(FeedArticleWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&FeedArticle{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	to.Title = m.Title
	to.Subtitle = m.Subtitle
	to.CoverPictureUrl = m.CoverPictureUrl
	to.Content = m.Content
	for _, v := range m.FeedTags {
		if v != nil {
			if tempFeedTags, cErr := v.ToPB(ctx); cErr == nil {
				to.FeedTags = append(to.FeedTags, &tempFeedTags)
			} else {
				return to, cErr
			}
		} else {
			to.FeedTags = append(to.FeedTags, nil)
		}
	}
	if m.FeedAuthor != nil {
		tempFeedAuthor, err := m.FeedAuthor.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.FeedAuthor = &tempFeedAuthor
	}
	if posthook, ok := interface{}(m).(FeedArticleWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FeedArticle the arg will be the target, the caller the one being converted from

// FeedArticleBeforeToORM called before default ToORM code
type FeedArticleWithBeforeToORM interface {
	BeforeToORM(context.Context, *FeedArticleORM) error
}

// FeedArticleAfterToORM called after default ToORM code
type FeedArticleWithAfterToORM interface {
	AfterToORM(context.Context, *FeedArticleORM) error
}

// FeedArticleBeforeToPB called before default ToPB code
type FeedArticleWithBeforeToPB interface {
	BeforeToPB(context.Context, *FeedArticle) error
}

// FeedArticleAfterToPB called after default ToPB code
type FeedArticleWithAfterToPB interface {
	AfterToPB(context.Context, *FeedArticle) error
}

// DefaultCreateFeedTag executes a basic gorm create call
func DefaultCreateFeedTag(ctx context.Context, in *FeedTag, db *gorm1.DB) (*FeedTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeedTagORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFeedTag executes a basic gorm read call
func DefaultReadFeedTag(ctx context.Context, in *FeedTag, db *gorm1.DB) (*FeedTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FeedTagORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeedTagORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeedTagORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeedTagORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedTag(ctx context.Context, in *FeedTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeedTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeedTagORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedTagSet(ctx context.Context, in []*FeedTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeedTagORM{})).(FeedTagORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeedTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeedTagORM{})).(FeedTagORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeedTagORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FeedTag, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FeedTag, *gorm1.DB) error
}

// DefaultStrictUpdateFeedTag clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeedTag(ctx context.Context, in *FeedTag, db *gorm1.DB) (*FeedTag, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeedTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeedTagORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeedTagORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFeedTag executes a basic gorm update call with patch behavior
func DefaultPatchFeedTag(ctx context.Context, in *FeedTag, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*FeedTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj FeedTag
	var err error
	if hook, ok := interface{}(&pbObj).(FeedTagWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeedTag(ctx, &FeedTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeedTagWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeedTag(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeedTagWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeedTag(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeedTagWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeedTagWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FeedTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FeedTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FeedTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FeedTag, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFeedTag executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeedTag(ctx context.Context, objects []*FeedTag, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*FeedTag, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FeedTag, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeedTag(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeedTag patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeedTag(ctx context.Context, patchee *FeedTag, patcher *FeedTag, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*FeedTag, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"FeedArticles" {
			patchee.FeedArticles = patcher.FeedArticles
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeedTag executes a gorm list call
func DefaultListFeedTag(ctx context.Context, db *gorm1.DB) ([]*FeedTag, error) {
	in := FeedTag{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FeedTagORM{}, &FeedTag{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeedTagORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedTagORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FeedTag{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeedTagORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedTagORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FeedTagORM) error
}

// DefaultCreateFeedAuthor executes a basic gorm create call
func DefaultCreateFeedAuthor(ctx context.Context, in *FeedAuthor, db *gorm1.DB) (*FeedAuthor, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeedAuthorORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFeedAuthor executes a basic gorm read call
func DefaultReadFeedAuthor(ctx context.Context, in *FeedAuthor, db *gorm1.DB) (*FeedAuthor, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FeedAuthorORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeedAuthorORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeedAuthorORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeedAuthorORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedAuthor(ctx context.Context, in *FeedAuthor, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeedAuthorORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeedAuthorORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedAuthorSet(ctx context.Context, in []*FeedAuthor, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeedAuthorORM{})).(FeedAuthorORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeedAuthorORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeedAuthorORM{})).(FeedAuthorORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeedAuthorORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FeedAuthor, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FeedAuthor, *gorm1.DB) error
}

// DefaultStrictUpdateFeedAuthor clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeedAuthor(ctx context.Context, in *FeedAuthor, db *gorm1.DB) (*FeedAuthor, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeedAuthor")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeedAuthorORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFeedArticles := FeedArticleORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterFeedArticles.FeedAuthorId = new(int64)
	*filterFeedArticles.FeedAuthorId = ormObj.Id
	if err = db.Where(filterFeedArticles).Delete(FeedArticleORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeedAuthorORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFeedAuthor executes a basic gorm update call with patch behavior
func DefaultPatchFeedAuthor(ctx context.Context, in *FeedAuthor, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*FeedAuthor, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj FeedAuthor
	var err error
	if hook, ok := interface{}(&pbObj).(FeedAuthorWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeedAuthor(ctx, &FeedAuthor{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeedAuthorWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeedAuthor(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeedAuthorWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeedAuthor(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeedAuthorWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeedAuthorWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FeedAuthor, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FeedAuthor, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FeedAuthor, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FeedAuthor, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFeedAuthor executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeedAuthor(ctx context.Context, objects []*FeedAuthor, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*FeedAuthor, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FeedAuthor, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeedAuthor(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeedAuthor patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeedAuthor(ctx context.Context, patchee *FeedAuthor, patcher *FeedAuthor, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*FeedAuthor, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"ProfilePhotoUrl" {
			patchee.ProfilePhotoUrl = patcher.ProfilePhotoUrl
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"FeedArticles" {
			patchee.FeedArticles = patcher.FeedArticles
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeedAuthor executes a gorm list call
func DefaultListFeedAuthor(ctx context.Context, db *gorm1.DB) ([]*FeedAuthor, error) {
	in := FeedAuthor{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FeedAuthorORM{}, &FeedAuthor{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeedAuthorORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedAuthorORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FeedAuthor{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeedAuthorORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedAuthorORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FeedAuthorORM) error
}

// DefaultCreateFeedArticleDetail executes a basic gorm create call
func DefaultCreateFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, db *gorm1.DB) (*FeedArticleDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeedArticleDetailORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFeedArticleDetail executes a basic gorm read call
func DefaultReadFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, db *gorm1.DB) (*FeedArticleDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FeedArticleDetailORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeedArticleDetailORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeedArticleDetailORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeedArticleDetailORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeedArticleDetailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeedArticleDetailORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedArticleDetailSet(ctx context.Context, in []*FeedArticleDetail, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeedArticleDetailORM{})).(FeedArticleDetailORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeedArticleDetailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeedArticleDetailORM{})).(FeedArticleDetailORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeedArticleDetailORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FeedArticleDetail, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FeedArticleDetail, *gorm1.DB) error
}

// DefaultStrictUpdateFeedArticleDetail clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, db *gorm1.DB) (*FeedArticleDetail, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeedArticleDetail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeedArticleDetailORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFeedArticle := FeedArticleORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterFeedArticle.FeedArticleDetailId = new(int64)
	*filterFeedArticle.FeedArticleDetailId = ormObj.Id
	if err = db.Where(filterFeedArticle).Delete(FeedArticleORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeedArticleDetailORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFeedArticleDetail executes a basic gorm update call with patch behavior
func DefaultPatchFeedArticleDetail(ctx context.Context, in *FeedArticleDetail, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*FeedArticleDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj FeedArticleDetail
	var err error
	if hook, ok := interface{}(&pbObj).(FeedArticleDetailWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeedArticleDetail(ctx, &FeedArticleDetail{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeedArticleDetailWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeedArticleDetail(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeedArticleDetailWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeedArticleDetail(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeedArticleDetailWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeedArticleDetailWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FeedArticleDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FeedArticleDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FeedArticleDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FeedArticleDetail, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFeedArticleDetail executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeedArticleDetail(ctx context.Context, objects []*FeedArticleDetail, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*FeedArticleDetail, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FeedArticleDetail, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeedArticleDetail(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeedArticleDetail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeedArticleDetail(ctx context.Context, patchee *FeedArticleDetail, patcher *FeedArticleDetail, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*FeedArticleDetail, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedFeedArticle bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if !updatedFeedArticle && strings.HasPrefix(f, prefix+"FeedArticle.") {
			updatedFeedArticle = true
			if patcher.FeedArticle == nil {
				patchee.FeedArticle = nil
				continue
			}
			if patchee.FeedArticle == nil {
				patchee.FeedArticle = &FeedArticle{}
			}
			if o, err := DefaultApplyFieldMaskFeedArticle(ctx, patchee.FeedArticle, patcher.FeedArticle, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"FeedArticle.", db); err != nil {
				return nil, err
			} else {
				patchee.FeedArticle = o
			}
			continue
		}
		if f == prefix+"FeedArticle" {
			updatedFeedArticle = true
			patchee.FeedArticle = patcher.FeedArticle
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeedArticleDetail executes a gorm list call
func DefaultListFeedArticleDetail(ctx context.Context, db *gorm1.DB) ([]*FeedArticleDetail, error) {
	in := FeedArticleDetail{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FeedArticleDetailORM{}, &FeedArticleDetail{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeedArticleDetailORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleDetailORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FeedArticleDetail{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeedArticleDetailORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleDetailORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FeedArticleDetailORM) error
}

// DefaultCreateFeedArticle executes a basic gorm create call
func DefaultCreateFeedArticle(ctx context.Context, in *FeedArticle, db *gorm1.DB) (*FeedArticle, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FeedArticleORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFeedArticle executes a basic gorm read call
func DefaultReadFeedArticle(ctx context.Context, in *FeedArticle, db *gorm1.DB) (*FeedArticle, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FeedArticleORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FeedArticleORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FeedArticleORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FeedArticleORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedArticle(ctx context.Context, in *FeedArticle, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FeedArticleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FeedArticleORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFeedArticleSet(ctx context.Context, in []*FeedArticle, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FeedArticleORM{})).(FeedArticleORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FeedArticleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FeedArticleORM{})).(FeedArticleORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FeedArticleORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FeedArticle, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FeedArticle, *gorm1.DB) error
}

// DefaultStrictUpdateFeedArticle clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFeedArticle(ctx context.Context, in *FeedArticle, db *gorm1.DB) (*FeedArticle, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFeedArticle")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FeedArticleORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FeedArticleORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFeedArticle executes a basic gorm update call with patch behavior
func DefaultPatchFeedArticle(ctx context.Context, in *FeedArticle, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*FeedArticle, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj FeedArticle
	var err error
	if hook, ok := interface{}(&pbObj).(FeedArticleWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFeedArticle(ctx, &FeedArticle{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FeedArticleWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFeedArticle(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FeedArticleWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFeedArticle(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FeedArticleWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FeedArticleWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FeedArticle, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FeedArticle, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FeedArticle, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FeedArticleWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FeedArticle, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFeedArticle executes a bulk gorm update call with patch behavior
func DefaultPatchSetFeedArticle(ctx context.Context, objects []*FeedArticle, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*FeedArticle, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FeedArticle, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFeedArticle(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFeedArticle patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFeedArticle(ctx context.Context, patchee *FeedArticle, patcher *FeedArticle, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*FeedArticle, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedFeedAuthor bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"Subtitle" {
			patchee.Subtitle = patcher.Subtitle
			continue
		}
		if f == prefix+"CoverPictureUrl" {
			patchee.CoverPictureUrl = patcher.CoverPictureUrl
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if f == prefix+"FeedTags" {
			patchee.FeedTags = patcher.FeedTags
			continue
		}
		if !updatedFeedAuthor && strings.HasPrefix(f, prefix+"FeedAuthor.") {
			updatedFeedAuthor = true
			if patcher.FeedAuthor == nil {
				patchee.FeedAuthor = nil
				continue
			}
			if patchee.FeedAuthor == nil {
				patchee.FeedAuthor = &FeedAuthor{}
			}
			if o, err := DefaultApplyFieldMaskFeedAuthor(ctx, patchee.FeedAuthor, patcher.FeedAuthor, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"FeedAuthor.", db); err != nil {
				return nil, err
			} else {
				patchee.FeedAuthor = o
			}
			continue
		}
		if f == prefix+"FeedAuthor" {
			updatedFeedAuthor = true
			patchee.FeedAuthor = patcher.FeedAuthor
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFeedArticle executes a gorm list call
func DefaultListFeedArticle(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*FeedArticle, error) {
	in := FeedArticle{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FeedArticleORM{}, &FeedArticle{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FeedArticleORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FeedArticleORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FeedArticle{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FeedArticleORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type FeedArticleORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type FeedArticleORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FeedArticleORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type FeedArticlesDefaultServer struct {
	DB *gorm1.DB
}

func (m *FeedArticlesDefaultServer) spanCreate(ctx context.Context, in interface{}, methodName string) (*trace1.Span, error) {
	_, span := trace1.StartSpan(ctx, fmt.Sprint("FeedArticlesDefaultServer.", methodName))
	raw, err := json1.Marshal(in)
	if err != nil {
		return nil, err
	}
	span.Annotate([]trace1.Attribute{trace1.StringAttribute("in", string(raw))}, "in parameter")
	return span, nil
}

// spanError ...
func (m *FeedArticlesDefaultServer) spanError(span *trace1.Span, err error) error {
	span.SetStatus(trace1.Status{
		Code:    trace1.StatusCodeUnknown,
		Message: err.Error(),
	})
	return err
}

// spanResult ...
func (m *FeedArticlesDefaultServer) spanResult(span *trace1.Span, out interface{}) error {
	raw, err := json1.Marshal(out)
	if err != nil {
		return err
	}
	span.Annotate([]trace1.Attribute{trace1.StringAttribute("out", string(raw))}, "out parameter")
	return nil
}

// List ...
func (m *FeedArticlesDefaultServer) List(ctx context.Context, in *ListFeedArticleRequest) (*ListFeedArticleResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "List")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(FeedArticlesFeedArticleWithBeforeList); ok {
		var err error
		if db, err = custom.BeforeList(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListFeedArticle(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListFeedArticleResponse{Results: res}
	if custom, ok := interface{}(in).(FeedArticlesFeedArticleWithAfterList); ok {
		var err error
		if err = custom.AfterList(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// FeedArticlesFeedArticleWithBeforeList called before DefaultListFeedArticle in the default List handler
type FeedArticlesFeedArticleWithBeforeList interface {
	BeforeList(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// FeedArticlesFeedArticleWithAfterList called before DefaultListFeedArticle in the default List handler
type FeedArticlesFeedArticleWithAfterList interface {
	AfterList(context.Context, *ListFeedArticleResponse, *gorm1.DB) error
}
type FeedArticleDetailsDefaultServer struct {
	DB *gorm1.DB
}

func (m *FeedArticleDetailsDefaultServer) spanCreate(ctx context.Context, in interface{}, methodName string) (*trace1.Span, error) {
	_, span := trace1.StartSpan(ctx, fmt.Sprint("FeedArticleDetailsDefaultServer.", methodName))
	raw, err := json1.Marshal(in)
	if err != nil {
		return nil, err
	}
	span.Annotate([]trace1.Attribute{trace1.StringAttribute("in", string(raw))}, "in parameter")
	return span, nil
}

// spanError ...
func (m *FeedArticleDetailsDefaultServer) spanError(span *trace1.Span, err error) error {
	span.SetStatus(trace1.Status{
		Code:    trace1.StatusCodeUnknown,
		Message: err.Error(),
	})
	return err
}

// spanResult ...
func (m *FeedArticleDetailsDefaultServer) spanResult(span *trace1.Span, out interface{}) error {
	raw, err := json1.Marshal(out)
	if err != nil {
		return err
	}
	span.Annotate([]trace1.Attribute{trace1.StringAttribute("out", string(raw))}, "out parameter")
	return nil
}

// Read ...
func (m *FeedArticleDetailsDefaultServer) Read(ctx context.Context, in *ReadFeedArticleDetailsRequest) (*ReadFeedArticleDetailsResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "Read")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(FeedArticleDetailsFeedArticleDetailWithBeforeRead); ok {
		var err error
		if db, err = custom.BeforeRead(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadFeedArticleDetail(ctx, &FeedArticleDetail{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadFeedArticleDetailsResponse{Result: res}
	if custom, ok := interface{}(in).(FeedArticleDetailsFeedArticleDetailWithAfterRead); ok {
		var err error
		if err = custom.AfterRead(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// FeedArticleDetailsFeedArticleDetailWithBeforeRead called before DefaultReadFeedArticleDetail in the default Read handler
type FeedArticleDetailsFeedArticleDetailWithBeforeRead interface {
	BeforeRead(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// FeedArticleDetailsFeedArticleDetailWithAfterRead called before DefaultReadFeedArticleDetail in the default Read handler
type FeedArticleDetailsFeedArticleDetailWithAfterRead interface {
	AfterRead(context.Context, *ReadFeedArticleDetailsResponse, *gorm1.DB) error
}

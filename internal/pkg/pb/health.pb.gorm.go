// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/kodesmil/ks-model/health.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

package pb

import context "context"
import fmt "fmt"
import time "time"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import json1 "encoding/json"
import ptypes1 "github.com/golang/protobuf/ptypes"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import trace1 "go.opencensus.io/trace"

import math "math"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/envoyproxy/protoc-gen-validate/validate"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type HealthMenstruationPersonalInfoORM struct {
	CreatedAt          *time.Time
	CycleLengthInDays  int32
	Id                 uint64 `gorm:"type:serial;primary_key"`
	PeriodLengthInDays int32
	ProfileId          string
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (HealthMenstruationPersonalInfoORM) TableName() string {
	return "health_menstruation_personal_infos"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *HealthMenstruationPersonalInfo) ToORM(ctx context.Context) (HealthMenstruationPersonalInfoORM, error) {
	to := HealthMenstruationPersonalInfoORM{}
	var err error
	if prehook, ok := interface{}(m).(HealthMenstruationPersonalInfoWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.ProfileId = m.ProfileId
	to.PeriodLengthInDays = m.PeriodLengthInDays
	to.CycleLengthInDays = m.CycleLengthInDays
	if posthook, ok := interface{}(m).(HealthMenstruationPersonalInfoWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HealthMenstruationPersonalInfoORM) ToPB(ctx context.Context) (HealthMenstruationPersonalInfo, error) {
	to := HealthMenstruationPersonalInfo{}
	var err error
	if prehook, ok := interface{}(m).(HealthMenstruationPersonalInfoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.ProfileId = m.ProfileId
	to.PeriodLengthInDays = m.PeriodLengthInDays
	to.CycleLengthInDays = m.CycleLengthInDays
	if posthook, ok := interface{}(m).(HealthMenstruationPersonalInfoWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type HealthMenstruationPersonalInfo the arg will be the target, the caller the one being converted from

// HealthMenstruationPersonalInfoBeforeToORM called before default ToORM code
type HealthMenstruationPersonalInfoWithBeforeToORM interface {
	BeforeToORM(context.Context, *HealthMenstruationPersonalInfoORM) error
}

// HealthMenstruationPersonalInfoAfterToORM called after default ToORM code
type HealthMenstruationPersonalInfoWithAfterToORM interface {
	AfterToORM(context.Context, *HealthMenstruationPersonalInfoORM) error
}

// HealthMenstruationPersonalInfoBeforeToPB called before default ToPB code
type HealthMenstruationPersonalInfoWithBeforeToPB interface {
	BeforeToPB(context.Context, *HealthMenstruationPersonalInfo) error
}

// HealthMenstruationPersonalInfoAfterToPB called after default ToPB code
type HealthMenstruationPersonalInfoWithAfterToPB interface {
	AfterToPB(context.Context, *HealthMenstruationPersonalInfo) error
}

type HealthMenstruationDailyEntryORM struct {
	BasedOnPrediction   bool
	CreatedAt           *time.Time
	Day                 *time.Time
	Id                  uint64 `gorm:"type:serial;primary_key"`
	IntensityPercentage int32
	Manual              bool
	ProfileId           string
	Type                int32
	UpdatedAt           *time.Time
}

// TableName overrides the default tablename generated by GORM
func (HealthMenstruationDailyEntryORM) TableName() string {
	return "health_menstruation_daily_entries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *HealthMenstruationDailyEntry) ToORM(ctx context.Context) (HealthMenstruationDailyEntryORM, error) {
	to := HealthMenstruationDailyEntryORM{}
	var err error
	if prehook, ok := interface{}(m).(HealthMenstruationDailyEntryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.ProfileId = m.ProfileId
	if m.Day != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.Day); err != nil {
			return to, err
		}
		to.Day = &t
	}
	to.IntensityPercentage = m.IntensityPercentage
	to.Type = int32(m.Type)
	to.Manual = m.Manual
	to.BasedOnPrediction = m.BasedOnPrediction
	if posthook, ok := interface{}(m).(HealthMenstruationDailyEntryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HealthMenstruationDailyEntryORM) ToPB(ctx context.Context) (HealthMenstruationDailyEntry, error) {
	to := HealthMenstruationDailyEntry{}
	var err error
	if prehook, ok := interface{}(m).(HealthMenstruationDailyEntryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.ProfileId = m.ProfileId
	if m.Day != nil {
		if to.Day, err = ptypes1.TimestampProto(*m.Day); err != nil {
			return to, err
		}
	}
	to.IntensityPercentage = m.IntensityPercentage
	to.Type = HealthMenstruationDailyEntry_Type(m.Type)
	to.Manual = m.Manual
	to.BasedOnPrediction = m.BasedOnPrediction
	if posthook, ok := interface{}(m).(HealthMenstruationDailyEntryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type HealthMenstruationDailyEntry the arg will be the target, the caller the one being converted from

// HealthMenstruationDailyEntryBeforeToORM called before default ToORM code
type HealthMenstruationDailyEntryWithBeforeToORM interface {
	BeforeToORM(context.Context, *HealthMenstruationDailyEntryORM) error
}

// HealthMenstruationDailyEntryAfterToORM called after default ToORM code
type HealthMenstruationDailyEntryWithAfterToORM interface {
	AfterToORM(context.Context, *HealthMenstruationDailyEntryORM) error
}

// HealthMenstruationDailyEntryBeforeToPB called before default ToPB code
type HealthMenstruationDailyEntryWithBeforeToPB interface {
	BeforeToPB(context.Context, *HealthMenstruationDailyEntry) error
}

// HealthMenstruationDailyEntryAfterToPB called after default ToPB code
type HealthMenstruationDailyEntryWithAfterToPB interface {
	AfterToPB(context.Context, *HealthMenstruationDailyEntry) error
}

// DefaultCreateHealthMenstruationPersonalInfo executes a basic gorm create call
func DefaultCreateHealthMenstruationPersonalInfo(ctx context.Context, in *HealthMenstruationPersonalInfo, db *gorm1.DB) (*HealthMenstruationPersonalInfo, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HealthMenstruationPersonalInfoORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadHealthMenstruationPersonalInfo executes a basic gorm read call
func DefaultReadHealthMenstruationPersonalInfo(ctx context.Context, in *HealthMenstruationPersonalInfo, db *gorm1.DB) (*HealthMenstruationPersonalInfo, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &HealthMenstruationPersonalInfoORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HealthMenstruationPersonalInfoORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HealthMenstruationPersonalInfoORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HealthMenstruationPersonalInfoORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteHealthMenstruationPersonalInfo(ctx context.Context, in *HealthMenstruationPersonalInfo, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HealthMenstruationPersonalInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HealthMenstruationPersonalInfoORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteHealthMenstruationPersonalInfoSet(ctx context.Context, in []*HealthMenstruationPersonalInfo, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HealthMenstruationPersonalInfoORM{})).(HealthMenstruationPersonalInfoORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HealthMenstruationPersonalInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HealthMenstruationPersonalInfoORM{})).(HealthMenstruationPersonalInfoORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HealthMenstruationPersonalInfoORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*HealthMenstruationPersonalInfo, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*HealthMenstruationPersonalInfo, *gorm1.DB) error
}

// DefaultStrictUpdateHealthMenstruationPersonalInfo clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHealthMenstruationPersonalInfo(ctx context.Context, in *HealthMenstruationPersonalInfo, db *gorm1.DB) (*HealthMenstruationPersonalInfo, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHealthMenstruationPersonalInfo")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HealthMenstruationPersonalInfoORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HealthMenstruationPersonalInfoORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchHealthMenstruationPersonalInfo executes a basic gorm update call with patch behavior
func DefaultPatchHealthMenstruationPersonalInfo(ctx context.Context, in *HealthMenstruationPersonalInfo, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*HealthMenstruationPersonalInfo, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj HealthMenstruationPersonalInfo
	var err error
	if hook, ok := interface{}(&pbObj).(HealthMenstruationPersonalInfoWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHealthMenstruationPersonalInfo(ctx, &HealthMenstruationPersonalInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HealthMenstruationPersonalInfoWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHealthMenstruationPersonalInfo(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HealthMenstruationPersonalInfoWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHealthMenstruationPersonalInfo(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HealthMenstruationPersonalInfoWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HealthMenstruationPersonalInfoWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *HealthMenstruationPersonalInfo, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *HealthMenstruationPersonalInfo, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *HealthMenstruationPersonalInfo, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *HealthMenstruationPersonalInfo, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetHealthMenstruationPersonalInfo executes a bulk gorm update call with patch behavior
func DefaultPatchSetHealthMenstruationPersonalInfo(ctx context.Context, objects []*HealthMenstruationPersonalInfo, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*HealthMenstruationPersonalInfo, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*HealthMenstruationPersonalInfo, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHealthMenstruationPersonalInfo(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHealthMenstruationPersonalInfo patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHealthMenstruationPersonalInfo(ctx context.Context, patchee *HealthMenstruationPersonalInfo, patcher *HealthMenstruationPersonalInfo, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*HealthMenstruationPersonalInfo, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"ProfileId" {
			patchee.ProfileId = patcher.ProfileId
			continue
		}
		if f == prefix+"PeriodLengthInDays" {
			patchee.PeriodLengthInDays = patcher.PeriodLengthInDays
			continue
		}
		if f == prefix+"CycleLengthInDays" {
			patchee.CycleLengthInDays = patcher.CycleLengthInDays
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHealthMenstruationPersonalInfo executes a gorm list call
func DefaultListHealthMenstruationPersonalInfo(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*HealthMenstruationPersonalInfo, error) {
	in := HealthMenstruationPersonalInfo{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &HealthMenstruationPersonalInfoORM{}, &HealthMenstruationPersonalInfo{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HealthMenstruationPersonalInfoORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationPersonalInfoORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*HealthMenstruationPersonalInfo{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HealthMenstruationPersonalInfoORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type HealthMenstruationPersonalInfoORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]HealthMenstruationPersonalInfoORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateHealthMenstruationDailyEntry executes a basic gorm create call
func DefaultCreateHealthMenstruationDailyEntry(ctx context.Context, in *HealthMenstruationDailyEntry, db *gorm1.DB) (*HealthMenstruationDailyEntry, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HealthMenstruationDailyEntryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadHealthMenstruationDailyEntry executes a basic gorm read call
func DefaultReadHealthMenstruationDailyEntry(ctx context.Context, in *HealthMenstruationDailyEntry, db *gorm1.DB) (*HealthMenstruationDailyEntry, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &HealthMenstruationDailyEntryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HealthMenstruationDailyEntryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HealthMenstruationDailyEntryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HealthMenstruationDailyEntryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteHealthMenstruationDailyEntry(ctx context.Context, in *HealthMenstruationDailyEntry, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HealthMenstruationDailyEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HealthMenstruationDailyEntryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteHealthMenstruationDailyEntrySet(ctx context.Context, in []*HealthMenstruationDailyEntry, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HealthMenstruationDailyEntryORM{})).(HealthMenstruationDailyEntryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HealthMenstruationDailyEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HealthMenstruationDailyEntryORM{})).(HealthMenstruationDailyEntryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HealthMenstruationDailyEntryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*HealthMenstruationDailyEntry, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*HealthMenstruationDailyEntry, *gorm1.DB) error
}

// DefaultStrictUpdateHealthMenstruationDailyEntry clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHealthMenstruationDailyEntry(ctx context.Context, in *HealthMenstruationDailyEntry, db *gorm1.DB) (*HealthMenstruationDailyEntry, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHealthMenstruationDailyEntry")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HealthMenstruationDailyEntryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HealthMenstruationDailyEntryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchHealthMenstruationDailyEntry executes a basic gorm update call with patch behavior
func DefaultPatchHealthMenstruationDailyEntry(ctx context.Context, in *HealthMenstruationDailyEntry, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*HealthMenstruationDailyEntry, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj HealthMenstruationDailyEntry
	var err error
	if hook, ok := interface{}(&pbObj).(HealthMenstruationDailyEntryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHealthMenstruationDailyEntry(ctx, &HealthMenstruationDailyEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HealthMenstruationDailyEntryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHealthMenstruationDailyEntry(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HealthMenstruationDailyEntryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHealthMenstruationDailyEntry(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HealthMenstruationDailyEntryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HealthMenstruationDailyEntryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *HealthMenstruationDailyEntry, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *HealthMenstruationDailyEntry, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *HealthMenstruationDailyEntry, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *HealthMenstruationDailyEntry, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetHealthMenstruationDailyEntry executes a bulk gorm update call with patch behavior
func DefaultPatchSetHealthMenstruationDailyEntry(ctx context.Context, objects []*HealthMenstruationDailyEntry, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*HealthMenstruationDailyEntry, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*HealthMenstruationDailyEntry, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHealthMenstruationDailyEntry(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHealthMenstruationDailyEntry patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHealthMenstruationDailyEntry(ctx context.Context, patchee *HealthMenstruationDailyEntry, patcher *HealthMenstruationDailyEntry, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*HealthMenstruationDailyEntry, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"ProfileId" {
			patchee.ProfileId = patcher.ProfileId
			continue
		}
		if f == prefix+"Day" {
			patchee.Day = patcher.Day
			continue
		}
		if f == prefix+"IntensityPercentage" {
			patchee.IntensityPercentage = patcher.IntensityPercentage
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Manual" {
			patchee.Manual = patcher.Manual
			continue
		}
		if f == prefix+"BasedOnPrediction" {
			patchee.BasedOnPrediction = patcher.BasedOnPrediction
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHealthMenstruationDailyEntry executes a gorm list call
func DefaultListHealthMenstruationDailyEntry(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*HealthMenstruationDailyEntry, error) {
	in := HealthMenstruationDailyEntry{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &HealthMenstruationDailyEntryORM{}, &HealthMenstruationDailyEntry{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HealthMenstruationDailyEntryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HealthMenstruationDailyEntryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*HealthMenstruationDailyEntry{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HealthMenstruationDailyEntryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type HealthMenstruationDailyEntryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]HealthMenstruationDailyEntryORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type HealthDefaultServer struct {
	DB *gorm1.DB
}

func (m *HealthDefaultServer) spanCreate(ctx context.Context, in interface{}, methodName string) (*trace1.Span, error) {
	_, span := trace1.StartSpan(ctx, fmt.Sprint("HealthDefaultServer.", methodName))
	raw, err := json1.Marshal(in)
	if err != nil {
		return nil, err
	}
	span.Annotate([]trace1.Attribute{trace1.StringAttribute("in", string(raw))}, "in parameter")
	return span, nil
}

// spanError ...
func (m *HealthDefaultServer) spanError(span *trace1.Span, err error) error {
	span.SetStatus(trace1.Status{
		Code:    trace1.StatusCodeUnknown,
		Message: err.Error(),
	})
	return err
}

// spanResult ...
func (m *HealthDefaultServer) spanResult(span *trace1.Span, out interface{}) error {
	raw, err := json1.Marshal(out)
	if err != nil {
		return err
	}
	span.Annotate([]trace1.Attribute{trace1.StringAttribute("out", string(raw))}, "out parameter")
	return nil
}

// CreateHealthMenstruationDailyEntry ...
func (m *HealthDefaultServer) CreateHealthMenstruationDailyEntry(ctx context.Context, in *CreateHealthMenstruationDailyEntryRequest) (*CreateHealthMenstruationDailyEntryResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateHealthMenstruationDailyEntry")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithBeforeCreateHealthMenstruationDailyEntry); ok {
		var err error
		if db, err = custom.BeforeCreateHealthMenstruationDailyEntry(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateHealthMenstruationDailyEntry(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateHealthMenstruationDailyEntryResponse{Result: res}
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithAfterCreateHealthMenstruationDailyEntry); ok {
		var err error
		if err = custom.AfterCreateHealthMenstruationDailyEntry(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationDailyEntryWithBeforeCreateHealthMenstruationDailyEntry called before DefaultCreateHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default CreateHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithBeforeCreateHealthMenstruationDailyEntry interface {
	BeforeCreateHealthMenstruationDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationDailyEntryWithAfterCreateHealthMenstruationDailyEntry called before DefaultCreateHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default CreateHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithAfterCreateHealthMenstruationDailyEntry interface {
	AfterCreateHealthMenstruationDailyEntry(context.Context, *CreateHealthMenstruationDailyEntryResponse, *gorm1.DB) error
}

// ReadHealthMenstruationDailyEntry ...
func (m *HealthDefaultServer) ReadHealthMenstruationDailyEntry(ctx context.Context, in *ReadHealthMenstruationDailyEntryRequest) (*ReadHealthMenstruationDailyEntryResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadHealthMenstruationDailyEntry")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithBeforeReadHealthMenstruationDailyEntry); ok {
		var err error
		if db, err = custom.BeforeReadHealthMenstruationDailyEntry(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadHealthMenstruationDailyEntry(ctx, &HealthMenstruationDailyEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadHealthMenstruationDailyEntryResponse{Result: res}
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithAfterReadHealthMenstruationDailyEntry); ok {
		var err error
		if err = custom.AfterReadHealthMenstruationDailyEntry(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationDailyEntryWithBeforeReadHealthMenstruationDailyEntry called before DefaultReadHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default ReadHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithBeforeReadHealthMenstruationDailyEntry interface {
	BeforeReadHealthMenstruationDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationDailyEntryWithAfterReadHealthMenstruationDailyEntry called before DefaultReadHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default ReadHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithAfterReadHealthMenstruationDailyEntry interface {
	AfterReadHealthMenstruationDailyEntry(context.Context, *ReadHealthMenstruationDailyEntryResponse, *gorm1.DB) error
}

// UpdateHealthMenstruationDailyEntry ...
func (m *HealthDefaultServer) UpdateHealthMenstruationDailyEntry(ctx context.Context, in *UpdateHealthMenstruationDailyEntryRequest) (*UpdateHealthMenstruationDailyEntryResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateHealthMenstruationDailyEntry")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *HealthMenstruationDailyEntry
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithBeforeUpdateHealthMenstruationDailyEntry); ok {
		var err error
		if db, err = custom.BeforeUpdateHealthMenstruationDailyEntry(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateHealthMenstruationDailyEntry(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateHealthMenstruationDailyEntryResponse{Result: res}
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithAfterUpdateHealthMenstruationDailyEntry); ok {
		var err error
		if err = custom.AfterUpdateHealthMenstruationDailyEntry(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationDailyEntryWithBeforeUpdateHealthMenstruationDailyEntry called before DefaultUpdateHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default UpdateHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithBeforeUpdateHealthMenstruationDailyEntry interface {
	BeforeUpdateHealthMenstruationDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationDailyEntryWithAfterUpdateHealthMenstruationDailyEntry called before DefaultUpdateHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default UpdateHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithAfterUpdateHealthMenstruationDailyEntry interface {
	AfterUpdateHealthMenstruationDailyEntry(context.Context, *UpdateHealthMenstruationDailyEntryResponse, *gorm1.DB) error
}

// DeleteHealthMenstruationDailyEntry ...
func (m *HealthDefaultServer) DeleteHealthMenstruationDailyEntry(ctx context.Context, in *DeleteHealthMenstruationDailyEntryRequest) (*DeleteHealthMenstruationDailyEntryResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteHealthMenstruationDailyEntry")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithBeforeDeleteHealthMenstruationDailyEntry); ok {
		var err error
		if db, err = custom.BeforeDeleteHealthMenstruationDailyEntry(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteHealthMenstruationDailyEntry(ctx, &HealthMenstruationDailyEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteHealthMenstruationDailyEntryResponse{}
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithAfterDeleteHealthMenstruationDailyEntry); ok {
		var err error
		if err = custom.AfterDeleteHealthMenstruationDailyEntry(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationDailyEntryWithBeforeDeleteHealthMenstruationDailyEntry called before DefaultDeleteHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default DeleteHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithBeforeDeleteHealthMenstruationDailyEntry interface {
	BeforeDeleteHealthMenstruationDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationDailyEntryWithAfterDeleteHealthMenstruationDailyEntry called before DefaultDeleteHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default DeleteHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithAfterDeleteHealthMenstruationDailyEntry interface {
	AfterDeleteHealthMenstruationDailyEntry(context.Context, *DeleteHealthMenstruationDailyEntryResponse, *gorm1.DB) error
}

// ListHealthMenstruationDailyEntry ...
func (m *HealthDefaultServer) ListHealthMenstruationDailyEntry(ctx context.Context, in *ListHealthMenstruationDailyEntryRequest) (*ListHealthMenstruationDailyEntryResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListHealthMenstruationDailyEntry")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithBeforeListHealthMenstruationDailyEntry); ok {
		var err error
		if db, err = custom.BeforeListHealthMenstruationDailyEntry(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListHealthMenstruationDailyEntry(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListHealthMenstruationDailyEntryResponse{Results: res}
	if custom, ok := interface{}(in).(HealthHealthMenstruationDailyEntryWithAfterListHealthMenstruationDailyEntry); ok {
		var err error
		if err = custom.AfterListHealthMenstruationDailyEntry(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationDailyEntryWithBeforeListHealthMenstruationDailyEntry called before DefaultListHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default ListHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithBeforeListHealthMenstruationDailyEntry interface {
	BeforeListHealthMenstruationDailyEntry(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationDailyEntryWithAfterListHealthMenstruationDailyEntry called before DefaultListHealthMenstruationDailyEntryHealthMenstruationDailyEntry in the default ListHealthMenstruationDailyEntry handler
type HealthHealthMenstruationDailyEntryWithAfterListHealthMenstruationDailyEntry interface {
	AfterListHealthMenstruationDailyEntry(context.Context, *ListHealthMenstruationDailyEntryResponse, *gorm1.DB) error
}

// CreateHealthMenstruationPersonalInfo ...
func (m *HealthDefaultServer) CreateHealthMenstruationPersonalInfo(ctx context.Context, in *CreateHealthMenstruationPersonalInfoRequest) (*CreateHealthMenstruationPersonalInfoResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateHealthMenstruationPersonalInfo")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithBeforeCreateHealthMenstruationPersonalInfo); ok {
		var err error
		if db, err = custom.BeforeCreateHealthMenstruationPersonalInfo(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateHealthMenstruationPersonalInfo(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateHealthMenstruationPersonalInfoResponse{Result: res}
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithAfterCreateHealthMenstruationPersonalInfo); ok {
		var err error
		if err = custom.AfterCreateHealthMenstruationPersonalInfo(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationPersonalInfoWithBeforeCreateHealthMenstruationPersonalInfo called before DefaultCreateHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default CreateHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithBeforeCreateHealthMenstruationPersonalInfo interface {
	BeforeCreateHealthMenstruationPersonalInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationPersonalInfoWithAfterCreateHealthMenstruationPersonalInfo called before DefaultCreateHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default CreateHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithAfterCreateHealthMenstruationPersonalInfo interface {
	AfterCreateHealthMenstruationPersonalInfo(context.Context, *CreateHealthMenstruationPersonalInfoResponse, *gorm1.DB) error
}

// ReadHealthMenstruationPersonalInfo ...
func (m *HealthDefaultServer) ReadHealthMenstruationPersonalInfo(ctx context.Context, in *ReadHealthMenstruationPersonalInfoRequest) (*ReadHealthMenstruationPersonalInfoResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadHealthMenstruationPersonalInfo")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithBeforeReadHealthMenstruationPersonalInfo); ok {
		var err error
		if db, err = custom.BeforeReadHealthMenstruationPersonalInfo(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadHealthMenstruationPersonalInfo(ctx, &HealthMenstruationPersonalInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadHealthMenstruationPersonalInfoResponse{Result: res}
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithAfterReadHealthMenstruationPersonalInfo); ok {
		var err error
		if err = custom.AfterReadHealthMenstruationPersonalInfo(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationPersonalInfoWithBeforeReadHealthMenstruationPersonalInfo called before DefaultReadHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default ReadHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithBeforeReadHealthMenstruationPersonalInfo interface {
	BeforeReadHealthMenstruationPersonalInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationPersonalInfoWithAfterReadHealthMenstruationPersonalInfo called before DefaultReadHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default ReadHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithAfterReadHealthMenstruationPersonalInfo interface {
	AfterReadHealthMenstruationPersonalInfo(context.Context, *ReadHealthMenstruationPersonalInfoResponse, *gorm1.DB) error
}

// UpdateHealthMenstruationPersonalInfo ...
func (m *HealthDefaultServer) UpdateHealthMenstruationPersonalInfo(ctx context.Context, in *UpdateHealthMenstruationPersonalInfoRequest) (*UpdateHealthMenstruationPersonalInfoResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateHealthMenstruationPersonalInfo")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *HealthMenstruationPersonalInfo
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithBeforeUpdateHealthMenstruationPersonalInfo); ok {
		var err error
		if db, err = custom.BeforeUpdateHealthMenstruationPersonalInfo(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateHealthMenstruationPersonalInfo(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateHealthMenstruationPersonalInfoResponse{Result: res}
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithAfterUpdateHealthMenstruationPersonalInfo); ok {
		var err error
		if err = custom.AfterUpdateHealthMenstruationPersonalInfo(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationPersonalInfoWithBeforeUpdateHealthMenstruationPersonalInfo called before DefaultUpdateHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default UpdateHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithBeforeUpdateHealthMenstruationPersonalInfo interface {
	BeforeUpdateHealthMenstruationPersonalInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationPersonalInfoWithAfterUpdateHealthMenstruationPersonalInfo called before DefaultUpdateHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default UpdateHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithAfterUpdateHealthMenstruationPersonalInfo interface {
	AfterUpdateHealthMenstruationPersonalInfo(context.Context, *UpdateHealthMenstruationPersonalInfoResponse, *gorm1.DB) error
}

// DeleteHealthMenstruationPersonalInfo ...
func (m *HealthDefaultServer) DeleteHealthMenstruationPersonalInfo(ctx context.Context, in *DeleteHealthMenstruationPersonalInfoRequest) (*DeleteHealthMenstruationPersonalInfoResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteHealthMenstruationPersonalInfo")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithBeforeDeleteHealthMenstruationPersonalInfo); ok {
		var err error
		if db, err = custom.BeforeDeleteHealthMenstruationPersonalInfo(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteHealthMenstruationPersonalInfo(ctx, &HealthMenstruationPersonalInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteHealthMenstruationPersonalInfoResponse{}
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithAfterDeleteHealthMenstruationPersonalInfo); ok {
		var err error
		if err = custom.AfterDeleteHealthMenstruationPersonalInfo(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationPersonalInfoWithBeforeDeleteHealthMenstruationPersonalInfo called before DefaultDeleteHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default DeleteHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithBeforeDeleteHealthMenstruationPersonalInfo interface {
	BeforeDeleteHealthMenstruationPersonalInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationPersonalInfoWithAfterDeleteHealthMenstruationPersonalInfo called before DefaultDeleteHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default DeleteHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithAfterDeleteHealthMenstruationPersonalInfo interface {
	AfterDeleteHealthMenstruationPersonalInfo(context.Context, *DeleteHealthMenstruationPersonalInfoResponse, *gorm1.DB) error
}

// ListHealthMenstruationPersonalInfo ...
func (m *HealthDefaultServer) ListHealthMenstruationPersonalInfo(ctx context.Context, in *ListHealthMenstruationPersonalInfoRequest) (*ListHealthMenstruationPersonalInfoResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListHealthMenstruationPersonalInfo")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithBeforeListHealthMenstruationPersonalInfo); ok {
		var err error
		if db, err = custom.BeforeListHealthMenstruationPersonalInfo(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListHealthMenstruationPersonalInfo(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListHealthMenstruationPersonalInfoResponse{Results: res}
	if custom, ok := interface{}(in).(HealthHealthMenstruationPersonalInfoWithAfterListHealthMenstruationPersonalInfo); ok {
		var err error
		if err = custom.AfterListHealthMenstruationPersonalInfo(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// HealthHealthMenstruationPersonalInfoWithBeforeListHealthMenstruationPersonalInfo called before DefaultListHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default ListHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithBeforeListHealthMenstruationPersonalInfo interface {
	BeforeListHealthMenstruationPersonalInfo(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// HealthHealthMenstruationPersonalInfoWithAfterListHealthMenstruationPersonalInfo called before DefaultListHealthMenstruationPersonalInfoHealthMenstruationPersonalInfo in the default ListHealthMenstruationPersonalInfo handler
type HealthHealthMenstruationPersonalInfoWithAfterListHealthMenstruationPersonalInfo interface {
	AfterListHealthMenstruationPersonalInfo(context.Context, *ListHealthMenstruationPersonalInfoResponse, *gorm1.DB) error
}

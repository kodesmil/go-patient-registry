// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/kodesmil/ks-model/service.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

package pb

import context "context"
import fmt "fmt"
import strings "strings"
import time "time"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import go_uuid1 "github.com/satori/go.uuid"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import json1 "encoding/json"
import ptypes1 "github.com/golang/protobuf/ptypes"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import trace1 "go.opencensus.io/trace"
import types1 "github.com/infobloxopen/protoc-gen-gorm/types"

import math "math"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/envoyproxy/protoc-gen-validate/validate"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type ServiceTagORM struct {
	Id   uint64 `gorm:"type:serial;primary_key"`
	Key  string `gorm:"unique"`
	Name string
}

// TableName overrides the default tablename generated by GORM
func (ServiceTagORM) TableName() string {
	return "service_tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceTag) ToORM(ctx context.Context) (ServiceTagORM, error) {
	to := ServiceTagORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceTagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Key = m.Key
	to.Name = m.Name
	if posthook, ok := interface{}(m).(ServiceTagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceTagORM) ToPB(ctx context.Context) (ServiceTag, error) {
	to := ServiceTag{}
	var err error
	if prehook, ok := interface{}(m).(ServiceTagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Key = m.Key
	to.Name = m.Name
	if posthook, ok := interface{}(m).(ServiceTagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceTag the arg will be the target, the caller the one being converted from

// ServiceTagBeforeToORM called before default ToORM code
type ServiceTagWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceTagORM) error
}

// ServiceTagAfterToORM called after default ToORM code
type ServiceTagWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceTagORM) error
}

// ServiceTagBeforeToPB called before default ToPB code
type ServiceTagWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceTag) error
}

// ServiceTagAfterToPB called after default ToPB code
type ServiceTagWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceTag) error
}

type ServiceORM struct {
	CreatedAt *time.Time
	Id        uint64 `gorm:"type:serial;primary_key"`
	Name      string
	Tags      []*ServiceTagORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:service_service_tags;jointable_foreignkey:service_id;association_jointable_foreignkey:service_tag_id"`
	Type      int32
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceORM) TableName() string {
	return "services"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Service) ToORM(ctx context.Context) (ServiceORM, error) {
	to := ServiceORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	to.Type = int32(m.Type)
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceORM) ToPB(ctx context.Context) (Service, error) {
	to := Service{}
	var err error
	if prehook, ok := interface{}(m).(ServiceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Type = Service_Type(m.Type)
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Service the arg will be the target, the caller the one being converted from

// ServiceBeforeToORM called before default ToORM code
type ServiceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceORM) error
}

// ServiceAfterToORM called after default ToORM code
type ServiceWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceORM) error
}

// ServiceBeforeToPB called before default ToPB code
type ServiceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Service) error
}

// ServiceAfterToPB called after default ToPB code
type ServiceWithAfterToPB interface {
	AfterToPB(context.Context, *Service) error
}

type ServiceOfferORM struct {
	CreatedAt           *time.Time
	Currency            string
	Description         string
	Id                  *go_uuid1.UUID        `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
	Owner               *ServiceEmploymentORM `gorm:"foreignkey:ServiceEmploymentId;association_foreignkey:Id"`
	PictureUrl          string
	Price               float32
	Provider            *ServiceProviderORM `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	Service             *ServiceORM         `gorm:"foreignkey:ServiceId;association_foreignkey:Id"`
	ServiceEmploymentId *uint64
	ServiceId           *uint64
	ServiceProviderId   *go_uuid1.UUID
	Sessions            []*ServiceSessionORM `gorm:"foreignkey:ServiceOfferId;association_foreignkey:Id"`
	Title               string
	UpdatedAt           *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceOfferORM) TableName() string {
	return "service_offers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceOffer) ToORM(ctx context.Context) (ServiceOfferORM, error) {
	to := ServiceOfferORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceOfferWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		tempUUID, uErr := go_uuid1.FromString(m.Id.Value)
		if uErr != nil {
			return to, uErr
		}
		to.Id = &tempUUID
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Price = m.Price
	to.Currency = m.Currency
	if m.Service != nil {
		tempService, err := m.Service.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	to.Description = m.Description
	to.Title = m.Title
	to.PictureUrl = m.PictureUrl
	for _, v := range m.Sessions {
		if v != nil {
			if tempSessions, cErr := v.ToORM(ctx); cErr == nil {
				to.Sessions = append(to.Sessions, &tempSessions)
			} else {
				return to, cErr
			}
		} else {
			to.Sessions = append(to.Sessions, nil)
		}
	}
	if m.Owner != nil {
		tempOwner, err := m.Owner.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Owner = &tempOwner
	}
	if posthook, ok := interface{}(m).(ServiceOfferWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceOfferORM) ToPB(ctx context.Context) (ServiceOffer, error) {
	to := ServiceOffer{}
	var err error
	if prehook, ok := interface{}(m).(ServiceOfferWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id = &types1.UUIDValue{Value: m.Id.String()}
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Price = m.Price
	to.Currency = m.Currency
	if m.Service != nil {
		tempService, err := m.Service.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	to.Description = m.Description
	to.Title = m.Title
	to.PictureUrl = m.PictureUrl
	for _, v := range m.Sessions {
		if v != nil {
			if tempSessions, cErr := v.ToPB(ctx); cErr == nil {
				to.Sessions = append(to.Sessions, &tempSessions)
			} else {
				return to, cErr
			}
		} else {
			to.Sessions = append(to.Sessions, nil)
		}
	}
	if m.Owner != nil {
		tempOwner, err := m.Owner.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Owner = &tempOwner
	}
	if posthook, ok := interface{}(m).(ServiceOfferWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceOffer the arg will be the target, the caller the one being converted from

// ServiceOfferBeforeToORM called before default ToORM code
type ServiceOfferWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceOfferORM) error
}

// ServiceOfferAfterToORM called after default ToORM code
type ServiceOfferWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceOfferORM) error
}

// ServiceOfferBeforeToPB called before default ToPB code
type ServiceOfferWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceOffer) error
}

// ServiceOfferAfterToPB called after default ToPB code
type ServiceOfferWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceOffer) error
}

type ServiceEmploymentORM struct {
	CanBeContacted    bool
	CreatedAt         *time.Time
	Email             string
	FirstName         string
	Id                uint64 `gorm:"type:serial;primary_key"`
	LastName          string
	Phone             string
	ProfileId         string         `gorm:"type:uuid"`
	ServiceProviderId *go_uuid1.UUID `gorm:"type:uuid"`
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceEmploymentORM) TableName() string {
	return "service_employments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceEmployment) ToORM(ctx context.Context) (ServiceEmploymentORM, error) {
	to := ServiceEmploymentORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceEmploymentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.ProfileId = m.ProfileId
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.Email = m.Email
	to.Phone = m.Phone
	to.CanBeContacted = m.CanBeContacted
	if m.ServiceProviderId != nil {
		tempUUID, uErr := go_uuid1.FromString(m.ServiceProviderId.Value)
		if uErr != nil {
			return to, uErr
		}
		to.ServiceProviderId = &tempUUID
	}
	if posthook, ok := interface{}(m).(ServiceEmploymentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceEmploymentORM) ToPB(ctx context.Context) (ServiceEmployment, error) {
	to := ServiceEmployment{}
	var err error
	if prehook, ok := interface{}(m).(ServiceEmploymentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.ProfileId = m.ProfileId
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.Email = m.Email
	to.Phone = m.Phone
	to.CanBeContacted = m.CanBeContacted
	if m.ServiceProviderId != nil {
		to.ServiceProviderId = &types1.UUIDValue{Value: m.ServiceProviderId.String()}
	}
	if posthook, ok := interface{}(m).(ServiceEmploymentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceEmployment the arg will be the target, the caller the one being converted from

// ServiceEmploymentBeforeToORM called before default ToORM code
type ServiceEmploymentWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceEmploymentORM) error
}

// ServiceEmploymentAfterToORM called after default ToORM code
type ServiceEmploymentWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceEmploymentORM) error
}

// ServiceEmploymentBeforeToPB called before default ToPB code
type ServiceEmploymentWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceEmployment) error
}

// ServiceEmploymentAfterToPB called after default ToPB code
type ServiceEmploymentWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceEmployment) error
}

type ServiceDetailsORM struct {
	Address           string
	CreatedAt         *time.Time
	Email             string
	Id                uint64 `gorm:"type:serial;primary_key"`
	LogoUrl           string
	Name              string
	Phone             string
	ServiceProviderId *go_uuid1.UUID
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceDetailsORM) TableName() string {
	return "service_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceDetails) ToORM(ctx context.Context) (ServiceDetailsORM, error) {
	to := ServiceDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	to.Address = m.Address
	to.Phone = m.Phone
	to.LogoUrl = m.LogoUrl
	to.Email = m.Email
	if posthook, ok := interface{}(m).(ServiceDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceDetailsORM) ToPB(ctx context.Context) (ServiceDetails, error) {
	to := ServiceDetails{}
	var err error
	if prehook, ok := interface{}(m).(ServiceDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Address = m.Address
	to.Phone = m.Phone
	to.LogoUrl = m.LogoUrl
	to.Email = m.Email
	if posthook, ok := interface{}(m).(ServiceDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceDetails the arg will be the target, the caller the one being converted from

// ServiceDetailsBeforeToORM called before default ToORM code
type ServiceDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceDetailsORM) error
}

// ServiceDetailsAfterToORM called after default ToORM code
type ServiceDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceDetailsORM) error
}

// ServiceDetailsBeforeToPB called before default ToPB code
type ServiceDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceDetails) error
}

// ServiceDetailsAfterToPB called after default ToPB code
type ServiceDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceDetails) error
}

type ServiceApplicationORM struct {
	AppliedAt         *time.Time
	ApprovedAt        *time.Time
	CreatedAt         *time.Time
	Files             []*ServiceApplicationFileORM `gorm:"foreignkey:ServiceApplicationId;association_foreignkey:Id"`
	Id                *go_uuid1.UUID               `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
	Provider          *ServiceProviderORM          `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	ReviewerId        *go_uuid1.UUID               `gorm:"type:uuid"`
	ServiceProviderId *go_uuid1.UUID
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceApplicationORM) TableName() string {
	return "service_applications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceApplication) ToORM(ctx context.Context) (ServiceApplicationORM, error) {
	to := ServiceApplicationORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		tempUUID, uErr := go_uuid1.FromString(m.Id.Value)
		if uErr != nil {
			return to, uErr
		}
		to.Id = &tempUUID
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	for _, v := range m.Files {
		if v != nil {
			if tempFiles, cErr := v.ToORM(ctx); cErr == nil {
				to.Files = append(to.Files, &tempFiles)
			} else {
				return to, cErr
			}
		} else {
			to.Files = append(to.Files, nil)
		}
	}
	if m.AppliedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.AppliedAt); err != nil {
			return to, err
		}
		to.AppliedAt = &t
	}
	if m.ApprovedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.ApprovedAt); err != nil {
			return to, err
		}
		to.ApprovedAt = &t
	}
	if m.ReviewerId != nil {
		tempUUID, uErr := go_uuid1.FromString(m.ReviewerId.Value)
		if uErr != nil {
			return to, uErr
		}
		to.ReviewerId = &tempUUID
	}
	if posthook, ok := interface{}(m).(ServiceApplicationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceApplicationORM) ToPB(ctx context.Context) (ServiceApplication, error) {
	to := ServiceApplication{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id = &types1.UUIDValue{Value: m.Id.String()}
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	for _, v := range m.Files {
		if v != nil {
			if tempFiles, cErr := v.ToPB(ctx); cErr == nil {
				to.Files = append(to.Files, &tempFiles)
			} else {
				return to, cErr
			}
		} else {
			to.Files = append(to.Files, nil)
		}
	}
	if m.AppliedAt != nil {
		if to.AppliedAt, err = ptypes1.TimestampProto(*m.AppliedAt); err != nil {
			return to, err
		}
	}
	if m.ApprovedAt != nil {
		if to.ApprovedAt, err = ptypes1.TimestampProto(*m.ApprovedAt); err != nil {
			return to, err
		}
	}
	if m.ReviewerId != nil {
		to.ReviewerId = &types1.UUIDValue{Value: m.ReviewerId.String()}
	}
	if posthook, ok := interface{}(m).(ServiceApplicationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceApplication the arg will be the target, the caller the one being converted from

// ServiceApplicationBeforeToORM called before default ToORM code
type ServiceApplicationWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceApplicationORM) error
}

// ServiceApplicationAfterToORM called after default ToORM code
type ServiceApplicationWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceApplicationORM) error
}

// ServiceApplicationBeforeToPB called before default ToPB code
type ServiceApplicationWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceApplication) error
}

// ServiceApplicationAfterToPB called after default ToPB code
type ServiceApplicationWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceApplication) error
}

type ServiceApplicationFileORM struct {
	CreatedAt            *time.Time
	Id                   *go_uuid1.UUID `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
	ServiceApplicationId *go_uuid1.UUID
	UpdatedAt            *time.Time
	Url                  string
}

// TableName overrides the default tablename generated by GORM
func (ServiceApplicationFileORM) TableName() string {
	return "service_application_files"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceApplicationFile) ToORM(ctx context.Context) (ServiceApplicationFileORM, error) {
	to := ServiceApplicationFileORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationFileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		tempUUID, uErr := go_uuid1.FromString(m.Id.Value)
		if uErr != nil {
			return to, uErr
		}
		to.Id = &tempUUID
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Url = m.Url
	if posthook, ok := interface{}(m).(ServiceApplicationFileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceApplicationFileORM) ToPB(ctx context.Context) (ServiceApplicationFile, error) {
	to := ServiceApplicationFile{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationFileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id = &types1.UUIDValue{Value: m.Id.String()}
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Url = m.Url
	if posthook, ok := interface{}(m).(ServiceApplicationFileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceApplicationFile the arg will be the target, the caller the one being converted from

// ServiceApplicationFileBeforeToORM called before default ToORM code
type ServiceApplicationFileWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceApplicationFileORM) error
}

// ServiceApplicationFileAfterToORM called after default ToORM code
type ServiceApplicationFileWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceApplicationFileORM) error
}

// ServiceApplicationFileBeforeToPB called before default ToPB code
type ServiceApplicationFileWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceApplicationFile) error
}

// ServiceApplicationFileAfterToPB called after default ToPB code
type ServiceApplicationFileWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceApplicationFile) error
}

type ServiceProviderORM struct {
	CreatedAt   *time.Time
	Details     *ServiceDetailsORM      `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	Employments []*ServiceEmploymentORM `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	Id          *go_uuid1.UUID          `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
	Offers      []*ServiceOfferORM      `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	UpdatedAt   *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceProviderORM) TableName() string {
	return "service_providers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceProvider) ToORM(ctx context.Context) (ServiceProviderORM, error) {
	to := ServiceProviderORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceProviderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		tempUUID, uErr := go_uuid1.FromString(m.Id.Value)
		if uErr != nil {
			return to, uErr
		}
		to.Id = &tempUUID
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Details != nil {
		tempDetails, err := m.Details.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Details = &tempDetails
	}
	for _, v := range m.Offers {
		if v != nil {
			if tempOffers, cErr := v.ToORM(ctx); cErr == nil {
				to.Offers = append(to.Offers, &tempOffers)
			} else {
				return to, cErr
			}
		} else {
			to.Offers = append(to.Offers, nil)
		}
	}
	for _, v := range m.Employments {
		if v != nil {
			if tempEmployments, cErr := v.ToORM(ctx); cErr == nil {
				to.Employments = append(to.Employments, &tempEmployments)
			} else {
				return to, cErr
			}
		} else {
			to.Employments = append(to.Employments, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceProviderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceProviderORM) ToPB(ctx context.Context) (ServiceProvider, error) {
	to := ServiceProvider{}
	var err error
	if prehook, ok := interface{}(m).(ServiceProviderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id = &types1.UUIDValue{Value: m.Id.String()}
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Details != nil {
		tempDetails, err := m.Details.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Details = &tempDetails
	}
	for _, v := range m.Offers {
		if v != nil {
			if tempOffers, cErr := v.ToPB(ctx); cErr == nil {
				to.Offers = append(to.Offers, &tempOffers)
			} else {
				return to, cErr
			}
		} else {
			to.Offers = append(to.Offers, nil)
		}
	}
	for _, v := range m.Employments {
		if v != nil {
			if tempEmployments, cErr := v.ToPB(ctx); cErr == nil {
				to.Employments = append(to.Employments, &tempEmployments)
			} else {
				return to, cErr
			}
		} else {
			to.Employments = append(to.Employments, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceProviderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceProvider the arg will be the target, the caller the one being converted from

// ServiceProviderBeforeToORM called before default ToORM code
type ServiceProviderWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceProviderORM) error
}

// ServiceProviderAfterToORM called after default ToORM code
type ServiceProviderWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceProviderORM) error
}

// ServiceProviderBeforeToPB called before default ToPB code
type ServiceProviderWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceProvider) error
}

// ServiceProviderAfterToPB called after default ToPB code
type ServiceProviderWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceProvider) error
}

type ServiceSessionEvaluationORM struct {
	Comment            string
	CreatedAt          *time.Time
	Id                 uint64 `gorm:"type:serial;primary_key"`
	RecommendationRate float64
	ServiceSessionId   *go_uuid1.UUID
	Session            *ServiceSessionORM `gorm:"foreignkey:ServiceSessionId;association_foreignkey:Id"`
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceSessionEvaluationORM) TableName() string {
	return "service_session_evaluations"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceSessionEvaluation) ToORM(ctx context.Context) (ServiceSessionEvaluationORM, error) {
	to := ServiceSessionEvaluationORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionEvaluationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Session != nil {
		tempSession, err := m.Session.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Session = &tempSession
	}
	to.Comment = m.Comment
	to.RecommendationRate = m.RecommendationRate
	if posthook, ok := interface{}(m).(ServiceSessionEvaluationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceSessionEvaluationORM) ToPB(ctx context.Context) (ServiceSessionEvaluation, error) {
	to := ServiceSessionEvaluation{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionEvaluationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Session != nil {
		tempSession, err := m.Session.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Session = &tempSession
	}
	to.Comment = m.Comment
	to.RecommendationRate = m.RecommendationRate
	if posthook, ok := interface{}(m).(ServiceSessionEvaluationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceSessionEvaluation the arg will be the target, the caller the one being converted from

// ServiceSessionEvaluationBeforeToORM called before default ToORM code
type ServiceSessionEvaluationWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceSessionEvaluationORM) error
}

// ServiceSessionEvaluationAfterToORM called after default ToORM code
type ServiceSessionEvaluationWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceSessionEvaluationORM) error
}

// ServiceSessionEvaluationBeforeToPB called before default ToPB code
type ServiceSessionEvaluationWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceSessionEvaluation) error
}

// ServiceSessionEvaluationAfterToPB called after default ToPB code
type ServiceSessionEvaluationWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceSessionEvaluation) error
}

type ServiceSessionORM struct {
	CreatedAt            *time.Time
	Evaluations          []*ServiceSessionEvaluationORM `gorm:"foreignkey:ServiceSessionId;association_foreignkey:Id"`
	FinishedAt           *time.Time
	Id                   *go_uuid1.UUID           `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
	Notes                []*ServiceSessionNoteORM `gorm:"foreignkey:ServiceSessionId;association_foreignkey:Id"`
	Offer                *ServiceOfferORM         `gorm:"foreignkey:ServiceOfferId;association_foreignkey:Id"`
	ProfileId            string                   `gorm:"type:uuid"`
	ScheduledAt          *time.Time
	ServiceOfferId       *go_uuid1.UUID
	ServiceSessionNoteId *go_uuid1.UUID
	Status               int32
	UpdatedAt            *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceSessionORM) TableName() string {
	return "service_sessions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceSession) ToORM(ctx context.Context) (ServiceSessionORM, error) {
	to := ServiceSessionORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		tempUUID, uErr := go_uuid1.FromString(m.Id.Value)
		if uErr != nil {
			return to, uErr
		}
		to.Id = &tempUUID
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.ProfileId = m.ProfileId
	if m.ScheduledAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.ScheduledAt); err != nil {
			return to, err
		}
		to.ScheduledAt = &t
	}
	if m.FinishedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.FinishedAt); err != nil {
			return to, err
		}
		to.FinishedAt = &t
	}
	if m.Offer != nil {
		tempOffer, err := m.Offer.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Offer = &tempOffer
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	to.Status = int32(m.Status)
	for _, v := range m.Evaluations {
		if v != nil {
			if tempEvaluations, cErr := v.ToORM(ctx); cErr == nil {
				to.Evaluations = append(to.Evaluations, &tempEvaluations)
			} else {
				return to, cErr
			}
		} else {
			to.Evaluations = append(to.Evaluations, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceSessionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceSessionORM) ToPB(ctx context.Context) (ServiceSession, error) {
	to := ServiceSession{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id = &types1.UUIDValue{Value: m.Id.String()}
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.ProfileId = m.ProfileId
	if m.ScheduledAt != nil {
		if to.ScheduledAt, err = ptypes1.TimestampProto(*m.ScheduledAt); err != nil {
			return to, err
		}
	}
	if m.FinishedAt != nil {
		if to.FinishedAt, err = ptypes1.TimestampProto(*m.FinishedAt); err != nil {
			return to, err
		}
	}
	if m.Offer != nil {
		tempOffer, err := m.Offer.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Offer = &tempOffer
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	to.Status = ServiceSession_Status(m.Status)
	for _, v := range m.Evaluations {
		if v != nil {
			if tempEvaluations, cErr := v.ToPB(ctx); cErr == nil {
				to.Evaluations = append(to.Evaluations, &tempEvaluations)
			} else {
				return to, cErr
			}
		} else {
			to.Evaluations = append(to.Evaluations, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceSessionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceSession the arg will be the target, the caller the one being converted from

// ServiceSessionBeforeToORM called before default ToORM code
type ServiceSessionWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceSessionORM) error
}

// ServiceSessionAfterToORM called after default ToORM code
type ServiceSessionWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceSessionORM) error
}

// ServiceSessionBeforeToPB called before default ToPB code
type ServiceSessionWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceSession) error
}

// ServiceSessionAfterToPB called after default ToPB code
type ServiceSessionWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceSession) error
}

type ServiceSessionNoteORM struct {
	CreatedAt        *time.Time
	Id               *go_uuid1.UUID `gorm:"type:uuid;primary_key;default:uuid_generate_v4()"`
	ServiceSessionId *go_uuid1.UUID
	Session          *ServiceSessionORM `gorm:"foreignkey:ServiceSessionNoteId;association_foreignkey:Id"`
	Text             string
	UpdatedAt        *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceSessionNoteORM) TableName() string {
	return "service_session_notes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceSessionNote) ToORM(ctx context.Context) (ServiceSessionNoteORM, error) {
	to := ServiceSessionNoteORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionNoteWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		tempUUID, uErr := go_uuid1.FromString(m.Id.Value)
		if uErr != nil {
			return to, uErr
		}
		to.Id = &tempUUID
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Session != nil {
		tempSession, err := m.Session.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Session = &tempSession
	}
	to.Text = m.Text
	if posthook, ok := interface{}(m).(ServiceSessionNoteWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceSessionNoteORM) ToPB(ctx context.Context) (ServiceSessionNote, error) {
	to := ServiceSessionNote{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionNoteWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Id != nil {
		to.Id = &types1.UUIDValue{Value: m.Id.String()}
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Session != nil {
		tempSession, err := m.Session.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Session = &tempSession
	}
	to.Text = m.Text
	if posthook, ok := interface{}(m).(ServiceSessionNoteWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceSessionNote the arg will be the target, the caller the one being converted from

// ServiceSessionNoteBeforeToORM called before default ToORM code
type ServiceSessionNoteWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceSessionNoteORM) error
}

// ServiceSessionNoteAfterToORM called after default ToORM code
type ServiceSessionNoteWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceSessionNoteORM) error
}

// ServiceSessionNoteBeforeToPB called before default ToPB code
type ServiceSessionNoteWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceSessionNote) error
}

// ServiceSessionNoteAfterToPB called after default ToPB code
type ServiceSessionNoteWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceSessionNote) error
}

// DefaultCreateServiceTag executes a basic gorm create call
func DefaultCreateServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceTagORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceTag executes a basic gorm read call
func DefaultReadServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceTagORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceTagORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceTagORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceTagORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceTagORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceTagSet(ctx context.Context, in []*ServiceTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceTagORM{})).(ServiceTagORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceTagORM{})).(ServiceTagORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceTagORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceTag, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceTag, *gorm1.DB) error
}

// DefaultStrictUpdateServiceTag clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceTagORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceTagORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceTag executes a basic gorm update call with patch behavior
func DefaultPatchServiceTag(ctx context.Context, in *ServiceTag, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceTag
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceTagWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceTag(ctx, &ServiceTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceTagWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceTag(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceTagWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceTag(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceTagWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceTagWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceTag executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceTag(ctx context.Context, objects []*ServiceTag, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceTag, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceTag, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceTag(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceTag patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceTag(ctx context.Context, patchee *ServiceTag, patcher *ServiceTag, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceTag, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceTag executes a gorm list call
func DefaultListServiceTag(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceTag, error) {
	in := ServiceTag{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceTagORM{}, &ServiceTag{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceTagORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceTag{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceTagORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceTagORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceTagORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateService executes a basic gorm create call
func DefaultCreateService(ctx context.Context, in *Service, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadService executes a basic gorm read call
func DefaultReadService(ctx context.Context, in *Service, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteService(ctx context.Context, in *Service, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSet(ctx context.Context, in []*Service, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceORM{})).(ServiceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceORM{})).(ServiceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Service, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Service, *gorm1.DB) error
}

// DefaultStrictUpdateService clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateService(ctx context.Context, in *Service, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateService")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchService executes a basic gorm update call with patch behavior
func DefaultPatchService(ctx context.Context, in *Service, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Service
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskService(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateService(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetService executes a bulk gorm update call with patch behavior
func DefaultPatchSetService(ctx context.Context, objects []*Service, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Service, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Service, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchService(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskService patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskService(ctx context.Context, patchee *Service, patcher *Service, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Service, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListService executes a gorm list call
func DefaultListService(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Service, error) {
	in := Service{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceORM{}, &Service{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Service{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceOffer executes a basic gorm create call
func DefaultCreateServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceOfferORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceOffer executes a basic gorm read call
func DefaultReadServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceOfferORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceOfferORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceOfferORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceOfferORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceOfferORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceOfferORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceOfferSet(ctx context.Context, in []*ServiceOffer, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []*go_uuid1.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceOfferORM{})).(ServiceOfferORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceOfferORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceOfferORM{})).(ServiceOfferORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceOfferORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceOffer, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceOffer, *gorm1.DB) error
}

// DefaultStrictUpdateServiceOffer clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceOffer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceOfferORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSessions := ServiceSessionORM{}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	filterSessions.ServiceOfferId = new(go_uuid1.UUID)
	*filterSessions.ServiceOfferId = *ormObj.Id
	if err = db.Where(filterSessions).Delete(ServiceSessionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceOfferORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceOffer executes a basic gorm update call with patch behavior
func DefaultPatchServiceOffer(ctx context.Context, in *ServiceOffer, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceOffer
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceOfferWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceOffer(ctx, &ServiceOffer{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceOfferWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceOffer(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceOfferWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceOffer(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceOfferWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceOfferWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceOffer executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceOffer(ctx context.Context, objects []*ServiceOffer, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceOffer, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceOffer, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceOffer(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceOffer patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceOffer(ctx context.Context, patchee *ServiceOffer, patcher *ServiceOffer, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceOffer, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedService bool
	var updatedProvider bool
	var updatedOwner bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedService && strings.HasPrefix(f, prefix+"Service.") {
			updatedService = true
			if patcher.Service == nil {
				patchee.Service = nil
				continue
			}
			if patchee.Service == nil {
				patchee.Service = &Service{}
			}
			if o, err := DefaultApplyFieldMaskService(ctx, patchee.Service, patcher.Service, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Service.", db); err != nil {
				return nil, err
			} else {
				patchee.Service = o
			}
			continue
		}
		if f == prefix+"Service" {
			updatedService = true
			patchee.Service = patcher.Service
			continue
		}
		if !updatedProvider && strings.HasPrefix(f, prefix+"Provider.") {
			updatedProvider = true
			if patcher.Provider == nil {
				patchee.Provider = nil
				continue
			}
			if patchee.Provider == nil {
				patchee.Provider = &ServiceProvider{}
			}
			if o, err := DefaultApplyFieldMaskServiceProvider(ctx, patchee.Provider, patcher.Provider, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Provider.", db); err != nil {
				return nil, err
			} else {
				patchee.Provider = o
			}
			continue
		}
		if f == prefix+"Provider" {
			updatedProvider = true
			patchee.Provider = patcher.Provider
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"PictureUrl" {
			patchee.PictureUrl = patcher.PictureUrl
			continue
		}
		if f == prefix+"Sessions" {
			patchee.Sessions = patcher.Sessions
			continue
		}
		if !updatedOwner && strings.HasPrefix(f, prefix+"Owner.") {
			updatedOwner = true
			if patcher.Owner == nil {
				patchee.Owner = nil
				continue
			}
			if patchee.Owner == nil {
				patchee.Owner = &ServiceEmployment{}
			}
			if o, err := DefaultApplyFieldMaskServiceEmployment(ctx, patchee.Owner, patcher.Owner, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Owner.", db); err != nil {
				return nil, err
			} else {
				patchee.Owner = o
			}
			continue
		}
		if f == prefix+"Owner" {
			updatedOwner = true
			patchee.Owner = patcher.Owner
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceOffer executes a gorm list call
func DefaultListServiceOffer(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceOffer, error) {
	in := ServiceOffer{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceOfferORM{}, &ServiceOffer{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceOfferORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceOffer{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceOfferORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceOfferORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceOfferORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceEmployment executes a basic gorm create call
func DefaultCreateServiceEmployment(ctx context.Context, in *ServiceEmployment, db *gorm1.DB) (*ServiceEmployment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceEmploymentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceEmployment executes a basic gorm read call
func DefaultReadServiceEmployment(ctx context.Context, in *ServiceEmployment, db *gorm1.DB) (*ServiceEmployment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceEmploymentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceEmploymentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceEmploymentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceEmploymentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceEmployment(ctx context.Context, in *ServiceEmployment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceEmploymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceEmploymentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceEmploymentSet(ctx context.Context, in []*ServiceEmployment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceEmploymentORM{})).(ServiceEmploymentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceEmploymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceEmploymentORM{})).(ServiceEmploymentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceEmploymentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceEmployment, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceEmployment, *gorm1.DB) error
}

// DefaultStrictUpdateServiceEmployment clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceEmployment(ctx context.Context, in *ServiceEmployment, db *gorm1.DB) (*ServiceEmployment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceEmployment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceEmploymentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceEmploymentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceEmployment executes a basic gorm update call with patch behavior
func DefaultPatchServiceEmployment(ctx context.Context, in *ServiceEmployment, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceEmployment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceEmployment
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceEmploymentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceEmployment(ctx, &ServiceEmployment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceEmploymentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceEmployment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceEmploymentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceEmployment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceEmploymentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceEmploymentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceEmployment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceEmployment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceEmployment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceEmploymentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceEmployment, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceEmployment executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceEmployment(ctx context.Context, objects []*ServiceEmployment, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceEmployment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceEmployment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceEmployment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceEmployment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceEmployment(ctx context.Context, patchee *ServiceEmployment, patcher *ServiceEmployment, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceEmployment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"ProfileId" {
			patchee.ProfileId = patcher.ProfileId
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Phone" {
			patchee.Phone = patcher.Phone
			continue
		}
		if f == prefix+"CanBeContacted" {
			patchee.CanBeContacted = patcher.CanBeContacted
			continue
		}
		if f == prefix+"ServiceProviderId" {
			patchee.ServiceProviderId = patcher.ServiceProviderId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceEmployment executes a gorm list call
func DefaultListServiceEmployment(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceEmployment, error) {
	in := ServiceEmployment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceEmploymentORM{}, &ServiceEmployment{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceEmploymentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceEmploymentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceEmployment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceEmploymentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceEmploymentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceEmploymentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceEmploymentORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceDetails executes a basic gorm create call
func DefaultCreateServiceDetails(ctx context.Context, in *ServiceDetails, db *gorm1.DB) (*ServiceDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceDetails executes a basic gorm read call
func DefaultReadServiceDetails(ctx context.Context, in *ServiceDetails, db *gorm1.DB) (*ServiceDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceDetails(ctx context.Context, in *ServiceDetails, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceDetailsSet(ctx context.Context, in []*ServiceDetails, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceDetailsORM{})).(ServiceDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceDetailsORM{})).(ServiceDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceDetails, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceDetails, *gorm1.DB) error
}

// DefaultStrictUpdateServiceDetails clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceDetails(ctx context.Context, in *ServiceDetails, db *gorm1.DB) (*ServiceDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceDetails executes a basic gorm update call with patch behavior
func DefaultPatchServiceDetails(ctx context.Context, in *ServiceDetails, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceDetails
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceDetails(ctx, &ServiceDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceDetails, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceDetails(ctx context.Context, objects []*ServiceDetails, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceDetails(ctx context.Context, patchee *ServiceDetails, patcher *ServiceDetails, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Phone" {
			patchee.Phone = patcher.Phone
			continue
		}
		if f == prefix+"LogoUrl" {
			patchee.LogoUrl = patcher.LogoUrl
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceDetails executes a gorm list call
func DefaultListServiceDetails(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceDetails, error) {
	in := ServiceDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceDetailsORM{}, &ServiceDetails{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceDetailsORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceApplication executes a basic gorm create call
func DefaultCreateServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceApplication executes a basic gorm read call
func DefaultReadServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceApplicationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceApplicationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceApplicationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceApplicationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplicationSet(ctx context.Context, in []*ServiceApplication, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []*go_uuid1.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceApplicationORM{})).(ServiceApplicationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceApplicationORM{})).(ServiceApplicationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceApplicationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceApplication, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceApplication, *gorm1.DB) error
}

// DefaultStrictUpdateServiceApplication clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceApplication")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceApplicationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFiles := ServiceApplicationFileORM{}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	filterFiles.ServiceApplicationId = new(go_uuid1.UUID)
	*filterFiles.ServiceApplicationId = *ormObj.Id
	if err = db.Where(filterFiles).Delete(ServiceApplicationFileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceApplicationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceApplication executes a basic gorm update call with patch behavior
func DefaultPatchServiceApplication(ctx context.Context, in *ServiceApplication, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceApplication
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceApplicationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceApplication(ctx, &ServiceApplication{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceApplicationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceApplication(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceApplicationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceApplication(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceApplicationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceApplicationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceApplication executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceApplication(ctx context.Context, objects []*ServiceApplication, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceApplication, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceApplication, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceApplication(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceApplication patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceApplication(ctx context.Context, patchee *ServiceApplication, patcher *ServiceApplication, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceApplication, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedProvider bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedProvider && strings.HasPrefix(f, prefix+"Provider.") {
			updatedProvider = true
			if patcher.Provider == nil {
				patchee.Provider = nil
				continue
			}
			if patchee.Provider == nil {
				patchee.Provider = &ServiceProvider{}
			}
			if o, err := DefaultApplyFieldMaskServiceProvider(ctx, patchee.Provider, patcher.Provider, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Provider.", db); err != nil {
				return nil, err
			} else {
				patchee.Provider = o
			}
			continue
		}
		if f == prefix+"Provider" {
			updatedProvider = true
			patchee.Provider = patcher.Provider
			continue
		}
		if f == prefix+"Files" {
			patchee.Files = patcher.Files
			continue
		}
		if f == prefix+"AppliedAt" {
			patchee.AppliedAt = patcher.AppliedAt
			continue
		}
		if f == prefix+"ApprovedAt" {
			patchee.ApprovedAt = patcher.ApprovedAt
			continue
		}
		if f == prefix+"ReviewerId" {
			patchee.ReviewerId = patcher.ReviewerId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceApplication executes a gorm list call
func DefaultListServiceApplication(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceApplication, error) {
	in := ServiceApplication{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceApplicationORM{}, &ServiceApplication{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceApplicationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceApplication{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceApplicationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceApplicationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceApplicationORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceApplicationFile executes a basic gorm create call
func DefaultCreateServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationFileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceApplicationFile executes a basic gorm read call
func DefaultReadServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceApplicationFileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceApplicationFileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceApplicationFileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationFileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceApplicationFileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceApplicationFileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplicationFileSet(ctx context.Context, in []*ServiceApplicationFile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []*go_uuid1.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceApplicationFileORM{})).(ServiceApplicationFileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceApplicationFileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceApplicationFileORM{})).(ServiceApplicationFileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceApplicationFileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceApplicationFile, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceApplicationFile, *gorm1.DB) error
}

// DefaultStrictUpdateServiceApplicationFile clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceApplicationFile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceApplicationFileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceApplicationFileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceApplicationFile executes a basic gorm update call with patch behavior
func DefaultPatchServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceApplicationFile
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceApplicationFileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceApplicationFile(ctx, &ServiceApplicationFile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceApplicationFileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceApplicationFile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceApplicationFileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceApplicationFile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceApplicationFileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceApplicationFileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceApplicationFile executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceApplicationFile(ctx context.Context, objects []*ServiceApplicationFile, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceApplicationFile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceApplicationFile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceApplicationFile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceApplicationFile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceApplicationFile(ctx context.Context, patchee *ServiceApplicationFile, patcher *ServiceApplicationFile, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Url" {
			patchee.Url = patcher.Url
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceApplicationFile executes a gorm list call
func DefaultListServiceApplicationFile(ctx context.Context, db *gorm1.DB) ([]*ServiceApplicationFile, error) {
	in := ServiceApplicationFile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceApplicationFileORM{}, &ServiceApplicationFile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceApplicationFileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceApplicationFile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceApplicationFileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceApplicationFileORM) error
}

// DefaultCreateServiceProvider executes a basic gorm create call
func DefaultCreateServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceProviderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceProvider executes a basic gorm read call
func DefaultReadServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceProviderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceProviderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceProviderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceProviderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceProviderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceProviderSet(ctx context.Context, in []*ServiceProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []*go_uuid1.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceProviderORM{})).(ServiceProviderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceProviderORM{})).(ServiceProviderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceProviderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceProvider, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceProvider, *gorm1.DB) error
}

// DefaultStrictUpdateServiceProvider clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceProvider")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceProviderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDetails := ServiceDetailsORM{}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	filterDetails.ServiceProviderId = new(go_uuid1.UUID)
	*filterDetails.ServiceProviderId = *ormObj.Id
	if err = db.Where(filterDetails).Delete(ServiceDetailsORM{}).Error; err != nil {
		return nil, err
	}
	filterEmployments := ServiceEmploymentORM{}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	filterEmployments.ServiceProviderId = new(go_uuid1.UUID)
	*filterEmployments.ServiceProviderId = *ormObj.Id
	if err = db.Where(filterEmployments).Delete(ServiceEmploymentORM{}).Error; err != nil {
		return nil, err
	}
	filterOffers := ServiceOfferORM{}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	filterOffers.ServiceProviderId = new(go_uuid1.UUID)
	*filterOffers.ServiceProviderId = *ormObj.Id
	if err = db.Where(filterOffers).Delete(ServiceOfferORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceProviderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceProvider executes a basic gorm update call with patch behavior
func DefaultPatchServiceProvider(ctx context.Context, in *ServiceProvider, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceProvider
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceProviderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceProvider(ctx, &ServiceProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceProviderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceProvider(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceProviderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceProvider(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceProviderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceProviderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceProvider executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceProvider(ctx context.Context, objects []*ServiceProvider, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceProvider, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceProvider, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceProvider(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceProvider patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceProvider(ctx context.Context, patchee *ServiceProvider, patcher *ServiceProvider, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceProvider, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedDetails bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDetails && strings.HasPrefix(f, prefix+"Details.") {
			updatedDetails = true
			if patcher.Details == nil {
				patchee.Details = nil
				continue
			}
			if patchee.Details == nil {
				patchee.Details = &ServiceDetails{}
			}
			if o, err := DefaultApplyFieldMaskServiceDetails(ctx, patchee.Details, patcher.Details, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Details.", db); err != nil {
				return nil, err
			} else {
				patchee.Details = o
			}
			continue
		}
		if f == prefix+"Details" {
			updatedDetails = true
			patchee.Details = patcher.Details
			continue
		}
		if f == prefix+"Offers" {
			patchee.Offers = patcher.Offers
			continue
		}
		if f == prefix+"Employments" {
			patchee.Employments = patcher.Employments
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceProvider executes a gorm list call
func DefaultListServiceProvider(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceProvider, error) {
	in := ServiceProvider{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceProviderORM{}, &ServiceProvider{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceProviderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceProvider{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceProviderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceProviderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceProviderORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceSessionEvaluation executes a basic gorm create call
func DefaultCreateServiceSessionEvaluation(ctx context.Context, in *ServiceSessionEvaluation, db *gorm1.DB) (*ServiceSessionEvaluation, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionEvaluationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceSessionEvaluation executes a basic gorm read call
func DefaultReadServiceSessionEvaluation(ctx context.Context, in *ServiceSessionEvaluation, db *gorm1.DB) (*ServiceSessionEvaluation, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceSessionEvaluationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceSessionEvaluationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceSessionEvaluationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionEvaluationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSessionEvaluation(ctx context.Context, in *ServiceSessionEvaluation, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceSessionEvaluationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceSessionEvaluationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSessionEvaluationSet(ctx context.Context, in []*ServiceSessionEvaluation, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceSessionEvaluationORM{})).(ServiceSessionEvaluationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceSessionEvaluationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceSessionEvaluationORM{})).(ServiceSessionEvaluationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceSessionEvaluationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceSessionEvaluation, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceSessionEvaluation, *gorm1.DB) error
}

// DefaultStrictUpdateServiceSessionEvaluation clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceSessionEvaluation(ctx context.Context, in *ServiceSessionEvaluation, db *gorm1.DB) (*ServiceSessionEvaluation, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceSessionEvaluation")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceSessionEvaluationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceSessionEvaluationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceSessionEvaluation executes a basic gorm update call with patch behavior
func DefaultPatchServiceSessionEvaluation(ctx context.Context, in *ServiceSessionEvaluation, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceSessionEvaluation, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceSessionEvaluation
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceSessionEvaluationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceSessionEvaluation(ctx, &ServiceSessionEvaluation{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceSessionEvaluationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceSessionEvaluation(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceSessionEvaluationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceSessionEvaluation(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceSessionEvaluationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceSessionEvaluationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceSessionEvaluation, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceSessionEvaluation, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceSessionEvaluation, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionEvaluationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceSessionEvaluation, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceSessionEvaluation executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceSessionEvaluation(ctx context.Context, objects []*ServiceSessionEvaluation, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceSessionEvaluation, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceSessionEvaluation, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceSessionEvaluation(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceSessionEvaluation patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceSessionEvaluation(ctx context.Context, patchee *ServiceSessionEvaluation, patcher *ServiceSessionEvaluation, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceSessionEvaluation, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedSession bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedSession && strings.HasPrefix(f, prefix+"Session.") {
			updatedSession = true
			if patcher.Session == nil {
				patchee.Session = nil
				continue
			}
			if patchee.Session == nil {
				patchee.Session = &ServiceSession{}
			}
			if o, err := DefaultApplyFieldMaskServiceSession(ctx, patchee.Session, patcher.Session, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Session.", db); err != nil {
				return nil, err
			} else {
				patchee.Session = o
			}
			continue
		}
		if f == prefix+"Session" {
			updatedSession = true
			patchee.Session = patcher.Session
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"RecommendationRate" {
			patchee.RecommendationRate = patcher.RecommendationRate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceSessionEvaluation executes a gorm list call
func DefaultListServiceSessionEvaluation(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceSessionEvaluation, error) {
	in := ServiceSessionEvaluation{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceSessionEvaluationORM{}, &ServiceSessionEvaluation{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceSessionEvaluationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionEvaluationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceSessionEvaluation{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceSessionEvaluationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceSessionEvaluationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceSessionEvaluationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceSessionEvaluationORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceSession executes a basic gorm create call
func DefaultCreateServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceSession executes a basic gorm read call
func DefaultReadServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceSessionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceSessionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceSessionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceSessionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceSessionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSessionSet(ctx context.Context, in []*ServiceSession, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []*go_uuid1.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceSessionORM{})).(ServiceSessionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceSessionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceSessionORM{})).(ServiceSessionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceSessionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceSession, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceSession, *gorm1.DB) error
}

// DefaultStrictUpdateServiceSession clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceSession")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceSessionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterEvaluations := ServiceSessionEvaluationORM{}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	filterEvaluations.ServiceSessionId = new(go_uuid1.UUID)
	*filterEvaluations.ServiceSessionId = *ormObj.Id
	if err = db.Where(filterEvaluations).Delete(ServiceSessionEvaluationORM{}).Error; err != nil {
		return nil, err
	}
	filterNotes := ServiceSessionNoteORM{}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	filterNotes.ServiceSessionId = new(go_uuid1.UUID)
	*filterNotes.ServiceSessionId = *ormObj.Id
	if err = db.Where(filterNotes).Delete(ServiceSessionNoteORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceSessionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceSession executes a basic gorm update call with patch behavior
func DefaultPatchServiceSession(ctx context.Context, in *ServiceSession, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceSession
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceSessionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceSession(ctx, &ServiceSession{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceSessionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceSession(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceSessionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceSession(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceSessionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceSessionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceSession executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceSession(ctx context.Context, objects []*ServiceSession, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceSession, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceSession, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceSession(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceSession patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceSession(ctx context.Context, patchee *ServiceSession, patcher *ServiceSession, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceSession, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedOffer bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"ProfileId" {
			patchee.ProfileId = patcher.ProfileId
			continue
		}
		if f == prefix+"ScheduledAt" {
			patchee.ScheduledAt = patcher.ScheduledAt
			continue
		}
		if f == prefix+"FinishedAt" {
			patchee.FinishedAt = patcher.FinishedAt
			continue
		}
		if !updatedOffer && strings.HasPrefix(f, prefix+"Offer.") {
			updatedOffer = true
			if patcher.Offer == nil {
				patchee.Offer = nil
				continue
			}
			if patchee.Offer == nil {
				patchee.Offer = &ServiceOffer{}
			}
			if o, err := DefaultApplyFieldMaskServiceOffer(ctx, patchee.Offer, patcher.Offer, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Offer.", db); err != nil {
				return nil, err
			} else {
				patchee.Offer = o
			}
			continue
		}
		if f == prefix+"Offer" {
			updatedOffer = true
			patchee.Offer = patcher.Offer
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Evaluations" {
			patchee.Evaluations = patcher.Evaluations
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceSession executes a gorm list call
func DefaultListServiceSession(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceSession, error) {
	in := ServiceSession{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceSessionORM{}, &ServiceSession{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceSessionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceSession{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceSessionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceSessionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceSessionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceSessionNote executes a basic gorm create call
func DefaultCreateServiceSessionNote(ctx context.Context, in *ServiceSessionNote, db *gorm1.DB) (*ServiceSessionNote, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionNoteORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceSessionNote executes a basic gorm read call
func DefaultReadServiceSessionNote(ctx context.Context, in *ServiceSessionNote, db *gorm1.DB) (*ServiceSessionNote, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceSessionNoteORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceSessionNoteORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceSessionNoteORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionNoteORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSessionNote(ctx context.Context, in *ServiceSessionNote, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceSessionNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceSessionNoteORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSessionNoteSet(ctx context.Context, in []*ServiceSessionNote, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []*go_uuid1.UUID{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceSessionNoteORM{})).(ServiceSessionNoteORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceSessionNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceSessionNoteORM{})).(ServiceSessionNoteORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceSessionNoteORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceSessionNote, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceSessionNote, *gorm1.DB) error
}

// DefaultStrictUpdateServiceSessionNote clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceSessionNote(ctx context.Context, in *ServiceSessionNote, db *gorm1.DB) (*ServiceSessionNote, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceSessionNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceSessionNoteORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSession := ServiceSessionORM{}
	if ormObj.Id == nil || *ormObj.Id == go_uuid1.Nil {
		return nil, errors1.EmptyIdError
	}
	filterSession.ServiceSessionNoteId = new(go_uuid1.UUID)
	*filterSession.ServiceSessionNoteId = *ormObj.Id
	if err = db.Where(filterSession).Delete(ServiceSessionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceSessionNoteORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceSessionNote executes a basic gorm update call with patch behavior
func DefaultPatchServiceSessionNote(ctx context.Context, in *ServiceSessionNote, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceSessionNote, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceSessionNote
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceSessionNoteWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceSessionNote(ctx, &ServiceSessionNote{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceSessionNoteWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceSessionNote(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceSessionNoteWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceSessionNote(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceSessionNoteWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceSessionNoteWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceSessionNote, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceSessionNote, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceSessionNote, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceSessionNote, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceSessionNote executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceSessionNote(ctx context.Context, objects []*ServiceSessionNote, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceSessionNote, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceSessionNote, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceSessionNote(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceSessionNote patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceSessionNote(ctx context.Context, patchee *ServiceSessionNote, patcher *ServiceSessionNote, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceSessionNote, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedSession bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedSession && strings.HasPrefix(f, prefix+"Session.") {
			updatedSession = true
			if patcher.Session == nil {
				patchee.Session = nil
				continue
			}
			if patchee.Session == nil {
				patchee.Session = &ServiceSession{}
			}
			if o, err := DefaultApplyFieldMaskServiceSession(ctx, patchee.Session, patcher.Session, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Session.", db); err != nil {
				return nil, err
			} else {
				patchee.Session = o
			}
			continue
		}
		if f == prefix+"Session" {
			updatedSession = true
			patchee.Session = patcher.Session
			continue
		}
		if f == prefix+"Text" {
			patchee.Text = patcher.Text
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceSessionNote executes a gorm list call
func DefaultListServiceSessionNote(ctx context.Context, db *gorm1.DB) ([]*ServiceSessionNote, error) {
	in := ServiceSessionNote{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceSessionNoteORM{}, &ServiceSessionNote{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceSessionNoteORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceSessionNote{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceSessionNoteORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceSessionNoteORM) error
}
type ServicesDefaultServer struct {
	DB *gorm1.DB
}

func (m *ServicesDefaultServer) spanCreate(ctx context.Context, in interface{}, methodName string) (*trace1.Span, error) {
	_, span := trace1.StartSpan(ctx, fmt.Sprint("ServicesDefaultServer.", methodName))
	raw, err := json1.Marshal(in)
	if err != nil {
		return nil, err
	}
	span.Annotate([]trace1.Attribute{trace1.StringAttribute("in", string(raw))}, "in parameter")
	return span, nil
}

// spanError ...
func (m *ServicesDefaultServer) spanError(span *trace1.Span, err error) error {
	span.SetStatus(trace1.Status{
		Code:    trace1.StatusCodeUnknown,
		Message: err.Error(),
	})
	return err
}

// spanResult ...
func (m *ServicesDefaultServer) spanResult(span *trace1.Span, out interface{}) error {
	raw, err := json1.Marshal(out)
	if err != nil {
		return err
	}
	span.Annotate([]trace1.Attribute{trace1.StringAttribute("out", string(raw))}, "out parameter")
	return nil
}

// ListService ...
func (m *ServicesDefaultServer) ListService(ctx context.Context, in *ListServiceRequest) (*ListServiceResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListService")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeListService); ok {
		var err error
		if db, err = custom.BeforeListService(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListService(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterListService); ok {
		var err error
		if err = custom.AfterListService(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceWithBeforeListService called before DefaultListServiceService in the default ListService handler
type ServicesServiceWithBeforeListService interface {
	BeforeListService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterListService called before DefaultListServiceService in the default ListService handler
type ServicesServiceWithAfterListService interface {
	AfterListService(context.Context, *ListServiceResponse, *gorm1.DB) error
}

// CreateService ...
func (m *ServicesDefaultServer) CreateService(ctx context.Context, in *CreateServiceRequest) (*CreateServiceResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateService")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeCreateService); ok {
		var err error
		if db, err = custom.BeforeCreateService(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateService(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateServiceResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterCreateService); ok {
		var err error
		if err = custom.AfterCreateService(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceWithBeforeCreateService called before DefaultCreateServiceService in the default CreateService handler
type ServicesServiceWithBeforeCreateService interface {
	BeforeCreateService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterCreateService called before DefaultCreateServiceService in the default CreateService handler
type ServicesServiceWithAfterCreateService interface {
	AfterCreateService(context.Context, *CreateServiceResponse, *gorm1.DB) error
}

// ReadService ...
func (m *ServicesDefaultServer) ReadService(ctx context.Context, in *ReadServiceRequest) (*ReadServiceResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadService")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeReadService); ok {
		var err error
		if db, err = custom.BeforeReadService(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadServiceResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterReadService); ok {
		var err error
		if err = custom.AfterReadService(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceWithBeforeReadService called before DefaultReadServiceService in the default ReadService handler
type ServicesServiceWithBeforeReadService interface {
	BeforeReadService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterReadService called before DefaultReadServiceService in the default ReadService handler
type ServicesServiceWithAfterReadService interface {
	AfterReadService(context.Context, *ReadServiceResponse, *gorm1.DB) error
}

// UpdateService ...
func (m *ServicesDefaultServer) UpdateService(ctx context.Context, in *UpdateServiceRequest) (*UpdateServiceResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateService")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *Service
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeUpdateService); ok {
		var err error
		if db, err = custom.BeforeUpdateService(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateService(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateServiceResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterUpdateService); ok {
		var err error
		if err = custom.AfterUpdateService(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceWithBeforeUpdateService called before DefaultUpdateServiceService in the default UpdateService handler
type ServicesServiceWithBeforeUpdateService interface {
	BeforeUpdateService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterUpdateService called before DefaultUpdateServiceService in the default UpdateService handler
type ServicesServiceWithAfterUpdateService interface {
	AfterUpdateService(context.Context, *UpdateServiceResponse, *gorm1.DB) error
}

// DeleteService ...
func (m *ServicesDefaultServer) DeleteService(ctx context.Context, in *DeleteServiceRequest) (*DeleteServiceResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteService")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeDeleteService); ok {
		var err error
		if db, err = custom.BeforeDeleteService(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteServiceResponse{}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterDeleteService); ok {
		var err error
		if err = custom.AfterDeleteService(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceWithBeforeDeleteService called before DefaultDeleteServiceService in the default DeleteService handler
type ServicesServiceWithBeforeDeleteService interface {
	BeforeDeleteService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterDeleteService called before DefaultDeleteServiceService in the default DeleteService handler
type ServicesServiceWithAfterDeleteService interface {
	AfterDeleteService(context.Context, *DeleteServiceResponse, *gorm1.DB) error
}

// ListServiceSession ...
func (m *ServicesDefaultServer) ListServiceSession(ctx context.Context, in *ListServiceSessionRequest) (*ListServiceSessionResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListServiceSession")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeListServiceSession); ok {
		var err error
		if db, err = custom.BeforeListServiceSession(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListServiceSession(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceSessionResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterListServiceSession); ok {
		var err error
		if err = custom.AfterListServiceSession(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeListServiceSession called before DefaultListServiceSessionServiceSession in the default ListServiceSession handler
type ServicesServiceSessionWithBeforeListServiceSession interface {
	BeforeListServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterListServiceSession called before DefaultListServiceSessionServiceSession in the default ListServiceSession handler
type ServicesServiceSessionWithAfterListServiceSession interface {
	AfterListServiceSession(context.Context, *ListServiceSessionResponse, *gorm1.DB) error
}

// ListServiceOfferSession ...
func (m *ServicesDefaultServer) ListServiceOfferSession(ctx context.Context, in *ListServiceOfferSessionRequest) (*ListServiceOfferSessionResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListServiceOfferSession")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeListServiceOfferSession); ok {
		var err error
		if db, err = custom.BeforeListServiceOfferSession(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListServiceSession(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceOfferSessionResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterListServiceOfferSession); ok {
		var err error
		if err = custom.AfterListServiceOfferSession(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeListServiceOfferSession called before DefaultListServiceOfferSessionServiceSession in the default ListServiceOfferSession handler
type ServicesServiceSessionWithBeforeListServiceOfferSession interface {
	BeforeListServiceOfferSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterListServiceOfferSession called before DefaultListServiceOfferSessionServiceSession in the default ListServiceOfferSession handler
type ServicesServiceSessionWithAfterListServiceOfferSession interface {
	AfterListServiceOfferSession(context.Context, *ListServiceOfferSessionResponse, *gorm1.DB) error
}

// CreateServiceSession ...
func (m *ServicesDefaultServer) CreateServiceSession(ctx context.Context, in *CreateServiceSessionRequest) (*CreateServiceSessionResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateServiceSession")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeCreateServiceSession); ok {
		var err error
		if db, err = custom.BeforeCreateServiceSession(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateServiceSession(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateServiceSessionResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterCreateServiceSession); ok {
		var err error
		if err = custom.AfterCreateServiceSession(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeCreateServiceSession called before DefaultCreateServiceSessionServiceSession in the default CreateServiceSession handler
type ServicesServiceSessionWithBeforeCreateServiceSession interface {
	BeforeCreateServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterCreateServiceSession called before DefaultCreateServiceSessionServiceSession in the default CreateServiceSession handler
type ServicesServiceSessionWithAfterCreateServiceSession interface {
	AfterCreateServiceSession(context.Context, *CreateServiceSessionResponse, *gorm1.DB) error
}

// ReadServiceSession ...
func (m *ServicesDefaultServer) ReadServiceSession(ctx context.Context, in *ReadServiceSessionRequest) (*ReadServiceSessionResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadServiceSession")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeReadServiceSession); ok {
		var err error
		if db, err = custom.BeforeReadServiceSession(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadServiceSession(ctx, &ServiceSession{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadServiceSessionResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterReadServiceSession); ok {
		var err error
		if err = custom.AfterReadServiceSession(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeReadServiceSession called before DefaultReadServiceSessionServiceSession in the default ReadServiceSession handler
type ServicesServiceSessionWithBeforeReadServiceSession interface {
	BeforeReadServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterReadServiceSession called before DefaultReadServiceSessionServiceSession in the default ReadServiceSession handler
type ServicesServiceSessionWithAfterReadServiceSession interface {
	AfterReadServiceSession(context.Context, *ReadServiceSessionResponse, *gorm1.DB) error
}

// UpdateServiceSession ...
func (m *ServicesDefaultServer) UpdateServiceSession(ctx context.Context, in *UpdateServiceSessionRequest) (*UpdateServiceSessionResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateServiceSession")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *ServiceSession
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeUpdateServiceSession); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceSession(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateServiceSession(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateServiceSessionResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterUpdateServiceSession); ok {
		var err error
		if err = custom.AfterUpdateServiceSession(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeUpdateServiceSession called before DefaultUpdateServiceSessionServiceSession in the default UpdateServiceSession handler
type ServicesServiceSessionWithBeforeUpdateServiceSession interface {
	BeforeUpdateServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterUpdateServiceSession called before DefaultUpdateServiceSessionServiceSession in the default UpdateServiceSession handler
type ServicesServiceSessionWithAfterUpdateServiceSession interface {
	AfterUpdateServiceSession(context.Context, *UpdateServiceSessionResponse, *gorm1.DB) error
}

// DeleteServiceSession ...
func (m *ServicesDefaultServer) DeleteServiceSession(ctx context.Context, in *DeleteServiceSessionRequest) (*DeleteServiceSessionResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteServiceSession")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeDeleteServiceSession); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceSession(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteServiceSession(ctx, &ServiceSession{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteServiceSessionResponse{}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterDeleteServiceSession); ok {
		var err error
		if err = custom.AfterDeleteServiceSession(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeDeleteServiceSession called before DefaultDeleteServiceSessionServiceSession in the default DeleteServiceSession handler
type ServicesServiceSessionWithBeforeDeleteServiceSession interface {
	BeforeDeleteServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterDeleteServiceSession called before DefaultDeleteServiceSessionServiceSession in the default DeleteServiceSession handler
type ServicesServiceSessionWithAfterDeleteServiceSession interface {
	AfterDeleteServiceSession(context.Context, *DeleteServiceSessionResponse, *gorm1.DB) error
}

// ListServiceSessionEvaluation ...
func (m *ServicesDefaultServer) ListServiceSessionEvaluation(ctx context.Context, in *ListServiceSessionEvaluationRequest) (*ListServiceSessionEvaluationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListServiceSessionEvaluation")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithBeforeListServiceSessionEvaluation); ok {
		var err error
		if db, err = custom.BeforeListServiceSessionEvaluation(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListServiceSessionEvaluation(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceSessionEvaluationResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithAfterListServiceSessionEvaluation); ok {
		var err error
		if err = custom.AfterListServiceSessionEvaluation(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionEvaluationWithBeforeListServiceSessionEvaluation called before DefaultListServiceSessionEvaluationServiceSessionEvaluation in the default ListServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithBeforeListServiceSessionEvaluation interface {
	BeforeListServiceSessionEvaluation(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionEvaluationWithAfterListServiceSessionEvaluation called before DefaultListServiceSessionEvaluationServiceSessionEvaluation in the default ListServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithAfterListServiceSessionEvaluation interface {
	AfterListServiceSessionEvaluation(context.Context, *ListServiceSessionEvaluationResponse, *gorm1.DB) error
}

// CreateServiceSessionEvaluation ...
func (m *ServicesDefaultServer) CreateServiceSessionEvaluation(ctx context.Context, in *CreateServiceSessionEvaluationRequest) (*CreateServiceSessionEvaluationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateServiceSessionEvaluation")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithBeforeCreateServiceSessionEvaluation); ok {
		var err error
		if db, err = custom.BeforeCreateServiceSessionEvaluation(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateServiceSessionEvaluation(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateServiceSessionEvaluationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithAfterCreateServiceSessionEvaluation); ok {
		var err error
		if err = custom.AfterCreateServiceSessionEvaluation(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionEvaluationWithBeforeCreateServiceSessionEvaluation called before DefaultCreateServiceSessionEvaluationServiceSessionEvaluation in the default CreateServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithBeforeCreateServiceSessionEvaluation interface {
	BeforeCreateServiceSessionEvaluation(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionEvaluationWithAfterCreateServiceSessionEvaluation called before DefaultCreateServiceSessionEvaluationServiceSessionEvaluation in the default CreateServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithAfterCreateServiceSessionEvaluation interface {
	AfterCreateServiceSessionEvaluation(context.Context, *CreateServiceSessionEvaluationResponse, *gorm1.DB) error
}

// ReadServiceSessionEvaluation ...
func (m *ServicesDefaultServer) ReadServiceSessionEvaluation(ctx context.Context, in *ReadServiceSessionEvaluationRequest) (*ReadServiceSessionEvaluationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadServiceSessionEvaluation")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithBeforeReadServiceSessionEvaluation); ok {
		var err error
		if db, err = custom.BeforeReadServiceSessionEvaluation(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadServiceSessionEvaluation(ctx, &ServiceSessionEvaluation{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadServiceSessionEvaluationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithAfterReadServiceSessionEvaluation); ok {
		var err error
		if err = custom.AfterReadServiceSessionEvaluation(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionEvaluationWithBeforeReadServiceSessionEvaluation called before DefaultReadServiceSessionEvaluationServiceSessionEvaluation in the default ReadServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithBeforeReadServiceSessionEvaluation interface {
	BeforeReadServiceSessionEvaluation(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionEvaluationWithAfterReadServiceSessionEvaluation called before DefaultReadServiceSessionEvaluationServiceSessionEvaluation in the default ReadServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithAfterReadServiceSessionEvaluation interface {
	AfterReadServiceSessionEvaluation(context.Context, *ReadServiceSessionEvaluationResponse, *gorm1.DB) error
}

// UpdateServiceSessionEvaluation ...
func (m *ServicesDefaultServer) UpdateServiceSessionEvaluation(ctx context.Context, in *UpdateServiceSessionEvaluationRequest) (*UpdateServiceSessionEvaluationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateServiceSessionEvaluation")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *ServiceSessionEvaluation
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithBeforeUpdateServiceSessionEvaluation); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceSessionEvaluation(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateServiceSessionEvaluation(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateServiceSessionEvaluationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithAfterUpdateServiceSessionEvaluation); ok {
		var err error
		if err = custom.AfterUpdateServiceSessionEvaluation(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionEvaluationWithBeforeUpdateServiceSessionEvaluation called before DefaultUpdateServiceSessionEvaluationServiceSessionEvaluation in the default UpdateServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithBeforeUpdateServiceSessionEvaluation interface {
	BeforeUpdateServiceSessionEvaluation(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionEvaluationWithAfterUpdateServiceSessionEvaluation called before DefaultUpdateServiceSessionEvaluationServiceSessionEvaluation in the default UpdateServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithAfterUpdateServiceSessionEvaluation interface {
	AfterUpdateServiceSessionEvaluation(context.Context, *UpdateServiceSessionEvaluationResponse, *gorm1.DB) error
}

// DeleteServiceSessionEvaluation ...
func (m *ServicesDefaultServer) DeleteServiceSessionEvaluation(ctx context.Context, in *DeleteServiceSessionEvaluationRequest) (*DeleteServiceSessionEvaluationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteServiceSessionEvaluation")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithBeforeDeleteServiceSessionEvaluation); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceSessionEvaluation(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteServiceSessionEvaluation(ctx, &ServiceSessionEvaluation{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteServiceSessionEvaluationResponse{}
	if custom, ok := interface{}(in).(ServicesServiceSessionEvaluationWithAfterDeleteServiceSessionEvaluation); ok {
		var err error
		if err = custom.AfterDeleteServiceSessionEvaluation(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceSessionEvaluationWithBeforeDeleteServiceSessionEvaluation called before DefaultDeleteServiceSessionEvaluationServiceSessionEvaluation in the default DeleteServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithBeforeDeleteServiceSessionEvaluation interface {
	BeforeDeleteServiceSessionEvaluation(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionEvaluationWithAfterDeleteServiceSessionEvaluation called before DefaultDeleteServiceSessionEvaluationServiceSessionEvaluation in the default DeleteServiceSessionEvaluation handler
type ServicesServiceSessionEvaluationWithAfterDeleteServiceSessionEvaluation interface {
	AfterDeleteServiceSessionEvaluation(context.Context, *DeleteServiceSessionEvaluationResponse, *gorm1.DB) error
}

// ListServiceTag ...
func (m *ServicesDefaultServer) ListServiceTag(ctx context.Context, in *ListServiceTagRequest) (*ListServiceTagResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListServiceTag")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeListServiceTag); ok {
		var err error
		if db, err = custom.BeforeListServiceTag(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListServiceTag(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceTagResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterListServiceTag); ok {
		var err error
		if err = custom.AfterListServiceTag(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceTagWithBeforeListServiceTag called before DefaultListServiceTagServiceTag in the default ListServiceTag handler
type ServicesServiceTagWithBeforeListServiceTag interface {
	BeforeListServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterListServiceTag called before DefaultListServiceTagServiceTag in the default ListServiceTag handler
type ServicesServiceTagWithAfterListServiceTag interface {
	AfterListServiceTag(context.Context, *ListServiceTagResponse, *gorm1.DB) error
}

// CreateServiceTag ...
func (m *ServicesDefaultServer) CreateServiceTag(ctx context.Context, in *CreateServiceTagRequest) (*CreateServiceTagResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateServiceTag")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeCreateServiceTag); ok {
		var err error
		if db, err = custom.BeforeCreateServiceTag(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateServiceTag(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateServiceTagResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterCreateServiceTag); ok {
		var err error
		if err = custom.AfterCreateServiceTag(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceTagWithBeforeCreateServiceTag called before DefaultCreateServiceTagServiceTag in the default CreateServiceTag handler
type ServicesServiceTagWithBeforeCreateServiceTag interface {
	BeforeCreateServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterCreateServiceTag called before DefaultCreateServiceTagServiceTag in the default CreateServiceTag handler
type ServicesServiceTagWithAfterCreateServiceTag interface {
	AfterCreateServiceTag(context.Context, *CreateServiceTagResponse, *gorm1.DB) error
}

// ReadServiceTag ...
func (m *ServicesDefaultServer) ReadServiceTag(ctx context.Context, in *ReadServiceTagRequest) (*ReadServiceTagResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadServiceTag")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeReadServiceTag); ok {
		var err error
		if db, err = custom.BeforeReadServiceTag(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadServiceTag(ctx, &ServiceTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadServiceTagResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterReadServiceTag); ok {
		var err error
		if err = custom.AfterReadServiceTag(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceTagWithBeforeReadServiceTag called before DefaultReadServiceTagServiceTag in the default ReadServiceTag handler
type ServicesServiceTagWithBeforeReadServiceTag interface {
	BeforeReadServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterReadServiceTag called before DefaultReadServiceTagServiceTag in the default ReadServiceTag handler
type ServicesServiceTagWithAfterReadServiceTag interface {
	AfterReadServiceTag(context.Context, *ReadServiceTagResponse, *gorm1.DB) error
}

// UpdateServiceTag ...
func (m *ServicesDefaultServer) UpdateServiceTag(ctx context.Context, in *UpdateServiceTagRequest) (*UpdateServiceTagResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateServiceTag")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *ServiceTag
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeUpdateServiceTag); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceTag(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateServiceTag(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateServiceTagResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterUpdateServiceTag); ok {
		var err error
		if err = custom.AfterUpdateServiceTag(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceTagWithBeforeUpdateServiceTag called before DefaultUpdateServiceTagServiceTag in the default UpdateServiceTag handler
type ServicesServiceTagWithBeforeUpdateServiceTag interface {
	BeforeUpdateServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterUpdateServiceTag called before DefaultUpdateServiceTagServiceTag in the default UpdateServiceTag handler
type ServicesServiceTagWithAfterUpdateServiceTag interface {
	AfterUpdateServiceTag(context.Context, *UpdateServiceTagResponse, *gorm1.DB) error
}

// DeleteServiceTag ...
func (m *ServicesDefaultServer) DeleteServiceTag(ctx context.Context, in *DeleteServiceTagRequest) (*DeleteServiceTagResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteServiceTag")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeDeleteServiceTag); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceTag(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteServiceTag(ctx, &ServiceTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteServiceTagResponse{}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterDeleteServiceTag); ok {
		var err error
		if err = custom.AfterDeleteServiceTag(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceTagWithBeforeDeleteServiceTag called before DefaultDeleteServiceTagServiceTag in the default DeleteServiceTag handler
type ServicesServiceTagWithBeforeDeleteServiceTag interface {
	BeforeDeleteServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterDeleteServiceTag called before DefaultDeleteServiceTagServiceTag in the default DeleteServiceTag handler
type ServicesServiceTagWithAfterDeleteServiceTag interface {
	AfterDeleteServiceTag(context.Context, *DeleteServiceTagResponse, *gorm1.DB) error
}

// ListServiceOffer ...
func (m *ServicesDefaultServer) ListServiceOffer(ctx context.Context, in *ListServiceOfferRequest) (*ListServiceOfferResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListServiceOffer")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeListServiceOffer); ok {
		var err error
		if db, err = custom.BeforeListServiceOffer(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListServiceOffer(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceOfferResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterListServiceOffer); ok {
		var err error
		if err = custom.AfterListServiceOffer(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeListServiceOffer called before DefaultListServiceOfferServiceOffer in the default ListServiceOffer handler
type ServicesServiceOfferWithBeforeListServiceOffer interface {
	BeforeListServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterListServiceOffer called before DefaultListServiceOfferServiceOffer in the default ListServiceOffer handler
type ServicesServiceOfferWithAfterListServiceOffer interface {
	AfterListServiceOffer(context.Context, *ListServiceOfferResponse, *gorm1.DB) error
}

// CreateServiceOffer ...
func (m *ServicesDefaultServer) CreateServiceOffer(ctx context.Context, in *CreateServiceOfferRequest) (*CreateServiceOfferResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateServiceOffer")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeCreateServiceOffer); ok {
		var err error
		if db, err = custom.BeforeCreateServiceOffer(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateServiceOffer(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateServiceOfferResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterCreateServiceOffer); ok {
		var err error
		if err = custom.AfterCreateServiceOffer(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeCreateServiceOffer called before DefaultCreateServiceOfferServiceOffer in the default CreateServiceOffer handler
type ServicesServiceOfferWithBeforeCreateServiceOffer interface {
	BeforeCreateServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterCreateServiceOffer called before DefaultCreateServiceOfferServiceOffer in the default CreateServiceOffer handler
type ServicesServiceOfferWithAfterCreateServiceOffer interface {
	AfterCreateServiceOffer(context.Context, *CreateServiceOfferResponse, *gorm1.DB) error
}

// ReadServiceOffer ...
func (m *ServicesDefaultServer) ReadServiceOffer(ctx context.Context, in *ReadServiceOfferRequest) (*ReadServiceOfferResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadServiceOffer")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeReadServiceOffer); ok {
		var err error
		if db, err = custom.BeforeReadServiceOffer(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadServiceOffer(ctx, &ServiceOffer{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadServiceOfferResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterReadServiceOffer); ok {
		var err error
		if err = custom.AfterReadServiceOffer(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeReadServiceOffer called before DefaultReadServiceOfferServiceOffer in the default ReadServiceOffer handler
type ServicesServiceOfferWithBeforeReadServiceOffer interface {
	BeforeReadServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterReadServiceOffer called before DefaultReadServiceOfferServiceOffer in the default ReadServiceOffer handler
type ServicesServiceOfferWithAfterReadServiceOffer interface {
	AfterReadServiceOffer(context.Context, *ReadServiceOfferResponse, *gorm1.DB) error
}

// UpdateServiceOffer ...
func (m *ServicesDefaultServer) UpdateServiceOffer(ctx context.Context, in *UpdateServiceOfferRequest) (*UpdateServiceOfferResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateServiceOffer")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *ServiceOffer
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeUpdateServiceOffer); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceOffer(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateServiceOffer(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateServiceOfferResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterUpdateServiceOffer); ok {
		var err error
		if err = custom.AfterUpdateServiceOffer(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeUpdateServiceOffer called before DefaultUpdateServiceOfferServiceOffer in the default UpdateServiceOffer handler
type ServicesServiceOfferWithBeforeUpdateServiceOffer interface {
	BeforeUpdateServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterUpdateServiceOffer called before DefaultUpdateServiceOfferServiceOffer in the default UpdateServiceOffer handler
type ServicesServiceOfferWithAfterUpdateServiceOffer interface {
	AfterUpdateServiceOffer(context.Context, *UpdateServiceOfferResponse, *gorm1.DB) error
}

// DeleteServiceOffer ...
func (m *ServicesDefaultServer) DeleteServiceOffer(ctx context.Context, in *DeleteServiceOfferRequest) (*DeleteServiceOfferResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteServiceOffer")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeDeleteServiceOffer); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceOffer(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteServiceOffer(ctx, &ServiceOffer{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteServiceOfferResponse{}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterDeleteServiceOffer); ok {
		var err error
		if err = custom.AfterDeleteServiceOffer(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeDeleteServiceOffer called before DefaultDeleteServiceOfferServiceOffer in the default DeleteServiceOffer handler
type ServicesServiceOfferWithBeforeDeleteServiceOffer interface {
	BeforeDeleteServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterDeleteServiceOffer called before DefaultDeleteServiceOfferServiceOffer in the default DeleteServiceOffer handler
type ServicesServiceOfferWithAfterDeleteServiceOffer interface {
	AfterDeleteServiceOffer(context.Context, *DeleteServiceOfferResponse, *gorm1.DB) error
}

// ListServiceEmployment ...
func (m *ServicesDefaultServer) ListServiceEmployment(ctx context.Context, in *ListServiceEmploymentRequest) (*ListServiceEmploymentResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListServiceEmployment")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithBeforeListServiceEmployment); ok {
		var err error
		if db, err = custom.BeforeListServiceEmployment(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListServiceEmployment(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceEmploymentResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithAfterListServiceEmployment); ok {
		var err error
		if err = custom.AfterListServiceEmployment(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceEmploymentWithBeforeListServiceEmployment called before DefaultListServiceEmploymentServiceEmployment in the default ListServiceEmployment handler
type ServicesServiceEmploymentWithBeforeListServiceEmployment interface {
	BeforeListServiceEmployment(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceEmploymentWithAfterListServiceEmployment called before DefaultListServiceEmploymentServiceEmployment in the default ListServiceEmployment handler
type ServicesServiceEmploymentWithAfterListServiceEmployment interface {
	AfterListServiceEmployment(context.Context, *ListServiceEmploymentResponse, *gorm1.DB) error
}

// CreateServiceEmployment ...
func (m *ServicesDefaultServer) CreateServiceEmployment(ctx context.Context, in *CreateServiceEmploymentRequest) (*CreateServiceEmploymentResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateServiceEmployment")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithBeforeCreateServiceEmployment); ok {
		var err error
		if db, err = custom.BeforeCreateServiceEmployment(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateServiceEmployment(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateServiceEmploymentResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithAfterCreateServiceEmployment); ok {
		var err error
		if err = custom.AfterCreateServiceEmployment(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceEmploymentWithBeforeCreateServiceEmployment called before DefaultCreateServiceEmploymentServiceEmployment in the default CreateServiceEmployment handler
type ServicesServiceEmploymentWithBeforeCreateServiceEmployment interface {
	BeforeCreateServiceEmployment(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceEmploymentWithAfterCreateServiceEmployment called before DefaultCreateServiceEmploymentServiceEmployment in the default CreateServiceEmployment handler
type ServicesServiceEmploymentWithAfterCreateServiceEmployment interface {
	AfterCreateServiceEmployment(context.Context, *CreateServiceEmploymentResponse, *gorm1.DB) error
}

// ReadServiceEmployment ...
func (m *ServicesDefaultServer) ReadServiceEmployment(ctx context.Context, in *ReadServiceEmploymentRequest) (*ReadServiceEmploymentResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadServiceEmployment")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithBeforeReadServiceEmployment); ok {
		var err error
		if db, err = custom.BeforeReadServiceEmployment(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadServiceEmployment(ctx, &ServiceEmployment{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadServiceEmploymentResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithAfterReadServiceEmployment); ok {
		var err error
		if err = custom.AfterReadServiceEmployment(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceEmploymentWithBeforeReadServiceEmployment called before DefaultReadServiceEmploymentServiceEmployment in the default ReadServiceEmployment handler
type ServicesServiceEmploymentWithBeforeReadServiceEmployment interface {
	BeforeReadServiceEmployment(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceEmploymentWithAfterReadServiceEmployment called before DefaultReadServiceEmploymentServiceEmployment in the default ReadServiceEmployment handler
type ServicesServiceEmploymentWithAfterReadServiceEmployment interface {
	AfterReadServiceEmployment(context.Context, *ReadServiceEmploymentResponse, *gorm1.DB) error
}

// UpdateServiceEmployment ...
func (m *ServicesDefaultServer) UpdateServiceEmployment(ctx context.Context, in *UpdateServiceEmploymentRequest) (*UpdateServiceEmploymentResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateServiceEmployment")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *ServiceEmployment
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithBeforeUpdateServiceEmployment); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceEmployment(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateServiceEmployment(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateServiceEmploymentResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithAfterUpdateServiceEmployment); ok {
		var err error
		if err = custom.AfterUpdateServiceEmployment(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceEmploymentWithBeforeUpdateServiceEmployment called before DefaultUpdateServiceEmploymentServiceEmployment in the default UpdateServiceEmployment handler
type ServicesServiceEmploymentWithBeforeUpdateServiceEmployment interface {
	BeforeUpdateServiceEmployment(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceEmploymentWithAfterUpdateServiceEmployment called before DefaultUpdateServiceEmploymentServiceEmployment in the default UpdateServiceEmployment handler
type ServicesServiceEmploymentWithAfterUpdateServiceEmployment interface {
	AfterUpdateServiceEmployment(context.Context, *UpdateServiceEmploymentResponse, *gorm1.DB) error
}

// DeleteServiceEmployment ...
func (m *ServicesDefaultServer) DeleteServiceEmployment(ctx context.Context, in *DeleteServiceEmploymentRequest) (*DeleteServiceEmploymentResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteServiceEmployment")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithBeforeDeleteServiceEmployment); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceEmployment(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteServiceEmployment(ctx, &ServiceEmployment{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteServiceEmploymentResponse{}
	if custom, ok := interface{}(in).(ServicesServiceEmploymentWithAfterDeleteServiceEmployment); ok {
		var err error
		if err = custom.AfterDeleteServiceEmployment(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceEmploymentWithBeforeDeleteServiceEmployment called before DefaultDeleteServiceEmploymentServiceEmployment in the default DeleteServiceEmployment handler
type ServicesServiceEmploymentWithBeforeDeleteServiceEmployment interface {
	BeforeDeleteServiceEmployment(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceEmploymentWithAfterDeleteServiceEmployment called before DefaultDeleteServiceEmploymentServiceEmployment in the default DeleteServiceEmployment handler
type ServicesServiceEmploymentWithAfterDeleteServiceEmployment interface {
	AfterDeleteServiceEmployment(context.Context, *DeleteServiceEmploymentResponse, *gorm1.DB) error
}

// ListServiceDetails ...
func (m *ServicesDefaultServer) ListServiceDetails(ctx context.Context, in *ListServiceDetailsRequest) (*ListServiceDetailsResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListServiceDetails")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithBeforeListServiceDetails); ok {
		var err error
		if db, err = custom.BeforeListServiceDetails(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListServiceDetails(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceDetailsResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithAfterListServiceDetails); ok {
		var err error
		if err = custom.AfterListServiceDetails(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceDetailsWithBeforeListServiceDetails called before DefaultListServiceDetailsServiceDetails in the default ListServiceDetails handler
type ServicesServiceDetailsWithBeforeListServiceDetails interface {
	BeforeListServiceDetails(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceDetailsWithAfterListServiceDetails called before DefaultListServiceDetailsServiceDetails in the default ListServiceDetails handler
type ServicesServiceDetailsWithAfterListServiceDetails interface {
	AfterListServiceDetails(context.Context, *ListServiceDetailsResponse, *gorm1.DB) error
}

// CreateServiceDetails ...
func (m *ServicesDefaultServer) CreateServiceDetails(ctx context.Context, in *CreateServiceDetailsRequest) (*CreateServiceDetailsResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateServiceDetails")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithBeforeCreateServiceDetails); ok {
		var err error
		if db, err = custom.BeforeCreateServiceDetails(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateServiceDetails(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateServiceDetailsResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithAfterCreateServiceDetails); ok {
		var err error
		if err = custom.AfterCreateServiceDetails(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceDetailsWithBeforeCreateServiceDetails called before DefaultCreateServiceDetailsServiceDetails in the default CreateServiceDetails handler
type ServicesServiceDetailsWithBeforeCreateServiceDetails interface {
	BeforeCreateServiceDetails(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceDetailsWithAfterCreateServiceDetails called before DefaultCreateServiceDetailsServiceDetails in the default CreateServiceDetails handler
type ServicesServiceDetailsWithAfterCreateServiceDetails interface {
	AfterCreateServiceDetails(context.Context, *CreateServiceDetailsResponse, *gorm1.DB) error
}

// ReadServiceDetails ...
func (m *ServicesDefaultServer) ReadServiceDetails(ctx context.Context, in *ReadServiceDetailsRequest) (*ReadServiceDetailsResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadServiceDetails")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithBeforeReadServiceDetails); ok {
		var err error
		if db, err = custom.BeforeReadServiceDetails(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadServiceDetails(ctx, &ServiceDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadServiceDetailsResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithAfterReadServiceDetails); ok {
		var err error
		if err = custom.AfterReadServiceDetails(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceDetailsWithBeforeReadServiceDetails called before DefaultReadServiceDetailsServiceDetails in the default ReadServiceDetails handler
type ServicesServiceDetailsWithBeforeReadServiceDetails interface {
	BeforeReadServiceDetails(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceDetailsWithAfterReadServiceDetails called before DefaultReadServiceDetailsServiceDetails in the default ReadServiceDetails handler
type ServicesServiceDetailsWithAfterReadServiceDetails interface {
	AfterReadServiceDetails(context.Context, *ReadServiceDetailsResponse, *gorm1.DB) error
}

// UpdateServiceDetails ...
func (m *ServicesDefaultServer) UpdateServiceDetails(ctx context.Context, in *UpdateServiceDetailsRequest) (*UpdateServiceDetailsResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateServiceDetails")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *ServiceDetails
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithBeforeUpdateServiceDetails); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceDetails(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateServiceDetails(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateServiceDetailsResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithAfterUpdateServiceDetails); ok {
		var err error
		if err = custom.AfterUpdateServiceDetails(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceDetailsWithBeforeUpdateServiceDetails called before DefaultUpdateServiceDetailsServiceDetails in the default UpdateServiceDetails handler
type ServicesServiceDetailsWithBeforeUpdateServiceDetails interface {
	BeforeUpdateServiceDetails(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceDetailsWithAfterUpdateServiceDetails called before DefaultUpdateServiceDetailsServiceDetails in the default UpdateServiceDetails handler
type ServicesServiceDetailsWithAfterUpdateServiceDetails interface {
	AfterUpdateServiceDetails(context.Context, *UpdateServiceDetailsResponse, *gorm1.DB) error
}

// DeleteServiceDetails ...
func (m *ServicesDefaultServer) DeleteServiceDetails(ctx context.Context, in *DeleteServiceDetailsRequest) (*DeleteServiceDetailsResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteServiceDetails")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithBeforeDeleteServiceDetails); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceDetails(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteServiceDetails(ctx, &ServiceDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteServiceDetailsResponse{}
	if custom, ok := interface{}(in).(ServicesServiceDetailsWithAfterDeleteServiceDetails); ok {
		var err error
		if err = custom.AfterDeleteServiceDetails(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceDetailsWithBeforeDeleteServiceDetails called before DefaultDeleteServiceDetailsServiceDetails in the default DeleteServiceDetails handler
type ServicesServiceDetailsWithBeforeDeleteServiceDetails interface {
	BeforeDeleteServiceDetails(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceDetailsWithAfterDeleteServiceDetails called before DefaultDeleteServiceDetailsServiceDetails in the default DeleteServiceDetails handler
type ServicesServiceDetailsWithAfterDeleteServiceDetails interface {
	AfterDeleteServiceDetails(context.Context, *DeleteServiceDetailsResponse, *gorm1.DB) error
}

// ListServiceApplication ...
func (m *ServicesDefaultServer) ListServiceApplication(ctx context.Context, in *ListServiceApplicationRequest) (*ListServiceApplicationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListServiceApplication")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeListServiceApplication); ok {
		var err error
		if db, err = custom.BeforeListServiceApplication(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListServiceApplication(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceApplicationResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterListServiceApplication); ok {
		var err error
		if err = custom.AfterListServiceApplication(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeListServiceApplication called before DefaultListServiceApplicationServiceApplication in the default ListServiceApplication handler
type ServicesServiceApplicationWithBeforeListServiceApplication interface {
	BeforeListServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterListServiceApplication called before DefaultListServiceApplicationServiceApplication in the default ListServiceApplication handler
type ServicesServiceApplicationWithAfterListServiceApplication interface {
	AfterListServiceApplication(context.Context, *ListServiceApplicationResponse, *gorm1.DB) error
}

// CreateServiceApplication ...
func (m *ServicesDefaultServer) CreateServiceApplication(ctx context.Context, in *CreateServiceApplicationRequest) (*CreateServiceApplicationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateServiceApplication")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeCreateServiceApplication); ok {
		var err error
		if db, err = custom.BeforeCreateServiceApplication(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateServiceApplication(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateServiceApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterCreateServiceApplication); ok {
		var err error
		if err = custom.AfterCreateServiceApplication(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeCreateServiceApplication called before DefaultCreateServiceApplicationServiceApplication in the default CreateServiceApplication handler
type ServicesServiceApplicationWithBeforeCreateServiceApplication interface {
	BeforeCreateServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterCreateServiceApplication called before DefaultCreateServiceApplicationServiceApplication in the default CreateServiceApplication handler
type ServicesServiceApplicationWithAfterCreateServiceApplication interface {
	AfterCreateServiceApplication(context.Context, *CreateServiceApplicationResponse, *gorm1.DB) error
}

// ReadServiceApplication ...
func (m *ServicesDefaultServer) ReadServiceApplication(ctx context.Context, in *ReadServiceApplicationRequest) (*ReadServiceApplicationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadServiceApplication")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeReadServiceApplication); ok {
		var err error
		if db, err = custom.BeforeReadServiceApplication(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadServiceApplication(ctx, &ServiceApplication{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadServiceApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterReadServiceApplication); ok {
		var err error
		if err = custom.AfterReadServiceApplication(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeReadServiceApplication called before DefaultReadServiceApplicationServiceApplication in the default ReadServiceApplication handler
type ServicesServiceApplicationWithBeforeReadServiceApplication interface {
	BeforeReadServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterReadServiceApplication called before DefaultReadServiceApplicationServiceApplication in the default ReadServiceApplication handler
type ServicesServiceApplicationWithAfterReadServiceApplication interface {
	AfterReadServiceApplication(context.Context, *ReadServiceApplicationResponse, *gorm1.DB) error
}

// UpdateServiceApplication ...
func (m *ServicesDefaultServer) UpdateServiceApplication(ctx context.Context, in *UpdateServiceApplicationRequest) (*UpdateServiceApplicationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateServiceApplication")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *ServiceApplication
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeUpdateServiceApplication); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceApplication(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateServiceApplication(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateServiceApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterUpdateServiceApplication); ok {
		var err error
		if err = custom.AfterUpdateServiceApplication(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeUpdateServiceApplication called before DefaultUpdateServiceApplicationServiceApplication in the default UpdateServiceApplication handler
type ServicesServiceApplicationWithBeforeUpdateServiceApplication interface {
	BeforeUpdateServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterUpdateServiceApplication called before DefaultUpdateServiceApplicationServiceApplication in the default UpdateServiceApplication handler
type ServicesServiceApplicationWithAfterUpdateServiceApplication interface {
	AfterUpdateServiceApplication(context.Context, *UpdateServiceApplicationResponse, *gorm1.DB) error
}

// DeleteServiceApplication ...
func (m *ServicesDefaultServer) DeleteServiceApplication(ctx context.Context, in *DeleteServiceApplicationRequest) (*DeleteServiceApplicationResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteServiceApplication")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeDeleteServiceApplication); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceApplication(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteServiceApplication(ctx, &ServiceApplication{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteServiceApplicationResponse{}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterDeleteServiceApplication); ok {
		var err error
		if err = custom.AfterDeleteServiceApplication(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeDeleteServiceApplication called before DefaultDeleteServiceApplicationServiceApplication in the default DeleteServiceApplication handler
type ServicesServiceApplicationWithBeforeDeleteServiceApplication interface {
	BeforeDeleteServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterDeleteServiceApplication called before DefaultDeleteServiceApplicationServiceApplication in the default DeleteServiceApplication handler
type ServicesServiceApplicationWithAfterDeleteServiceApplication interface {
	AfterDeleteServiceApplication(context.Context, *DeleteServiceApplicationResponse, *gorm1.DB) error
}

// ListServiceProvider ...
func (m *ServicesDefaultServer) ListServiceProvider(ctx context.Context, in *ListServiceProviderRequest) (*ListServiceProviderResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ListServiceProvider")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeListServiceProvider); ok {
		var err error
		if db, err = custom.BeforeListServiceProvider(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultListServiceProvider(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ListServiceProviderResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterListServiceProvider); ok {
		var err error
		if err = custom.AfterListServiceProvider(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeListServiceProvider called before DefaultListServiceProviderServiceProvider in the default ListServiceProvider handler
type ServicesServiceProviderWithBeforeListServiceProvider interface {
	BeforeListServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterListServiceProvider called before DefaultListServiceProviderServiceProvider in the default ListServiceProvider handler
type ServicesServiceProviderWithAfterListServiceProvider interface {
	AfterListServiceProvider(context.Context, *ListServiceProviderResponse, *gorm1.DB) error
}

// CreateServiceProvider ...
func (m *ServicesDefaultServer) CreateServiceProvider(ctx context.Context, in *CreateServiceProviderRequest) (*CreateServiceProviderResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "CreateServiceProvider")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeCreateServiceProvider); ok {
		var err error
		if db, err = custom.BeforeCreateServiceProvider(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultCreateServiceProvider(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &CreateServiceProviderResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterCreateServiceProvider); ok {
		var err error
		if err = custom.AfterCreateServiceProvider(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeCreateServiceProvider called before DefaultCreateServiceProviderServiceProvider in the default CreateServiceProvider handler
type ServicesServiceProviderWithBeforeCreateServiceProvider interface {
	BeforeCreateServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterCreateServiceProvider called before DefaultCreateServiceProviderServiceProvider in the default CreateServiceProvider handler
type ServicesServiceProviderWithAfterCreateServiceProvider interface {
	AfterCreateServiceProvider(context.Context, *CreateServiceProviderResponse, *gorm1.DB) error
}

// ReadServiceProvider ...
func (m *ServicesDefaultServer) ReadServiceProvider(ctx context.Context, in *ReadServiceProviderRequest) (*ReadServiceProviderResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "ReadServiceProvider")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeReadServiceProvider); ok {
		var err error
		if db, err = custom.BeforeReadServiceProvider(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err := DefaultReadServiceProvider(ctx, &ServiceProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &ReadServiceProviderResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterReadServiceProvider); ok {
		var err error
		if err = custom.AfterReadServiceProvider(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeReadServiceProvider called before DefaultReadServiceProviderServiceProvider in the default ReadServiceProvider handler
type ServicesServiceProviderWithBeforeReadServiceProvider interface {
	BeforeReadServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterReadServiceProvider called before DefaultReadServiceProviderServiceProvider in the default ReadServiceProvider handler
type ServicesServiceProviderWithAfterReadServiceProvider interface {
	AfterReadServiceProvider(context.Context, *ReadServiceProviderResponse, *gorm1.DB) error
}

// UpdateServiceProvider ...
func (m *ServicesDefaultServer) UpdateServiceProvider(ctx context.Context, in *UpdateServiceProviderRequest) (*UpdateServiceProviderResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "UpdateServiceProvider")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	var err error
	var res *ServiceProvider
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeUpdateServiceProvider); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceProvider(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	res, err = DefaultStrictUpdateServiceProvider(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &UpdateServiceProviderResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterUpdateServiceProvider); ok {
		var err error
		if err = custom.AfterUpdateServiceProvider(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeUpdateServiceProvider called before DefaultUpdateServiceProviderServiceProvider in the default UpdateServiceProvider handler
type ServicesServiceProviderWithBeforeUpdateServiceProvider interface {
	BeforeUpdateServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterUpdateServiceProvider called before DefaultUpdateServiceProviderServiceProvider in the default UpdateServiceProvider handler
type ServicesServiceProviderWithAfterUpdateServiceProvider interface {
	AfterUpdateServiceProvider(context.Context, *UpdateServiceProviderResponse, *gorm1.DB) error
}

// DeleteServiceProvider ...
func (m *ServicesDefaultServer) DeleteServiceProvider(ctx context.Context, in *DeleteServiceProviderRequest) (*DeleteServiceProviderResponse, error) {
	span, errSpanCreate := m.spanCreate(ctx, in, "DeleteServiceProvider")
	if errSpanCreate != nil {
		return nil, errSpanCreate
	}
	defer span.End()
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeDeleteServiceProvider); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceProvider(ctx, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	err := DefaultDeleteServiceProvider(ctx, &ServiceProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, m.spanError(span, err)
	}
	out := &DeleteServiceProviderResponse{}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterDeleteServiceProvider); ok {
		var err error
		if err = custom.AfterDeleteServiceProvider(ctx, out, db); err != nil {
			return nil, m.spanError(span, err)
		}
	}
	errSpanResult := m.spanResult(span, out)
	if errSpanResult != nil {
		return nil, m.spanError(span, errSpanResult)
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeDeleteServiceProvider called before DefaultDeleteServiceProviderServiceProvider in the default DeleteServiceProvider handler
type ServicesServiceProviderWithBeforeDeleteServiceProvider interface {
	BeforeDeleteServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterDeleteServiceProvider called before DefaultDeleteServiceProviderServiceProvider in the default DeleteServiceProvider handler
type ServicesServiceProviderWithAfterDeleteServiceProvider interface {
	AfterDeleteServiceProvider(context.Context, *DeleteServiceProviderResponse, *gorm1.DB) error
}

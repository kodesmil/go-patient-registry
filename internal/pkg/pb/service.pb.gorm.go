// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/kodesmil/ks-model/service.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

package pb

import context "context"
import fmt "fmt"
import strings "strings"
import time "time"

import auth1 "github.com/kodesmil/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import ptypes1 "github.com/golang/protobuf/ptypes"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"

import math "math"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/envoyproxy/protoc-gen-validate/validate"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type ServiceTagORM struct {
	Id   int64  `gorm:"type:serial;primary_key"`
	Key  string `gorm:"unique"`
	Name string
}

// TableName overrides the default tablename generated by GORM
func (ServiceTagORM) TableName() string {
	return "service_tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceTag) ToORM(ctx context.Context) (ServiceTagORM, error) {
	to := ServiceTagORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceTagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ServiceTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	if posthook, ok := interface{}(m).(ServiceTagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceTagORM) ToPB(ctx context.Context) (ServiceTag, error) {
	to := ServiceTag{}
	var err error
	if prehook, ok := interface{}(m).(ServiceTagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	if posthook, ok := interface{}(m).(ServiceTagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceTag the arg will be the target, the caller the one being converted from

// ServiceTagBeforeToORM called before default ToORM code
type ServiceTagWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceTagORM) error
}

// ServiceTagAfterToORM called after default ToORM code
type ServiceTagWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceTagORM) error
}

// ServiceTagBeforeToPB called before default ToPB code
type ServiceTagWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceTag) error
}

// ServiceTagAfterToPB called after default ToPB code
type ServiceTagWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceTag) error
}

type ServiceORM struct {
	CreatedAt      *time.Time
	Id             int64 `gorm:"type:serial;primary_key"`
	Name           string
	ServiceOfferId *int64
	Tags           []*ServiceTagORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:service_service_tags;jointable_foreignkey:service_id;association_jointable_foreignkey:service_tag_id"`
	Type           int32
	UpdatedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceORM) TableName() string {
	return "services"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Service) ToORM(ctx context.Context) (ServiceORM, error) {
	to := ServiceORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Service{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	to.Type = int32(m.Type)
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceORM) ToPB(ctx context.Context) (Service, error) {
	to := Service{}
	var err error
	if prehook, ok := interface{}(m).(ServiceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Service{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Type = Service_Type(m.Type)
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Service the arg will be the target, the caller the one being converted from

// ServiceBeforeToORM called before default ToORM code
type ServiceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceORM) error
}

// ServiceAfterToORM called after default ToORM code
type ServiceWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceORM) error
}

// ServiceBeforeToPB called before default ToPB code
type ServiceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Service) error
}

// ServiceAfterToPB called after default ToPB code
type ServiceWithAfterToPB interface {
	AfterToPB(context.Context, *Service) error
}

type ServiceOfferORM struct {
	CreatedAt         *time.Time
	Currency          string
	Description       string
	Id                int64 `gorm:"type:serial;primary_key"`
	Price             float32
	Provider          *ServiceProviderORM `gorm:"foreignkey:ServiceOfferId;association_foreignkey:Id"`
	Service           *ServiceORM         `gorm:"foreignkey:ServiceOfferId;association_foreignkey:Id"`
	ServiceProviderId *int64
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceOfferORM) TableName() string {
	return "service_offers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceOffer) ToORM(ctx context.Context) (ServiceOfferORM, error) {
	to := ServiceOfferORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceOfferWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ServiceOffer{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Price = m.Price
	to.Currency = m.Currency
	if m.Service != nil {
		tempService, err := m.Service.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	to.Description = m.Description
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	if posthook, ok := interface{}(m).(ServiceOfferWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceOfferORM) ToPB(ctx context.Context) (ServiceOffer, error) {
	to := ServiceOffer{}
	var err error
	if prehook, ok := interface{}(m).(ServiceOfferWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceOffer{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Price = m.Price
	to.Currency = m.Currency
	if m.Service != nil {
		tempService, err := m.Service.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	to.Description = m.Description
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	if posthook, ok := interface{}(m).(ServiceOfferWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceOffer the arg will be the target, the caller the one being converted from

// ServiceOfferBeforeToORM called before default ToORM code
type ServiceOfferWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceOfferORM) error
}

// ServiceOfferAfterToORM called after default ToORM code
type ServiceOfferWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceOfferORM) error
}

// ServiceOfferBeforeToPB called before default ToPB code
type ServiceOfferWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceOffer) error
}

// ServiceOfferAfterToPB called after default ToPB code
type ServiceOfferWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceOffer) error
}

type ServiceInPersonORM struct {
	AccountID         string
	CreatedAt         *time.Time
	FirstName         string
	Id                string `gorm:"type:uuid;primary_key"`
	LastName          string
	ServiceProviderId *int64
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceInPersonORM) TableName() string {
	return "service_in_people"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceInPerson) ToORM(ctx context.Context) (ServiceInPersonORM, error) {
	to := ServiceInPersonORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceInPersonWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceInPerson{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceInPersonWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceInPersonORM) ToPB(ctx context.Context) (ServiceInPerson, error) {
	to := ServiceInPerson{}
	var err error
	if prehook, ok := interface{}(m).(ServiceInPersonWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceInPerson{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	if posthook, ok := interface{}(m).(ServiceInPersonWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceInPerson the arg will be the target, the caller the one being converted from

// ServiceInPersonBeforeToORM called before default ToORM code
type ServiceInPersonWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceInPersonORM) error
}

// ServiceInPersonAfterToORM called after default ToORM code
type ServiceInPersonWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceInPersonORM) error
}

// ServiceInPersonBeforeToPB called before default ToPB code
type ServiceInPersonWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceInPerson) error
}

// ServiceInPersonAfterToPB called after default ToPB code
type ServiceInPersonWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceInPerson) error
}

type ServiceApplicationORM struct {
	AccountID  string
	AppliedAt  *time.Time
	ApprovedAt *time.Time
	ApprovedBy *ProfileORM `gorm:"foreignkey:ServiceApplicationId;association_foreignkey:Id"`
	CreatedAt  *time.Time
	Files      []*ServiceApplicationFileORM `gorm:"foreignkey:ServiceApplicationId;association_foreignkey:Id"`
	Id         string                       `gorm:"type:uuid;primary_key"`
	Provider   *ServiceProviderORM          `gorm:"foreignkey:ServiceApplicationId;association_foreignkey:Id"`
	UpdatedAt  *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceApplicationORM) TableName() string {
	return "service_applications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceApplication) ToORM(ctx context.Context) (ServiceApplicationORM, error) {
	to := ServiceApplicationORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceApplication{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	for _, v := range m.Files {
		if v != nil {
			if tempFiles, cErr := v.ToORM(ctx); cErr == nil {
				to.Files = append(to.Files, &tempFiles)
			} else {
				return to, cErr
			}
		} else {
			to.Files = append(to.Files, nil)
		}
	}
	if m.AppliedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.AppliedAt); err != nil {
			return to, err
		}
		to.AppliedAt = &t
	}
	if m.ApprovedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.ApprovedAt); err != nil {
			return to, err
		}
		to.ApprovedAt = &t
	}
	if m.ApprovedBy != nil {
		tempApprovedBy, err := m.ApprovedBy.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ApprovedBy = &tempApprovedBy
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceApplicationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceApplicationORM) ToPB(ctx context.Context) (ServiceApplication, error) {
	to := ServiceApplication{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceApplication{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	for _, v := range m.Files {
		if v != nil {
			if tempFiles, cErr := v.ToPB(ctx); cErr == nil {
				to.Files = append(to.Files, &tempFiles)
			} else {
				return to, cErr
			}
		} else {
			to.Files = append(to.Files, nil)
		}
	}
	if m.AppliedAt != nil {
		if to.AppliedAt, err = ptypes1.TimestampProto(*m.AppliedAt); err != nil {
			return to, err
		}
	}
	if m.ApprovedAt != nil {
		if to.ApprovedAt, err = ptypes1.TimestampProto(*m.ApprovedAt); err != nil {
			return to, err
		}
	}
	if m.ApprovedBy != nil {
		tempApprovedBy, err := m.ApprovedBy.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ApprovedBy = &tempApprovedBy
	}
	if posthook, ok := interface{}(m).(ServiceApplicationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceApplication the arg will be the target, the caller the one being converted from

// ServiceApplicationBeforeToORM called before default ToORM code
type ServiceApplicationWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceApplicationORM) error
}

// ServiceApplicationAfterToORM called after default ToORM code
type ServiceApplicationWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceApplicationORM) error
}

// ServiceApplicationBeforeToPB called before default ToPB code
type ServiceApplicationWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceApplication) error
}

// ServiceApplicationAfterToPB called after default ToPB code
type ServiceApplicationWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceApplication) error
}

type ServiceApplicationFileORM struct {
	AccountID            string
	CreatedAt            *time.Time
	Id                   string `gorm:"type:uuid;primary_key"`
	ServiceApplicationId *string
	UpdatedAt            *time.Time
	Url                  string
}

// TableName overrides the default tablename generated by GORM
func (ServiceApplicationFileORM) TableName() string {
	return "service_application_files"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceApplicationFile) ToORM(ctx context.Context) (ServiceApplicationFileORM, error) {
	to := ServiceApplicationFileORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationFileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceApplicationFile{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Url = m.Url
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceApplicationFileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceApplicationFileORM) ToPB(ctx context.Context) (ServiceApplicationFile, error) {
	to := ServiceApplicationFile{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationFileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceApplicationFile{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Url = m.Url
	if posthook, ok := interface{}(m).(ServiceApplicationFileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceApplicationFile the arg will be the target, the caller the one being converted from

// ServiceApplicationFileBeforeToORM called before default ToORM code
type ServiceApplicationFileWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceApplicationFileORM) error
}

// ServiceApplicationFileAfterToORM called after default ToORM code
type ServiceApplicationFileWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceApplicationFileORM) error
}

// ServiceApplicationFileBeforeToPB called before default ToPB code
type ServiceApplicationFileWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceApplicationFile) error
}

// ServiceApplicationFileAfterToPB called after default ToPB code
type ServiceApplicationFileWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceApplicationFile) error
}

type ServiceProviderORM struct {
	AccountID            string
	CreatedAt            *time.Time
	Id                   int64              `gorm:"type:serial;primary_key"`
	Offers               []*ServiceOfferORM `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	ServiceApplicationId *string
	ServiceInPerson      *ServiceInPersonORM `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	ServiceOfferId       *int64
	UpdatedAt            *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceProviderORM) TableName() string {
	return "service_providers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceProvider) ToORM(ctx context.Context) (ServiceProviderORM, error) {
	to := ServiceProviderORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceProviderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ServiceProvider{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	for _, v := range m.Offers {
		if v != nil {
			if tempOffers, cErr := v.ToORM(ctx); cErr == nil {
				to.Offers = append(to.Offers, &tempOffers)
			} else {
				return to, cErr
			}
		} else {
			to.Offers = append(to.Offers, nil)
		}
	}
	if m.ServiceInPerson != nil {
		tempServiceInPerson, err := m.ServiceInPerson.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ServiceInPerson = &tempServiceInPerson
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceProviderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceProviderORM) ToPB(ctx context.Context) (ServiceProvider, error) {
	to := ServiceProvider{}
	var err error
	if prehook, ok := interface{}(m).(ServiceProviderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceProvider{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	for _, v := range m.Offers {
		if v != nil {
			if tempOffers, cErr := v.ToPB(ctx); cErr == nil {
				to.Offers = append(to.Offers, &tempOffers)
			} else {
				return to, cErr
			}
		} else {
			to.Offers = append(to.Offers, nil)
		}
	}
	if m.ServiceInPerson != nil {
		tempServiceInPerson, err := m.ServiceInPerson.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ServiceInPerson = &tempServiceInPerson
	}
	if posthook, ok := interface{}(m).(ServiceProviderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceProvider the arg will be the target, the caller the one being converted from

// ServiceProviderBeforeToORM called before default ToORM code
type ServiceProviderWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceProviderORM) error
}

// ServiceProviderAfterToORM called after default ToORM code
type ServiceProviderWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceProviderORM) error
}

// ServiceProviderBeforeToPB called before default ToPB code
type ServiceProviderWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceProvider) error
}

// ServiceProviderAfterToPB called after default ToPB code
type ServiceProviderWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceProvider) error
}

type ServiceSessionORM struct {
	Client         *ProfileORM `gorm:"foreignkey:ServiceSessionId;association_foreignkey:Id"`
	CreatedAt      *time.Time
	FinishedAt     *time.Time
	Id             string           `gorm:"type:uuid;primary_key"`
	Offer          *ServiceOfferORM `gorm:"foreignkey:ServiceOfferId;association_foreignkey:Id"`
	ScheduledAt    *time.Time
	ServiceOfferId *int64
	UpdatedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceSessionORM) TableName() string {
	return "service_sessions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceSession) ToORM(ctx context.Context) (ServiceSessionORM, error) {
	to := ServiceSessionORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceSession{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.ScheduledAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.ScheduledAt); err != nil {
			return to, err
		}
		to.ScheduledAt = &t
	}
	if m.FinishedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.FinishedAt); err != nil {
			return to, err
		}
		to.FinishedAt = &t
	}
	if m.Client != nil {
		tempClient, err := m.Client.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Client = &tempClient
	}
	if m.Offer != nil {
		tempOffer, err := m.Offer.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Offer = &tempOffer
	}
	if posthook, ok := interface{}(m).(ServiceSessionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceSessionORM) ToPB(ctx context.Context) (ServiceSession, error) {
	to := ServiceSession{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceSession{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.ScheduledAt != nil {
		if to.ScheduledAt, err = ptypes1.TimestampProto(*m.ScheduledAt); err != nil {
			return to, err
		}
	}
	if m.FinishedAt != nil {
		if to.FinishedAt, err = ptypes1.TimestampProto(*m.FinishedAt); err != nil {
			return to, err
		}
	}
	if m.Client != nil {
		tempClient, err := m.Client.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Client = &tempClient
	}
	if m.Offer != nil {
		tempOffer, err := m.Offer.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Offer = &tempOffer
	}
	if posthook, ok := interface{}(m).(ServiceSessionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceSession the arg will be the target, the caller the one being converted from

// ServiceSessionBeforeToORM called before default ToORM code
type ServiceSessionWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceSessionORM) error
}

// ServiceSessionAfterToORM called after default ToORM code
type ServiceSessionWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceSessionORM) error
}

// ServiceSessionBeforeToPB called before default ToPB code
type ServiceSessionWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceSession) error
}

// ServiceSessionAfterToPB called after default ToPB code
type ServiceSessionWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceSession) error
}

// DefaultCreateServiceTag executes a basic gorm create call
func DefaultCreateServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceTagORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceTag executes a basic gorm read call
func DefaultReadServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceTagORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceTagORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceTagORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceTagORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceTagORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceTagSet(ctx context.Context, in []*ServiceTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceTagORM{})).(ServiceTagORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceTagORM{})).(ServiceTagORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceTagORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceTag, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceTag, *gorm1.DB) error
}

// DefaultStrictUpdateServiceTag clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceTagORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceTagORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceTag executes a basic gorm update call with patch behavior
func DefaultPatchServiceTag(ctx context.Context, in *ServiceTag, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceTag
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceTagWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceTag(ctx, &ServiceTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceTagWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceTag(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceTagWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceTag(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceTagWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceTagWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceTag executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceTag(ctx context.Context, objects []*ServiceTag, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceTag, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceTag, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceTag(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceTag patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceTag(ctx context.Context, patchee *ServiceTag, patcher *ServiceTag, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceTag, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceTag executes a gorm list call
func DefaultListServiceTag(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceTag, error) {
	in := ServiceTag{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceTagORM{}, &ServiceTag{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceTagORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceTag{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceTagORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceTagORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceTagORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateService executes a basic gorm create call
func DefaultCreateService(ctx context.Context, in *Service, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadService executes a basic gorm read call
func DefaultReadService(ctx context.Context, in *Service, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteService(ctx context.Context, in *Service, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSet(ctx context.Context, in []*Service, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceORM{})).(ServiceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceORM{})).(ServiceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Service, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Service, *gorm1.DB) error
}

// DefaultStrictUpdateService clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateService(ctx context.Context, in *Service, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateService")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchService executes a basic gorm update call with patch behavior
func DefaultPatchService(ctx context.Context, in *Service, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Service
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskService(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateService(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetService executes a bulk gorm update call with patch behavior
func DefaultPatchSetService(ctx context.Context, objects []*Service, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Service, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Service, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchService(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskService patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskService(ctx context.Context, patchee *Service, patcher *Service, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Service, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListService executes a gorm list call
func DefaultListService(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Service, error) {
	in := Service{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceORM{}, &Service{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Service{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceOffer executes a basic gorm create call
func DefaultCreateServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceOfferORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceOffer executes a basic gorm read call
func DefaultReadServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceOfferORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceOfferORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceOfferORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceOfferORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceOfferORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceOfferORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceOfferSet(ctx context.Context, in []*ServiceOffer, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceOfferORM{})).(ServiceOfferORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceOfferORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceOfferORM{})).(ServiceOfferORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceOfferORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceOffer, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceOffer, *gorm1.DB) error
}

// DefaultStrictUpdateServiceOffer clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceOffer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceOfferORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterProvider := ServiceProviderORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterProvider.ServiceOfferId = new(int64)
	*filterProvider.ServiceOfferId = ormObj.Id
	if err = db.Where(filterProvider).Delete(ServiceProviderORM{}).Error; err != nil {
		return nil, err
	}
	filterService := ServiceORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterService.ServiceOfferId = new(int64)
	*filterService.ServiceOfferId = ormObj.Id
	if err = db.Where(filterService).Delete(ServiceORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceOfferORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceOffer executes a basic gorm update call with patch behavior
func DefaultPatchServiceOffer(ctx context.Context, in *ServiceOffer, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceOffer
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceOfferWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceOffer(ctx, &ServiceOffer{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceOfferWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceOffer(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceOfferWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceOffer(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceOfferWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceOfferWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceOffer executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceOffer(ctx context.Context, objects []*ServiceOffer, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceOffer, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceOffer, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceOffer(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceOffer patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceOffer(ctx context.Context, patchee *ServiceOffer, patcher *ServiceOffer, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceOffer, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedService bool
	var updatedProvider bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedService && strings.HasPrefix(f, prefix+"Service.") {
			updatedService = true
			if patcher.Service == nil {
				patchee.Service = nil
				continue
			}
			if patchee.Service == nil {
				patchee.Service = &Service{}
			}
			if o, err := DefaultApplyFieldMaskService(ctx, patchee.Service, patcher.Service, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Service.", db); err != nil {
				return nil, err
			} else {
				patchee.Service = o
			}
			continue
		}
		if f == prefix+"Service" {
			updatedService = true
			patchee.Service = patcher.Service
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedProvider && strings.HasPrefix(f, prefix+"Provider.") {
			updatedProvider = true
			if patcher.Provider == nil {
				patchee.Provider = nil
				continue
			}
			if patchee.Provider == nil {
				patchee.Provider = &ServiceProvider{}
			}
			if o, err := DefaultApplyFieldMaskServiceProvider(ctx, patchee.Provider, patcher.Provider, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Provider.", db); err != nil {
				return nil, err
			} else {
				patchee.Provider = o
			}
			continue
		}
		if f == prefix+"Provider" {
			updatedProvider = true
			patchee.Provider = patcher.Provider
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceOffer executes a gorm list call
func DefaultListServiceOffer(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceOffer, error) {
	in := ServiceOffer{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceOfferORM{}, &ServiceOffer{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceOfferORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceOffer{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceOfferORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceOfferORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceOfferORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceInPerson executes a basic gorm create call
func DefaultCreateServiceInPerson(ctx context.Context, in *ServiceInPerson, db *gorm1.DB) (*ServiceInPerson, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceInPersonORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceInPerson executes a basic gorm read call
func DefaultReadServiceInPerson(ctx context.Context, in *ServiceInPerson, db *gorm1.DB) (*ServiceInPerson, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceInPersonORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceInPersonORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceInPersonORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceInPersonORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceInPerson(ctx context.Context, in *ServiceInPerson, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceInPersonORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceInPersonORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceInPersonSet(ctx context.Context, in []*ServiceInPerson, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceInPersonORM{})).(ServiceInPersonORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceInPersonORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceInPersonORM{})).(ServiceInPersonORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceInPersonORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceInPerson, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceInPerson, *gorm1.DB) error
}

// DefaultStrictUpdateServiceInPerson clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceInPerson(ctx context.Context, in *ServiceInPerson, db *gorm1.DB) (*ServiceInPerson, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceInPerson")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceInPersonORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceInPersonORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceInPerson executes a basic gorm update call with patch behavior
func DefaultPatchServiceInPerson(ctx context.Context, in *ServiceInPerson, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceInPerson, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceInPerson
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceInPersonWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceInPerson(ctx, &ServiceInPerson{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceInPersonWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceInPerson(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceInPersonWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceInPerson(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceInPersonWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceInPersonWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceInPerson, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceInPerson, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceInPerson, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceInPersonWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceInPerson, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceInPerson executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceInPerson(ctx context.Context, objects []*ServiceInPerson, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceInPerson, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceInPerson, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceInPerson(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceInPerson patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceInPerson(ctx context.Context, patchee *ServiceInPerson, patcher *ServiceInPerson, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceInPerson, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceInPerson executes a gorm list call
func DefaultListServiceInPerson(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceInPerson, error) {
	in := ServiceInPerson{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceInPersonORM{}, &ServiceInPerson{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceInPersonORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceInPersonORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceInPerson{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceInPersonORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceInPersonORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceInPersonORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceInPersonORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceApplication executes a basic gorm create call
func DefaultCreateServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceApplication executes a basic gorm read call
func DefaultReadServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceApplicationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceApplicationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceApplicationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceApplicationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplicationSet(ctx context.Context, in []*ServiceApplication, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceApplicationORM{})).(ServiceApplicationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceApplicationORM{})).(ServiceApplicationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceApplicationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceApplication, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceApplication, *gorm1.DB) error
}

// DefaultStrictUpdateServiceApplication clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceApplication")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceApplicationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterApprovedBy := ProfileORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterApprovedBy.ServiceApplicationId = new(string)
	*filterApprovedBy.ServiceApplicationId = ormObj.Id
	if err = db.Where(filterApprovedBy).Delete(ProfileORM{}).Error; err != nil {
		return nil, err
	}
	filterFiles := ServiceApplicationFileORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterFiles.ServiceApplicationId = new(string)
	*filterFiles.ServiceApplicationId = ormObj.Id
	if err = db.Where(filterFiles).Delete(ServiceApplicationFileORM{}).Error; err != nil {
		return nil, err
	}
	filterProvider := ServiceProviderORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterProvider.ServiceApplicationId = new(string)
	*filterProvider.ServiceApplicationId = ormObj.Id
	if err = db.Where(filterProvider).Delete(ServiceProviderORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceApplicationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceApplication executes a basic gorm update call with patch behavior
func DefaultPatchServiceApplication(ctx context.Context, in *ServiceApplication, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceApplication
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceApplicationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceApplication(ctx, &ServiceApplication{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceApplicationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceApplication(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceApplicationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceApplication(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceApplicationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceApplicationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceApplication executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceApplication(ctx context.Context, objects []*ServiceApplication, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceApplication, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceApplication, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceApplication(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceApplication patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceApplication(ctx context.Context, patchee *ServiceApplication, patcher *ServiceApplication, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceApplication, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedProvider bool
	var updatedApprovedBy bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedProvider && strings.HasPrefix(f, prefix+"Provider.") {
			updatedProvider = true
			if patcher.Provider == nil {
				patchee.Provider = nil
				continue
			}
			if patchee.Provider == nil {
				patchee.Provider = &ServiceProvider{}
			}
			if o, err := DefaultApplyFieldMaskServiceProvider(ctx, patchee.Provider, patcher.Provider, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Provider.", db); err != nil {
				return nil, err
			} else {
				patchee.Provider = o
			}
			continue
		}
		if f == prefix+"Provider" {
			updatedProvider = true
			patchee.Provider = patcher.Provider
			continue
		}
		if f == prefix+"Files" {
			patchee.Files = patcher.Files
			continue
		}
		if f == prefix+"AppliedAt" {
			patchee.AppliedAt = patcher.AppliedAt
			continue
		}
		if f == prefix+"ApprovedAt" {
			patchee.ApprovedAt = patcher.ApprovedAt
			continue
		}
		if !updatedApprovedBy && strings.HasPrefix(f, prefix+"ApprovedBy.") {
			updatedApprovedBy = true
			if patcher.ApprovedBy == nil {
				patchee.ApprovedBy = nil
				continue
			}
			if patchee.ApprovedBy == nil {
				patchee.ApprovedBy = &Profile{}
			}
			if o, err := DefaultApplyFieldMaskProfile(ctx, patchee.ApprovedBy, patcher.ApprovedBy, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ApprovedBy.", db); err != nil {
				return nil, err
			} else {
				patchee.ApprovedBy = o
			}
			continue
		}
		if f == prefix+"ApprovedBy" {
			updatedApprovedBy = true
			patchee.ApprovedBy = patcher.ApprovedBy
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceApplication executes a gorm list call
func DefaultListServiceApplication(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceApplication, error) {
	in := ServiceApplication{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceApplicationORM{}, &ServiceApplication{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceApplicationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceApplication{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceApplicationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceApplicationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceApplicationORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceApplicationFile executes a basic gorm create call
func DefaultCreateServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationFileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceApplicationFile executes a basic gorm read call
func DefaultReadServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceApplicationFileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceApplicationFileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceApplicationFileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationFileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceApplicationFileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceApplicationFileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplicationFileSet(ctx context.Context, in []*ServiceApplicationFile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceApplicationFileORM{})).(ServiceApplicationFileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceApplicationFileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceApplicationFileORM{})).(ServiceApplicationFileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceApplicationFileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceApplicationFile, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceApplicationFile, *gorm1.DB) error
}

// DefaultStrictUpdateServiceApplicationFile clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceApplicationFile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceApplicationFileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceApplicationFileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceApplicationFile executes a basic gorm update call with patch behavior
func DefaultPatchServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceApplicationFile
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceApplicationFileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceApplicationFile(ctx, &ServiceApplicationFile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceApplicationFileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceApplicationFile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceApplicationFileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceApplicationFile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceApplicationFileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceApplicationFileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceApplicationFile executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceApplicationFile(ctx context.Context, objects []*ServiceApplicationFile, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceApplicationFile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceApplicationFile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceApplicationFile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceApplicationFile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceApplicationFile(ctx context.Context, patchee *ServiceApplicationFile, patcher *ServiceApplicationFile, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Url" {
			patchee.Url = patcher.Url
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceApplicationFile executes a gorm list call
func DefaultListServiceApplicationFile(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceApplicationFile, error) {
	in := ServiceApplicationFile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceApplicationFileORM{}, &ServiceApplicationFile{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceApplicationFileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceApplicationFile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceApplicationFileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceApplicationFileORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceProvider executes a basic gorm create call
func DefaultCreateServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceProviderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceProvider executes a basic gorm read call
func DefaultReadServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceProviderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceProviderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceProviderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceProviderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceProviderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceProviderSet(ctx context.Context, in []*ServiceProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceProviderORM{})).(ServiceProviderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceProviderORM{})).(ServiceProviderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceProviderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceProvider, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceProvider, *gorm1.DB) error
}

// DefaultStrictUpdateServiceProvider clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceProvider")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceProviderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterOffers := ServiceOfferORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterOffers.ServiceProviderId = new(int64)
	*filterOffers.ServiceProviderId = ormObj.Id
	if err = db.Where(filterOffers).Delete(ServiceOfferORM{}).Error; err != nil {
		return nil, err
	}
	filterServiceInPerson := ServiceInPersonORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterServiceInPerson.ServiceProviderId = new(int64)
	*filterServiceInPerson.ServiceProviderId = ormObj.Id
	if err = db.Where(filterServiceInPerson).Delete(ServiceInPersonORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceProviderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceProvider executes a basic gorm update call with patch behavior
func DefaultPatchServiceProvider(ctx context.Context, in *ServiceProvider, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceProvider
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceProviderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceProvider(ctx, &ServiceProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceProviderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceProvider(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceProviderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceProvider(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceProviderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceProviderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceProvider executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceProvider(ctx context.Context, objects []*ServiceProvider, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceProvider, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceProvider, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceProvider(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceProvider patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceProvider(ctx context.Context, patchee *ServiceProvider, patcher *ServiceProvider, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceProvider, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedServiceInPerson bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Offers" {
			patchee.Offers = patcher.Offers
			continue
		}
		if !updatedServiceInPerson && strings.HasPrefix(f, prefix+"ServiceInPerson.") {
			updatedServiceInPerson = true
			if patcher.ServiceInPerson == nil {
				patchee.ServiceInPerson = nil
				continue
			}
			if patchee.ServiceInPerson == nil {
				patchee.ServiceInPerson = &ServiceInPerson{}
			}
			if o, err := DefaultApplyFieldMaskServiceInPerson(ctx, patchee.ServiceInPerson, patcher.ServiceInPerson, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ServiceInPerson.", db); err != nil {
				return nil, err
			} else {
				patchee.ServiceInPerson = o
			}
			continue
		}
		if f == prefix+"ServiceInPerson" {
			updatedServiceInPerson = true
			patchee.ServiceInPerson = patcher.ServiceInPerson
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceProvider executes a gorm list call
func DefaultListServiceProvider(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceProvider, error) {
	in := ServiceProvider{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceProviderORM{}, &ServiceProvider{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceProviderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceProvider{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceProviderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceProviderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceProviderORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceSession executes a basic gorm create call
func DefaultCreateServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceSession executes a basic gorm read call
func DefaultReadServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceSessionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceSessionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceSessionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceSessionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceSessionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSessionSet(ctx context.Context, in []*ServiceSession, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceSessionORM{})).(ServiceSessionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceSessionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceSessionORM{})).(ServiceSessionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceSessionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceSession, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceSession, *gorm1.DB) error
}

// DefaultStrictUpdateServiceSession clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceSession")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceSessionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterClient := ProfileORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterClient.ServiceSessionId = new(string)
	*filterClient.ServiceSessionId = ormObj.Id
	if err = db.Where(filterClient).Delete(ProfileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceSessionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceSession executes a basic gorm update call with patch behavior
func DefaultPatchServiceSession(ctx context.Context, in *ServiceSession, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceSession
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceSessionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceSession(ctx, &ServiceSession{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceSessionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceSession(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceSessionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceSession(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceSessionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceSessionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceSession executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceSession(ctx context.Context, objects []*ServiceSession, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceSession, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceSession, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceSession(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceSession patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceSession(ctx context.Context, patchee *ServiceSession, patcher *ServiceSession, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceSession, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedClient bool
	var updatedOffer bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"ScheduledAt" {
			patchee.ScheduledAt = patcher.ScheduledAt
			continue
		}
		if f == prefix+"FinishedAt" {
			patchee.FinishedAt = patcher.FinishedAt
			continue
		}
		if !updatedClient && strings.HasPrefix(f, prefix+"Client.") {
			updatedClient = true
			if patcher.Client == nil {
				patchee.Client = nil
				continue
			}
			if patchee.Client == nil {
				patchee.Client = &Profile{}
			}
			if o, err := DefaultApplyFieldMaskProfile(ctx, patchee.Client, patcher.Client, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Client.", db); err != nil {
				return nil, err
			} else {
				patchee.Client = o
			}
			continue
		}
		if f == prefix+"Client" {
			updatedClient = true
			patchee.Client = patcher.Client
			continue
		}
		if !updatedOffer && strings.HasPrefix(f, prefix+"Offer.") {
			updatedOffer = true
			if patcher.Offer == nil {
				patchee.Offer = nil
				continue
			}
			if patchee.Offer == nil {
				patchee.Offer = &ServiceOffer{}
			}
			if o, err := DefaultApplyFieldMaskServiceOffer(ctx, patchee.Offer, patcher.Offer, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Offer.", db); err != nil {
				return nil, err
			} else {
				patchee.Offer = o
			}
			continue
		}
		if f == prefix+"Offer" {
			updatedOffer = true
			patchee.Offer = patcher.Offer
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceSession executes a gorm list call
func DefaultListServiceSession(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceSession, error) {
	in := ServiceSession{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceSessionORM{}, &ServiceSession{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceSessionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceSession{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceSessionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceSessionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceSessionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}
type ServicesDefaultServer struct {
	DB *gorm1.DB
}

// ListService ...
func (m *ServicesDefaultServer) ListService(ctx context.Context, in *ListServiceRequest) (*ListServiceResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeListService); ok {
		var err error
		if db, err = custom.BeforeListService(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListService(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterListService); ok {
		var err error
		if err = custom.AfterListService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeListService called before DefaultListServiceService in the default ListService handler
type ServicesServiceWithBeforeListService interface {
	BeforeListService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterListService called before DefaultListServiceService in the default ListService handler
type ServicesServiceWithAfterListService interface {
	AfterListService(context.Context, *ListServiceResponse, *gorm1.DB) error
}

// CreateService ...
func (m *ServicesDefaultServer) CreateService(ctx context.Context, in *CreateServiceRequest) (*CreateServiceResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeCreateService); ok {
		var err error
		if db, err = custom.BeforeCreateService(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateService(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterCreateService); ok {
		var err error
		if err = custom.AfterCreateService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeCreateService called before DefaultCreateServiceService in the default CreateService handler
type ServicesServiceWithBeforeCreateService interface {
	BeforeCreateService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterCreateService called before DefaultCreateServiceService in the default CreateService handler
type ServicesServiceWithAfterCreateService interface {
	AfterCreateService(context.Context, *CreateServiceResponse, *gorm1.DB) error
}

// ReadService ...
func (m *ServicesDefaultServer) ReadService(ctx context.Context, in *ReadServiceRequest) (*ReadServiceResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeReadService); ok {
		var err error
		if db, err = custom.BeforeReadService(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterReadService); ok {
		var err error
		if err = custom.AfterReadService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeReadService called before DefaultReadServiceService in the default ReadService handler
type ServicesServiceWithBeforeReadService interface {
	BeforeReadService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterReadService called before DefaultReadServiceService in the default ReadService handler
type ServicesServiceWithAfterReadService interface {
	AfterReadService(context.Context, *ReadServiceResponse, *gorm1.DB) error
}

// UpdateService ...
func (m *ServicesDefaultServer) UpdateService(ctx context.Context, in *UpdateServiceRequest) (*UpdateServiceResponse, error) {
	var err error
	var res *Service
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeUpdateService); ok {
		var err error
		if db, err = custom.BeforeUpdateService(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateService(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterUpdateService); ok {
		var err error
		if err = custom.AfterUpdateService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeUpdateService called before DefaultUpdateServiceService in the default UpdateService handler
type ServicesServiceWithBeforeUpdateService interface {
	BeforeUpdateService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterUpdateService called before DefaultUpdateServiceService in the default UpdateService handler
type ServicesServiceWithAfterUpdateService interface {
	AfterUpdateService(context.Context, *UpdateServiceResponse, *gorm1.DB) error
}

// DeleteService ...
func (m *ServicesDefaultServer) DeleteService(ctx context.Context, in *DeleteServiceRequest) (*DeleteServiceResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeDeleteService); ok {
		var err error
		if db, err = custom.BeforeDeleteService(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceResponse{}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterDeleteService); ok {
		var err error
		if err = custom.AfterDeleteService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeDeleteService called before DefaultDeleteServiceService in the default DeleteService handler
type ServicesServiceWithBeforeDeleteService interface {
	BeforeDeleteService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterDeleteService called before DefaultDeleteServiceService in the default DeleteService handler
type ServicesServiceWithAfterDeleteService interface {
	AfterDeleteService(context.Context, *DeleteServiceResponse, *gorm1.DB) error
}

// ListServiceSession ...
func (m *ServicesDefaultServer) ListServiceSession(ctx context.Context, in *ListServiceSessionRequest) (*ListServiceSessionResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeListServiceSession); ok {
		var err error
		if db, err = custom.BeforeListServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceSession(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceSessionResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterListServiceSession); ok {
		var err error
		if err = custom.AfterListServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeListServiceSession called before DefaultListServiceSessionServiceSession in the default ListServiceSession handler
type ServicesServiceSessionWithBeforeListServiceSession interface {
	BeforeListServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterListServiceSession called before DefaultListServiceSessionServiceSession in the default ListServiceSession handler
type ServicesServiceSessionWithAfterListServiceSession interface {
	AfterListServiceSession(context.Context, *ListServiceSessionResponse, *gorm1.DB) error
}

// CreateServiceSession ...
func (m *ServicesDefaultServer) CreateServiceSession(ctx context.Context, in *CreateServiceSessionRequest) (*CreateServiceSessionResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeCreateServiceSession); ok {
		var err error
		if db, err = custom.BeforeCreateServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceSession(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceSessionResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterCreateServiceSession); ok {
		var err error
		if err = custom.AfterCreateServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeCreateServiceSession called before DefaultCreateServiceSessionServiceSession in the default CreateServiceSession handler
type ServicesServiceSessionWithBeforeCreateServiceSession interface {
	BeforeCreateServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterCreateServiceSession called before DefaultCreateServiceSessionServiceSession in the default CreateServiceSession handler
type ServicesServiceSessionWithAfterCreateServiceSession interface {
	AfterCreateServiceSession(context.Context, *CreateServiceSessionResponse, *gorm1.DB) error
}

// ReadServiceSession ...
func (m *ServicesDefaultServer) ReadServiceSession(ctx context.Context, in *ReadServiceSessionRequest) (*ReadServiceSessionResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeReadServiceSession); ok {
		var err error
		if db, err = custom.BeforeReadServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceSession(ctx, &ServiceSession{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceSessionResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterReadServiceSession); ok {
		var err error
		if err = custom.AfterReadServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeReadServiceSession called before DefaultReadServiceSessionServiceSession in the default ReadServiceSession handler
type ServicesServiceSessionWithBeforeReadServiceSession interface {
	BeforeReadServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterReadServiceSession called before DefaultReadServiceSessionServiceSession in the default ReadServiceSession handler
type ServicesServiceSessionWithAfterReadServiceSession interface {
	AfterReadServiceSession(context.Context, *ReadServiceSessionResponse, *gorm1.DB) error
}

// UpdateServiceSession ...
func (m *ServicesDefaultServer) UpdateServiceSession(ctx context.Context, in *UpdateServiceSessionRequest) (*UpdateServiceSessionResponse, error) {
	var err error
	var res *ServiceSession
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeUpdateServiceSession); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceSession(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceSessionResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterUpdateServiceSession); ok {
		var err error
		if err = custom.AfterUpdateServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeUpdateServiceSession called before DefaultUpdateServiceSessionServiceSession in the default UpdateServiceSession handler
type ServicesServiceSessionWithBeforeUpdateServiceSession interface {
	BeforeUpdateServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterUpdateServiceSession called before DefaultUpdateServiceSessionServiceSession in the default UpdateServiceSession handler
type ServicesServiceSessionWithAfterUpdateServiceSession interface {
	AfterUpdateServiceSession(context.Context, *UpdateServiceSessionResponse, *gorm1.DB) error
}

// DeleteServiceSession ...
func (m *ServicesDefaultServer) DeleteServiceSession(ctx context.Context, in *DeleteServiceSessionRequest) (*DeleteServiceSessionResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeDeleteServiceSession); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceSession(ctx, &ServiceSession{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceSessionResponse{}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterDeleteServiceSession); ok {
		var err error
		if err = custom.AfterDeleteServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeDeleteServiceSession called before DefaultDeleteServiceSessionServiceSession in the default DeleteServiceSession handler
type ServicesServiceSessionWithBeforeDeleteServiceSession interface {
	BeforeDeleteServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterDeleteServiceSession called before DefaultDeleteServiceSessionServiceSession in the default DeleteServiceSession handler
type ServicesServiceSessionWithAfterDeleteServiceSession interface {
	AfterDeleteServiceSession(context.Context, *DeleteServiceSessionResponse, *gorm1.DB) error
}

// ListServiceTag ...
func (m *ServicesDefaultServer) ListServiceTag(ctx context.Context, in *ListServiceTagRequest) (*ListServiceTagResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeListServiceTag); ok {
		var err error
		if db, err = custom.BeforeListServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceTag(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceTagResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterListServiceTag); ok {
		var err error
		if err = custom.AfterListServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeListServiceTag called before DefaultListServiceTagServiceTag in the default ListServiceTag handler
type ServicesServiceTagWithBeforeListServiceTag interface {
	BeforeListServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterListServiceTag called before DefaultListServiceTagServiceTag in the default ListServiceTag handler
type ServicesServiceTagWithAfterListServiceTag interface {
	AfterListServiceTag(context.Context, *ListServiceTagResponse, *gorm1.DB) error
}

// CreateServiceTag ...
func (m *ServicesDefaultServer) CreateServiceTag(ctx context.Context, in *CreateServiceTagRequest) (*CreateServiceTagResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeCreateServiceTag); ok {
		var err error
		if db, err = custom.BeforeCreateServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceTag(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceTagResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterCreateServiceTag); ok {
		var err error
		if err = custom.AfterCreateServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeCreateServiceTag called before DefaultCreateServiceTagServiceTag in the default CreateServiceTag handler
type ServicesServiceTagWithBeforeCreateServiceTag interface {
	BeforeCreateServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterCreateServiceTag called before DefaultCreateServiceTagServiceTag in the default CreateServiceTag handler
type ServicesServiceTagWithAfterCreateServiceTag interface {
	AfterCreateServiceTag(context.Context, *CreateServiceTagResponse, *gorm1.DB) error
}

// ReadServiceTag ...
func (m *ServicesDefaultServer) ReadServiceTag(ctx context.Context, in *ReadServiceTagRequest) (*ReadServiceTagResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeReadServiceTag); ok {
		var err error
		if db, err = custom.BeforeReadServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceTag(ctx, &ServiceTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceTagResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterReadServiceTag); ok {
		var err error
		if err = custom.AfterReadServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeReadServiceTag called before DefaultReadServiceTagServiceTag in the default ReadServiceTag handler
type ServicesServiceTagWithBeforeReadServiceTag interface {
	BeforeReadServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterReadServiceTag called before DefaultReadServiceTagServiceTag in the default ReadServiceTag handler
type ServicesServiceTagWithAfterReadServiceTag interface {
	AfterReadServiceTag(context.Context, *ReadServiceTagResponse, *gorm1.DB) error
}

// UpdateServiceTag ...
func (m *ServicesDefaultServer) UpdateServiceTag(ctx context.Context, in *UpdateServiceTagRequest) (*UpdateServiceTagResponse, error) {
	var err error
	var res *ServiceTag
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeUpdateServiceTag); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceTag(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceTagResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterUpdateServiceTag); ok {
		var err error
		if err = custom.AfterUpdateServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeUpdateServiceTag called before DefaultUpdateServiceTagServiceTag in the default UpdateServiceTag handler
type ServicesServiceTagWithBeforeUpdateServiceTag interface {
	BeforeUpdateServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterUpdateServiceTag called before DefaultUpdateServiceTagServiceTag in the default UpdateServiceTag handler
type ServicesServiceTagWithAfterUpdateServiceTag interface {
	AfterUpdateServiceTag(context.Context, *UpdateServiceTagResponse, *gorm1.DB) error
}

// DeleteServiceTag ...
func (m *ServicesDefaultServer) DeleteServiceTag(ctx context.Context, in *DeleteServiceTagRequest) (*DeleteServiceTagResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeDeleteServiceTag); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceTag(ctx, &ServiceTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceTagResponse{}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterDeleteServiceTag); ok {
		var err error
		if err = custom.AfterDeleteServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeDeleteServiceTag called before DefaultDeleteServiceTagServiceTag in the default DeleteServiceTag handler
type ServicesServiceTagWithBeforeDeleteServiceTag interface {
	BeforeDeleteServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterDeleteServiceTag called before DefaultDeleteServiceTagServiceTag in the default DeleteServiceTag handler
type ServicesServiceTagWithAfterDeleteServiceTag interface {
	AfterDeleteServiceTag(context.Context, *DeleteServiceTagResponse, *gorm1.DB) error
}

// ListServiceInPerson ...
func (m *ServicesDefaultServer) ListServiceInPerson(ctx context.Context, in *ListServiceInPersonRequest) (*ListServiceInPersonResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithBeforeListServiceInPerson); ok {
		var err error
		if db, err = custom.BeforeListServiceInPerson(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceInPerson(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceInPersonResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithAfterListServiceInPerson); ok {
		var err error
		if err = custom.AfterListServiceInPerson(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceInPersonWithBeforeListServiceInPerson called before DefaultListServiceInPersonServiceInPerson in the default ListServiceInPerson handler
type ServicesServiceInPersonWithBeforeListServiceInPerson interface {
	BeforeListServiceInPerson(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceInPersonWithAfterListServiceInPerson called before DefaultListServiceInPersonServiceInPerson in the default ListServiceInPerson handler
type ServicesServiceInPersonWithAfterListServiceInPerson interface {
	AfterListServiceInPerson(context.Context, *ListServiceInPersonResponse, *gorm1.DB) error
}

// CreateServiceInPerson ...
func (m *ServicesDefaultServer) CreateServiceInPerson(ctx context.Context, in *CreateServiceInPersonRequest) (*CreateServiceInPersonResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithBeforeCreateServiceInPerson); ok {
		var err error
		if db, err = custom.BeforeCreateServiceInPerson(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceInPerson(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceInPersonResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithAfterCreateServiceInPerson); ok {
		var err error
		if err = custom.AfterCreateServiceInPerson(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceInPersonWithBeforeCreateServiceInPerson called before DefaultCreateServiceInPersonServiceInPerson in the default CreateServiceInPerson handler
type ServicesServiceInPersonWithBeforeCreateServiceInPerson interface {
	BeforeCreateServiceInPerson(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceInPersonWithAfterCreateServiceInPerson called before DefaultCreateServiceInPersonServiceInPerson in the default CreateServiceInPerson handler
type ServicesServiceInPersonWithAfterCreateServiceInPerson interface {
	AfterCreateServiceInPerson(context.Context, *CreateServiceInPersonResponse, *gorm1.DB) error
}

// ReadServiceInPerson ...
func (m *ServicesDefaultServer) ReadServiceInPerson(ctx context.Context, in *ReadServiceInPersonRequest) (*ReadServiceInPersonResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithBeforeReadServiceInPerson); ok {
		var err error
		if db, err = custom.BeforeReadServiceInPerson(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceInPerson(ctx, &ServiceInPerson{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceInPersonResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithAfterReadServiceInPerson); ok {
		var err error
		if err = custom.AfterReadServiceInPerson(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceInPersonWithBeforeReadServiceInPerson called before DefaultReadServiceInPersonServiceInPerson in the default ReadServiceInPerson handler
type ServicesServiceInPersonWithBeforeReadServiceInPerson interface {
	BeforeReadServiceInPerson(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceInPersonWithAfterReadServiceInPerson called before DefaultReadServiceInPersonServiceInPerson in the default ReadServiceInPerson handler
type ServicesServiceInPersonWithAfterReadServiceInPerson interface {
	AfterReadServiceInPerson(context.Context, *ReadServiceInPersonResponse, *gorm1.DB) error
}

// UpdateServiceInPerson ...
func (m *ServicesDefaultServer) UpdateServiceInPerson(ctx context.Context, in *UpdateServiceInPersonRequest) (*UpdateServiceInPersonResponse, error) {
	var err error
	var res *ServiceInPerson
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithBeforeUpdateServiceInPerson); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceInPerson(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceInPerson(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceInPersonResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithAfterUpdateServiceInPerson); ok {
		var err error
		if err = custom.AfterUpdateServiceInPerson(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceInPersonWithBeforeUpdateServiceInPerson called before DefaultUpdateServiceInPersonServiceInPerson in the default UpdateServiceInPerson handler
type ServicesServiceInPersonWithBeforeUpdateServiceInPerson interface {
	BeforeUpdateServiceInPerson(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceInPersonWithAfterUpdateServiceInPerson called before DefaultUpdateServiceInPersonServiceInPerson in the default UpdateServiceInPerson handler
type ServicesServiceInPersonWithAfterUpdateServiceInPerson interface {
	AfterUpdateServiceInPerson(context.Context, *UpdateServiceInPersonResponse, *gorm1.DB) error
}

// DeleteServiceInPerson ...
func (m *ServicesDefaultServer) DeleteServiceInPerson(ctx context.Context, in *DeleteServiceInPersonRequest) (*DeleteServiceInPersonResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithBeforeDeleteServiceInPerson); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceInPerson(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceInPerson(ctx, &ServiceInPerson{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceInPersonResponse{}
	if custom, ok := interface{}(in).(ServicesServiceInPersonWithAfterDeleteServiceInPerson); ok {
		var err error
		if err = custom.AfterDeleteServiceInPerson(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceInPersonWithBeforeDeleteServiceInPerson called before DefaultDeleteServiceInPersonServiceInPerson in the default DeleteServiceInPerson handler
type ServicesServiceInPersonWithBeforeDeleteServiceInPerson interface {
	BeforeDeleteServiceInPerson(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceInPersonWithAfterDeleteServiceInPerson called before DefaultDeleteServiceInPersonServiceInPerson in the default DeleteServiceInPerson handler
type ServicesServiceInPersonWithAfterDeleteServiceInPerson interface {
	AfterDeleteServiceInPerson(context.Context, *DeleteServiceInPersonResponse, *gorm1.DB) error
}

// ListServiceOffer ...
func (m *ServicesDefaultServer) ListServiceOffer(ctx context.Context, in *ListServiceOfferRequest) (*ListServiceOfferResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeListServiceOffer); ok {
		var err error
		if db, err = custom.BeforeListServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceOffer(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceOfferResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterListServiceOffer); ok {
		var err error
		if err = custom.AfterListServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeListServiceOffer called before DefaultListServiceOfferServiceOffer in the default ListServiceOffer handler
type ServicesServiceOfferWithBeforeListServiceOffer interface {
	BeforeListServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterListServiceOffer called before DefaultListServiceOfferServiceOffer in the default ListServiceOffer handler
type ServicesServiceOfferWithAfterListServiceOffer interface {
	AfterListServiceOffer(context.Context, *ListServiceOfferResponse, *gorm1.DB) error
}

// CreateServiceOffer ...
func (m *ServicesDefaultServer) CreateServiceOffer(ctx context.Context, in *CreateServiceOfferRequest) (*CreateServiceOfferResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeCreateServiceOffer); ok {
		var err error
		if db, err = custom.BeforeCreateServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceOffer(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceOfferResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterCreateServiceOffer); ok {
		var err error
		if err = custom.AfterCreateServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeCreateServiceOffer called before DefaultCreateServiceOfferServiceOffer in the default CreateServiceOffer handler
type ServicesServiceOfferWithBeforeCreateServiceOffer interface {
	BeforeCreateServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterCreateServiceOffer called before DefaultCreateServiceOfferServiceOffer in the default CreateServiceOffer handler
type ServicesServiceOfferWithAfterCreateServiceOffer interface {
	AfterCreateServiceOffer(context.Context, *CreateServiceOfferResponse, *gorm1.DB) error
}

// ReadServiceOffer ...
func (m *ServicesDefaultServer) ReadServiceOffer(ctx context.Context, in *ReadServiceOfferRequest) (*ReadServiceOfferResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeReadServiceOffer); ok {
		var err error
		if db, err = custom.BeforeReadServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceOffer(ctx, &ServiceOffer{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceOfferResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterReadServiceOffer); ok {
		var err error
		if err = custom.AfterReadServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeReadServiceOffer called before DefaultReadServiceOfferServiceOffer in the default ReadServiceOffer handler
type ServicesServiceOfferWithBeforeReadServiceOffer interface {
	BeforeReadServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterReadServiceOffer called before DefaultReadServiceOfferServiceOffer in the default ReadServiceOffer handler
type ServicesServiceOfferWithAfterReadServiceOffer interface {
	AfterReadServiceOffer(context.Context, *ReadServiceOfferResponse, *gorm1.DB) error
}

// UpdateServiceOffer ...
func (m *ServicesDefaultServer) UpdateServiceOffer(ctx context.Context, in *UpdateServiceOfferRequest) (*UpdateServiceOfferResponse, error) {
	var err error
	var res *ServiceOffer
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeUpdateServiceOffer); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceOffer(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceOfferResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterUpdateServiceOffer); ok {
		var err error
		if err = custom.AfterUpdateServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeUpdateServiceOffer called before DefaultUpdateServiceOfferServiceOffer in the default UpdateServiceOffer handler
type ServicesServiceOfferWithBeforeUpdateServiceOffer interface {
	BeforeUpdateServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterUpdateServiceOffer called before DefaultUpdateServiceOfferServiceOffer in the default UpdateServiceOffer handler
type ServicesServiceOfferWithAfterUpdateServiceOffer interface {
	AfterUpdateServiceOffer(context.Context, *UpdateServiceOfferResponse, *gorm1.DB) error
}

// DeleteServiceOffer ...
func (m *ServicesDefaultServer) DeleteServiceOffer(ctx context.Context, in *DeleteServiceOfferRequest) (*DeleteServiceOfferResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeDeleteServiceOffer); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceOffer(ctx, &ServiceOffer{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceOfferResponse{}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterDeleteServiceOffer); ok {
		var err error
		if err = custom.AfterDeleteServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeDeleteServiceOffer called before DefaultDeleteServiceOfferServiceOffer in the default DeleteServiceOffer handler
type ServicesServiceOfferWithBeforeDeleteServiceOffer interface {
	BeforeDeleteServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterDeleteServiceOffer called before DefaultDeleteServiceOfferServiceOffer in the default DeleteServiceOffer handler
type ServicesServiceOfferWithAfterDeleteServiceOffer interface {
	AfterDeleteServiceOffer(context.Context, *DeleteServiceOfferResponse, *gorm1.DB) error
}

// ListServiceApplicationFile ...
func (m *ServicesDefaultServer) ListServiceApplicationFile(ctx context.Context, in *ListServiceApplicationFileRequest) (*ListServiceApplicationFileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithBeforeListServiceApplicationFile); ok {
		var err error
		if db, err = custom.BeforeListServiceApplicationFile(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceApplicationFile(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceApplicationFileResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithAfterListServiceApplicationFile); ok {
		var err error
		if err = custom.AfterListServiceApplicationFile(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationFileWithBeforeListServiceApplicationFile called before DefaultListServiceApplicationFileServiceApplicationFile in the default ListServiceApplicationFile handler
type ServicesServiceApplicationFileWithBeforeListServiceApplicationFile interface {
	BeforeListServiceApplicationFile(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationFileWithAfterListServiceApplicationFile called before DefaultListServiceApplicationFileServiceApplicationFile in the default ListServiceApplicationFile handler
type ServicesServiceApplicationFileWithAfterListServiceApplicationFile interface {
	AfterListServiceApplicationFile(context.Context, *ListServiceApplicationFileResponse, *gorm1.DB) error
}

// CreateServiceApplicationFile ...
func (m *ServicesDefaultServer) CreateServiceApplicationFile(ctx context.Context, in *CreateServiceApplicationFileRequest) (*CreateServiceApplicationFileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithBeforeCreateServiceApplicationFile); ok {
		var err error
		if db, err = custom.BeforeCreateServiceApplicationFile(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceApplicationFile(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceApplicationFileResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithAfterCreateServiceApplicationFile); ok {
		var err error
		if err = custom.AfterCreateServiceApplicationFile(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationFileWithBeforeCreateServiceApplicationFile called before DefaultCreateServiceApplicationFileServiceApplicationFile in the default CreateServiceApplicationFile handler
type ServicesServiceApplicationFileWithBeforeCreateServiceApplicationFile interface {
	BeforeCreateServiceApplicationFile(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationFileWithAfterCreateServiceApplicationFile called before DefaultCreateServiceApplicationFileServiceApplicationFile in the default CreateServiceApplicationFile handler
type ServicesServiceApplicationFileWithAfterCreateServiceApplicationFile interface {
	AfterCreateServiceApplicationFile(context.Context, *CreateServiceApplicationFileResponse, *gorm1.DB) error
}

// ReadServiceApplicationFile ...
func (m *ServicesDefaultServer) ReadServiceApplicationFile(ctx context.Context, in *ReadServiceApplicationFileRequest) (*ReadServiceApplicationFileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithBeforeReadServiceApplicationFile); ok {
		var err error
		if db, err = custom.BeforeReadServiceApplicationFile(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceApplicationFile(ctx, &ServiceApplicationFile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceApplicationFileResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithAfterReadServiceApplicationFile); ok {
		var err error
		if err = custom.AfterReadServiceApplicationFile(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationFileWithBeforeReadServiceApplicationFile called before DefaultReadServiceApplicationFileServiceApplicationFile in the default ReadServiceApplicationFile handler
type ServicesServiceApplicationFileWithBeforeReadServiceApplicationFile interface {
	BeforeReadServiceApplicationFile(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationFileWithAfterReadServiceApplicationFile called before DefaultReadServiceApplicationFileServiceApplicationFile in the default ReadServiceApplicationFile handler
type ServicesServiceApplicationFileWithAfterReadServiceApplicationFile interface {
	AfterReadServiceApplicationFile(context.Context, *ReadServiceApplicationFileResponse, *gorm1.DB) error
}

// UpdateServiceApplicationFile ...
func (m *ServicesDefaultServer) UpdateServiceApplicationFile(ctx context.Context, in *UpdateServiceApplicationFileRequest) (*UpdateServiceApplicationFileResponse, error) {
	var err error
	var res *ServiceApplicationFile
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithBeforeUpdateServiceApplicationFile); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceApplicationFile(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceApplicationFile(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceApplicationFileResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithAfterUpdateServiceApplicationFile); ok {
		var err error
		if err = custom.AfterUpdateServiceApplicationFile(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationFileWithBeforeUpdateServiceApplicationFile called before DefaultUpdateServiceApplicationFileServiceApplicationFile in the default UpdateServiceApplicationFile handler
type ServicesServiceApplicationFileWithBeforeUpdateServiceApplicationFile interface {
	BeforeUpdateServiceApplicationFile(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationFileWithAfterUpdateServiceApplicationFile called before DefaultUpdateServiceApplicationFileServiceApplicationFile in the default UpdateServiceApplicationFile handler
type ServicesServiceApplicationFileWithAfterUpdateServiceApplicationFile interface {
	AfterUpdateServiceApplicationFile(context.Context, *UpdateServiceApplicationFileResponse, *gorm1.DB) error
}

// DeleteServiceApplicationFile ...
func (m *ServicesDefaultServer) DeleteServiceApplicationFile(ctx context.Context, in *DeleteServiceApplicationFileRequest) (*DeleteServiceApplicationFileResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithBeforeDeleteServiceApplicationFile); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceApplicationFile(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceApplicationFile(ctx, &ServiceApplicationFile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceApplicationFileResponse{}
	if custom, ok := interface{}(in).(ServicesServiceApplicationFileWithAfterDeleteServiceApplicationFile); ok {
		var err error
		if err = custom.AfterDeleteServiceApplicationFile(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationFileWithBeforeDeleteServiceApplicationFile called before DefaultDeleteServiceApplicationFileServiceApplicationFile in the default DeleteServiceApplicationFile handler
type ServicesServiceApplicationFileWithBeforeDeleteServiceApplicationFile interface {
	BeforeDeleteServiceApplicationFile(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationFileWithAfterDeleteServiceApplicationFile called before DefaultDeleteServiceApplicationFileServiceApplicationFile in the default DeleteServiceApplicationFile handler
type ServicesServiceApplicationFileWithAfterDeleteServiceApplicationFile interface {
	AfterDeleteServiceApplicationFile(context.Context, *DeleteServiceApplicationFileResponse, *gorm1.DB) error
}

// ListServiceApplication ...
func (m *ServicesDefaultServer) ListServiceApplication(ctx context.Context, in *ListServiceApplicationRequest) (*ListServiceApplicationResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeListServiceApplication); ok {
		var err error
		if db, err = custom.BeforeListServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceApplication(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceApplicationResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterListServiceApplication); ok {
		var err error
		if err = custom.AfterListServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeListServiceApplication called before DefaultListServiceApplicationServiceApplication in the default ListServiceApplication handler
type ServicesServiceApplicationWithBeforeListServiceApplication interface {
	BeforeListServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterListServiceApplication called before DefaultListServiceApplicationServiceApplication in the default ListServiceApplication handler
type ServicesServiceApplicationWithAfterListServiceApplication interface {
	AfterListServiceApplication(context.Context, *ListServiceApplicationResponse, *gorm1.DB) error
}

// CreateServiceApplication ...
func (m *ServicesDefaultServer) CreateServiceApplication(ctx context.Context, in *CreateServiceApplicationRequest) (*CreateServiceApplicationResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeCreateServiceApplication); ok {
		var err error
		if db, err = custom.BeforeCreateServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceApplication(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterCreateServiceApplication); ok {
		var err error
		if err = custom.AfterCreateServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeCreateServiceApplication called before DefaultCreateServiceApplicationServiceApplication in the default CreateServiceApplication handler
type ServicesServiceApplicationWithBeforeCreateServiceApplication interface {
	BeforeCreateServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterCreateServiceApplication called before DefaultCreateServiceApplicationServiceApplication in the default CreateServiceApplication handler
type ServicesServiceApplicationWithAfterCreateServiceApplication interface {
	AfterCreateServiceApplication(context.Context, *CreateServiceApplicationResponse, *gorm1.DB) error
}

// ReadServiceApplication ...
func (m *ServicesDefaultServer) ReadServiceApplication(ctx context.Context, in *ReadServiceApplicationRequest) (*ReadServiceApplicationResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeReadServiceApplication); ok {
		var err error
		if db, err = custom.BeforeReadServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceApplication(ctx, &ServiceApplication{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterReadServiceApplication); ok {
		var err error
		if err = custom.AfterReadServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeReadServiceApplication called before DefaultReadServiceApplicationServiceApplication in the default ReadServiceApplication handler
type ServicesServiceApplicationWithBeforeReadServiceApplication interface {
	BeforeReadServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterReadServiceApplication called before DefaultReadServiceApplicationServiceApplication in the default ReadServiceApplication handler
type ServicesServiceApplicationWithAfterReadServiceApplication interface {
	AfterReadServiceApplication(context.Context, *ReadServiceApplicationResponse, *gorm1.DB) error
}

// UpdateServiceApplication ...
func (m *ServicesDefaultServer) UpdateServiceApplication(ctx context.Context, in *UpdateServiceApplicationRequest) (*UpdateServiceApplicationResponse, error) {
	var err error
	var res *ServiceApplication
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeUpdateServiceApplication); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceApplication(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterUpdateServiceApplication); ok {
		var err error
		if err = custom.AfterUpdateServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeUpdateServiceApplication called before DefaultUpdateServiceApplicationServiceApplication in the default UpdateServiceApplication handler
type ServicesServiceApplicationWithBeforeUpdateServiceApplication interface {
	BeforeUpdateServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterUpdateServiceApplication called before DefaultUpdateServiceApplicationServiceApplication in the default UpdateServiceApplication handler
type ServicesServiceApplicationWithAfterUpdateServiceApplication interface {
	AfterUpdateServiceApplication(context.Context, *UpdateServiceApplicationResponse, *gorm1.DB) error
}

// DeleteServiceApplication ...
func (m *ServicesDefaultServer) DeleteServiceApplication(ctx context.Context, in *DeleteServiceApplicationRequest) (*DeleteServiceApplicationResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeDeleteServiceApplication); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceApplication(ctx, &ServiceApplication{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceApplicationResponse{}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterDeleteServiceApplication); ok {
		var err error
		if err = custom.AfterDeleteServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeDeleteServiceApplication called before DefaultDeleteServiceApplicationServiceApplication in the default DeleteServiceApplication handler
type ServicesServiceApplicationWithBeforeDeleteServiceApplication interface {
	BeforeDeleteServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterDeleteServiceApplication called before DefaultDeleteServiceApplicationServiceApplication in the default DeleteServiceApplication handler
type ServicesServiceApplicationWithAfterDeleteServiceApplication interface {
	AfterDeleteServiceApplication(context.Context, *DeleteServiceApplicationResponse, *gorm1.DB) error
}

// ListServiceProvider ...
func (m *ServicesDefaultServer) ListServiceProvider(ctx context.Context, in *ListServiceProviderRequest) (*ListServiceProviderResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeListServiceProvider); ok {
		var err error
		if db, err = custom.BeforeListServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceProvider(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceProviderResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterListServiceProvider); ok {
		var err error
		if err = custom.AfterListServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeListServiceProvider called before DefaultListServiceProviderServiceProvider in the default ListServiceProvider handler
type ServicesServiceProviderWithBeforeListServiceProvider interface {
	BeforeListServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterListServiceProvider called before DefaultListServiceProviderServiceProvider in the default ListServiceProvider handler
type ServicesServiceProviderWithAfterListServiceProvider interface {
	AfterListServiceProvider(context.Context, *ListServiceProviderResponse, *gorm1.DB) error
}

// CreateServiceProvider ...
func (m *ServicesDefaultServer) CreateServiceProvider(ctx context.Context, in *CreateServiceProviderRequest) (*CreateServiceProviderResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeCreateServiceProvider); ok {
		var err error
		if db, err = custom.BeforeCreateServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceProvider(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceProviderResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterCreateServiceProvider); ok {
		var err error
		if err = custom.AfterCreateServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeCreateServiceProvider called before DefaultCreateServiceProviderServiceProvider in the default CreateServiceProvider handler
type ServicesServiceProviderWithBeforeCreateServiceProvider interface {
	BeforeCreateServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterCreateServiceProvider called before DefaultCreateServiceProviderServiceProvider in the default CreateServiceProvider handler
type ServicesServiceProviderWithAfterCreateServiceProvider interface {
	AfterCreateServiceProvider(context.Context, *CreateServiceProviderResponse, *gorm1.DB) error
}

// ReadServiceProvider ...
func (m *ServicesDefaultServer) ReadServiceProvider(ctx context.Context, in *ReadServiceProviderRequest) (*ReadServiceProviderResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeReadServiceProvider); ok {
		var err error
		if db, err = custom.BeforeReadServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceProvider(ctx, &ServiceProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceProviderResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterReadServiceProvider); ok {
		var err error
		if err = custom.AfterReadServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeReadServiceProvider called before DefaultReadServiceProviderServiceProvider in the default ReadServiceProvider handler
type ServicesServiceProviderWithBeforeReadServiceProvider interface {
	BeforeReadServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterReadServiceProvider called before DefaultReadServiceProviderServiceProvider in the default ReadServiceProvider handler
type ServicesServiceProviderWithAfterReadServiceProvider interface {
	AfterReadServiceProvider(context.Context, *ReadServiceProviderResponse, *gorm1.DB) error
}

// UpdateServiceProvider ...
func (m *ServicesDefaultServer) UpdateServiceProvider(ctx context.Context, in *UpdateServiceProviderRequest) (*UpdateServiceProviderResponse, error) {
	var err error
	var res *ServiceProvider
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeUpdateServiceProvider); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceProvider(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceProviderResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterUpdateServiceProvider); ok {
		var err error
		if err = custom.AfterUpdateServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeUpdateServiceProvider called before DefaultUpdateServiceProviderServiceProvider in the default UpdateServiceProvider handler
type ServicesServiceProviderWithBeforeUpdateServiceProvider interface {
	BeforeUpdateServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterUpdateServiceProvider called before DefaultUpdateServiceProviderServiceProvider in the default UpdateServiceProvider handler
type ServicesServiceProviderWithAfterUpdateServiceProvider interface {
	AfterUpdateServiceProvider(context.Context, *UpdateServiceProviderResponse, *gorm1.DB) error
}

// DeleteServiceProvider ...
func (m *ServicesDefaultServer) DeleteServiceProvider(ctx context.Context, in *DeleteServiceProviderRequest) (*DeleteServiceProviderResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeDeleteServiceProvider); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceProvider(ctx, &ServiceProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceProviderResponse{}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterDeleteServiceProvider); ok {
		var err error
		if err = custom.AfterDeleteServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeDeleteServiceProvider called before DefaultDeleteServiceProviderServiceProvider in the default DeleteServiceProvider handler
type ServicesServiceProviderWithBeforeDeleteServiceProvider interface {
	BeforeDeleteServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterDeleteServiceProvider called before DefaultDeleteServiceProviderServiceProvider in the default DeleteServiceProvider handler
type ServicesServiceProviderWithAfterDeleteServiceProvider interface {
	AfterDeleteServiceProvider(context.Context, *DeleteServiceProviderResponse, *gorm1.DB) error
}

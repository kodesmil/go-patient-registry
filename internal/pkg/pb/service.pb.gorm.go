// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/kodesmil/ks-model/service.proto

// Generated with protoc-gen-gorm version: master
// Anticipating compatibility with atlas-app-toolkit version: master

package pb

import context "context"
import fmt "fmt"
import strings "strings"
import time "time"

import auth1 "github.com/kodesmil/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import ptypes1 "github.com/golang/protobuf/ptypes"
import query1 "github.com/infobloxopen/atlas-app-toolkit/query"
import resource1 "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"

import math "math"
import _ "google.golang.org/genproto/protobuf/field_mask"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/envoyproxy/protoc-gen-validate/validate"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/infobloxopen/atlas-app-toolkit/rpc/resource"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type ServiceTagORM struct {
	Id   int64  `gorm:"type:serial;primary_key"`
	Key  string `gorm:"unique"`
	Name string
}

// TableName overrides the default tablename generated by GORM
func (ServiceTagORM) TableName() string {
	return "service_tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceTag) ToORM(ctx context.Context) (ServiceTagORM, error) {
	to := ServiceTagORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceTagWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ServiceTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	if posthook, ok := interface{}(m).(ServiceTagWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceTagORM) ToPB(ctx context.Context) (ServiceTag, error) {
	to := ServiceTag{}
	var err error
	if prehook, ok := interface{}(m).(ServiceTagWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceTag{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Key = m.Key
	to.Name = m.Name
	if posthook, ok := interface{}(m).(ServiceTagWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceTag the arg will be the target, the caller the one being converted from

// ServiceTagBeforeToORM called before default ToORM code
type ServiceTagWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceTagORM) error
}

// ServiceTagAfterToORM called after default ToORM code
type ServiceTagWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceTagORM) error
}

// ServiceTagBeforeToPB called before default ToPB code
type ServiceTagWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceTag) error
}

// ServiceTagAfterToPB called after default ToPB code
type ServiceTagWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceTag) error
}

type ServiceORM struct {
	CreatedAt *time.Time
	Id        int64 `gorm:"type:serial;primary_key"`
	Name      string
	Tags      []*ServiceTagORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:service_service_tags;jointable_foreignkey:service_id;association_jointable_foreignkey:service_tag_id"`
	Type      int32
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceORM) TableName() string {
	return "services"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Service) ToORM(ctx context.Context) (ServiceORM, error) {
	to := ServiceORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&Service{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	to.Type = int32(m.Type)
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceORM) ToPB(ctx context.Context) (Service, error) {
	to := Service{}
	var err error
	if prehook, ok := interface{}(m).(ServiceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&Service{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Type = Service_Type(m.Type)
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	if posthook, ok := interface{}(m).(ServiceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Service the arg will be the target, the caller the one being converted from

// ServiceBeforeToORM called before default ToORM code
type ServiceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceORM) error
}

// ServiceAfterToORM called after default ToORM code
type ServiceWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceORM) error
}

// ServiceBeforeToPB called before default ToPB code
type ServiceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Service) error
}

// ServiceAfterToPB called after default ToPB code
type ServiceWithAfterToPB interface {
	AfterToPB(context.Context, *Service) error
}

type ServiceOfferORM struct {
	CreatedAt         *time.Time
	Currency          string
	Description       string
	Id                string `gorm:"type:uuid;primary_key"`
	Price             float32
	Provider          *ServiceProviderORM `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	Service           *ServiceORM         `gorm:"foreignkey:ServiceId;association_foreignkey:Id"`
	ServiceId         *int64
	ServiceProviderId *string
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceOfferORM) TableName() string {
	return "service_offers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceOffer) ToORM(ctx context.Context) (ServiceOfferORM, error) {
	to := ServiceOfferORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceOfferWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceOffer{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Price = m.Price
	to.Currency = m.Currency
	if m.Service != nil {
		tempService, err := m.Service.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	to.Description = m.Description
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	if posthook, ok := interface{}(m).(ServiceOfferWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceOfferORM) ToPB(ctx context.Context) (ServiceOffer, error) {
	to := ServiceOffer{}
	var err error
	if prehook, ok := interface{}(m).(ServiceOfferWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceOffer{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Price = m.Price
	to.Currency = m.Currency
	if m.Service != nil {
		tempService, err := m.Service.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Service = &tempService
	}
	to.Description = m.Description
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	if posthook, ok := interface{}(m).(ServiceOfferWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceOffer the arg will be the target, the caller the one being converted from

// ServiceOfferBeforeToORM called before default ToORM code
type ServiceOfferWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceOfferORM) error
}

// ServiceOfferAfterToORM called after default ToORM code
type ServiceOfferWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceOfferORM) error
}

// ServiceOfferBeforeToPB called before default ToPB code
type ServiceOfferWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceOffer) error
}

// ServiceOfferAfterToPB called after default ToPB code
type ServiceOfferWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceOffer) error
}

type ServiceDetailsContactORM struct {
	AccountID        string
	CreatedAt        *time.Time
	Email            string
	FirstName        string
	Id               int64 `gorm:"type:serial;primary_key"`
	LastName         string
	Phone            string
	ServiceDetailsId *int64
	UpdatedAt        *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceDetailsContactORM) TableName() string {
	return "service_details_contacts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceDetailsContact) ToORM(ctx context.Context) (ServiceDetailsContactORM, error) {
	to := ServiceDetailsContactORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceDetailsContactWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ServiceDetailsContact{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.Email = m.Email
	to.Phone = m.Phone
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceDetailsContactWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceDetailsContactORM) ToPB(ctx context.Context) (ServiceDetailsContact, error) {
	to := ServiceDetailsContact{}
	var err error
	if prehook, ok := interface{}(m).(ServiceDetailsContactWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceDetailsContact{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.Email = m.Email
	to.Phone = m.Phone
	if posthook, ok := interface{}(m).(ServiceDetailsContactWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceDetailsContact the arg will be the target, the caller the one being converted from

// ServiceDetailsContactBeforeToORM called before default ToORM code
type ServiceDetailsContactWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceDetailsContactORM) error
}

// ServiceDetailsContactAfterToORM called after default ToORM code
type ServiceDetailsContactWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceDetailsContactORM) error
}

// ServiceDetailsContactBeforeToPB called before default ToPB code
type ServiceDetailsContactWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceDetailsContact) error
}

// ServiceDetailsContactAfterToPB called after default ToPB code
type ServiceDetailsContactWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceDetailsContact) error
}

type ServiceDetailsCompanyORM struct {
	AccountID        string
	Address          string
	CreatedAt        *time.Time
	Id               int64 `gorm:"type:serial;primary_key"`
	Name             string
	Phone            string
	ServiceDetailsId *int64
	UpdatedAt        *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceDetailsCompanyORM) TableName() string {
	return "service_details_companies"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceDetailsCompany) ToORM(ctx context.Context) (ServiceDetailsCompanyORM, error) {
	to := ServiceDetailsCompanyORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceDetailsCompanyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ServiceDetailsCompany{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	to.Address = m.Address
	to.Phone = m.Phone
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceDetailsCompanyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceDetailsCompanyORM) ToPB(ctx context.Context) (ServiceDetailsCompany, error) {
	to := ServiceDetailsCompany{}
	var err error
	if prehook, ok := interface{}(m).(ServiceDetailsCompanyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceDetailsCompany{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Address = m.Address
	to.Phone = m.Phone
	if posthook, ok := interface{}(m).(ServiceDetailsCompanyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceDetailsCompany the arg will be the target, the caller the one being converted from

// ServiceDetailsCompanyBeforeToORM called before default ToORM code
type ServiceDetailsCompanyWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceDetailsCompanyORM) error
}

// ServiceDetailsCompanyAfterToORM called after default ToORM code
type ServiceDetailsCompanyWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceDetailsCompanyORM) error
}

// ServiceDetailsCompanyBeforeToPB called before default ToPB code
type ServiceDetailsCompanyWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceDetailsCompany) error
}

// ServiceDetailsCompanyAfterToPB called after default ToPB code
type ServiceDetailsCompanyWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceDetailsCompany) error
}

type ServiceDetailsORM struct {
	AccountID         string
	Company           *ServiceDetailsCompanyORM `gorm:"foreignkey:ServiceDetailsId;association_foreignkey:Id"`
	Contact           *ServiceDetailsContactORM `gorm:"foreignkey:ServiceDetailsId;association_foreignkey:Id"`
	CreatedAt         *time.Time
	Id                int64 `gorm:"type:serial;primary_key"`
	ServiceProviderId *string
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceDetailsORM) TableName() string {
	return "service_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceDetails) ToORM(ctx context.Context) (ServiceDetailsORM, error) {
	to := ServiceDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ServiceDetails{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Company != nil {
		tempCompany, err := m.Company.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Company = &tempCompany
	}
	if m.Contact != nil {
		tempContact, err := m.Contact.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Contact = &tempContact
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceDetailsORM) ToPB(ctx context.Context) (ServiceDetails, error) {
	to := ServiceDetails{}
	var err error
	if prehook, ok := interface{}(m).(ServiceDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceDetails{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Company != nil {
		tempCompany, err := m.Company.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Company = &tempCompany
	}
	if m.Contact != nil {
		tempContact, err := m.Contact.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Contact = &tempContact
	}
	if posthook, ok := interface{}(m).(ServiceDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceDetails the arg will be the target, the caller the one being converted from

// ServiceDetailsBeforeToORM called before default ToORM code
type ServiceDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceDetailsORM) error
}

// ServiceDetailsAfterToORM called after default ToORM code
type ServiceDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceDetailsORM) error
}

// ServiceDetailsBeforeToPB called before default ToPB code
type ServiceDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceDetails) error
}

// ServiceDetailsAfterToPB called after default ToPB code
type ServiceDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceDetails) error
}

type ServiceApplicationORM struct {
	AccountID         string
	AppliedAt         *time.Time
	ApprovedAt        *time.Time
	ApprovedBy        *ProfileORM `gorm:"foreignkey:ServiceApplicationId;association_foreignkey:Id"`
	CreatedAt         *time.Time
	Files             []*ServiceApplicationFileORM `gorm:"foreignkey:ServiceApplicationId;association_foreignkey:Id"`
	Id                string                       `gorm:"type:uuid;primary_key"`
	Provider          *ServiceProviderORM          `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	ServiceProviderId *string
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceApplicationORM) TableName() string {
	return "service_applications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceApplication) ToORM(ctx context.Context) (ServiceApplicationORM, error) {
	to := ServiceApplicationORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceApplication{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	for _, v := range m.Files {
		if v != nil {
			if tempFiles, cErr := v.ToORM(ctx); cErr == nil {
				to.Files = append(to.Files, &tempFiles)
			} else {
				return to, cErr
			}
		} else {
			to.Files = append(to.Files, nil)
		}
	}
	if m.AppliedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.AppliedAt); err != nil {
			return to, err
		}
		to.AppliedAt = &t
	}
	if m.ApprovedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.ApprovedAt); err != nil {
			return to, err
		}
		to.ApprovedAt = &t
	}
	if m.ApprovedBy != nil {
		tempApprovedBy, err := m.ApprovedBy.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ApprovedBy = &tempApprovedBy
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceApplicationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceApplicationORM) ToPB(ctx context.Context) (ServiceApplication, error) {
	to := ServiceApplication{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceApplication{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Provider != nil {
		tempProvider, err := m.Provider.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Provider = &tempProvider
	}
	for _, v := range m.Files {
		if v != nil {
			if tempFiles, cErr := v.ToPB(ctx); cErr == nil {
				to.Files = append(to.Files, &tempFiles)
			} else {
				return to, cErr
			}
		} else {
			to.Files = append(to.Files, nil)
		}
	}
	if m.AppliedAt != nil {
		if to.AppliedAt, err = ptypes1.TimestampProto(*m.AppliedAt); err != nil {
			return to, err
		}
	}
	if m.ApprovedAt != nil {
		if to.ApprovedAt, err = ptypes1.TimestampProto(*m.ApprovedAt); err != nil {
			return to, err
		}
	}
	if m.ApprovedBy != nil {
		tempApprovedBy, err := m.ApprovedBy.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ApprovedBy = &tempApprovedBy
	}
	if posthook, ok := interface{}(m).(ServiceApplicationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceApplication the arg will be the target, the caller the one being converted from

// ServiceApplicationBeforeToORM called before default ToORM code
type ServiceApplicationWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceApplicationORM) error
}

// ServiceApplicationAfterToORM called after default ToORM code
type ServiceApplicationWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceApplicationORM) error
}

// ServiceApplicationBeforeToPB called before default ToPB code
type ServiceApplicationWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceApplication) error
}

// ServiceApplicationAfterToPB called after default ToPB code
type ServiceApplicationWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceApplication) error
}

type ServiceApplicationFileORM struct {
	AccountID            string
	CreatedAt            *time.Time
	Id                   string `gorm:"type:uuid;primary_key"`
	ServiceApplicationId *string
	UpdatedAt            *time.Time
	Url                  string
}

// TableName overrides the default tablename generated by GORM
func (ServiceApplicationFileORM) TableName() string {
	return "service_application_files"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceApplicationFile) ToORM(ctx context.Context) (ServiceApplicationFileORM, error) {
	to := ServiceApplicationFileORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationFileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceApplicationFile{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Url = m.Url
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceApplicationFileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceApplicationFileORM) ToPB(ctx context.Context) (ServiceApplicationFile, error) {
	to := ServiceApplicationFile{}
	var err error
	if prehook, ok := interface{}(m).(ServiceApplicationFileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceApplicationFile{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Url = m.Url
	if posthook, ok := interface{}(m).(ServiceApplicationFileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceApplicationFile the arg will be the target, the caller the one being converted from

// ServiceApplicationFileBeforeToORM called before default ToORM code
type ServiceApplicationFileWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceApplicationFileORM) error
}

// ServiceApplicationFileAfterToORM called after default ToORM code
type ServiceApplicationFileWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceApplicationFileORM) error
}

// ServiceApplicationFileBeforeToPB called before default ToPB code
type ServiceApplicationFileWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceApplicationFile) error
}

// ServiceApplicationFileAfterToPB called after default ToPB code
type ServiceApplicationFileWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceApplicationFile) error
}

type ServiceProviderORM struct {
	AccountID string
	CreatedAt *time.Time
	Details   *ServiceDetailsORM `gorm:"foreignkey:ServiceProviderId;association_foreignkey:Id"`
	Id        string             `gorm:"type:uuid;primary_key"`
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceProviderORM) TableName() string {
	return "service_providers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceProvider) ToORM(ctx context.Context) (ServiceProviderORM, error) {
	to := ServiceProviderORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceProviderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceProvider{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Details != nil {
		tempDetails, err := m.Details.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Details = &tempDetails
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceProviderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceProviderORM) ToPB(ctx context.Context) (ServiceProvider, error) {
	to := ServiceProvider{}
	var err error
	if prehook, ok := interface{}(m).(ServiceProviderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceProvider{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Details != nil {
		tempDetails, err := m.Details.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Details = &tempDetails
	}
	if posthook, ok := interface{}(m).(ServiceProviderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceProvider the arg will be the target, the caller the one being converted from

// ServiceProviderBeforeToORM called before default ToORM code
type ServiceProviderWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceProviderORM) error
}

// ServiceProviderAfterToORM called after default ToORM code
type ServiceProviderWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceProviderORM) error
}

// ServiceProviderBeforeToPB called before default ToPB code
type ServiceProviderWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceProvider) error
}

// ServiceProviderAfterToPB called after default ToPB code
type ServiceProviderWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceProvider) error
}

type ServiceProviderSessionEvaluationORM struct {
	AccountID          string
	Comment            string
	CreatedAt          *time.Time
	Id                 int64 `gorm:"type:serial;primary_key"`
	RecommendationRate float64
	ServiceSessionId   *string
	Session            *ServiceSessionORM `gorm:"foreignkey:ServiceProviderSessionEvaluationId;association_foreignkey:Id"`
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceProviderSessionEvaluationORM) TableName() string {
	return "service_provider_session_evaluations"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceProviderSessionEvaluation) ToORM(ctx context.Context) (ServiceProviderSessionEvaluationORM, error) {
	to := ServiceProviderSessionEvaluationORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceProviderSessionEvaluationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.DecodeInt64(&ServiceProviderSessionEvaluation{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.Session != nil {
		tempSession, err := m.Session.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Session = &tempSession
	}
	to.Comment = m.Comment
	to.RecommendationRate = m.RecommendationRate
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceProviderSessionEvaluationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceProviderSessionEvaluationORM) ToPB(ctx context.Context) (ServiceProviderSessionEvaluation, error) {
	to := ServiceProviderSessionEvaluation{}
	var err error
	if prehook, ok := interface{}(m).(ServiceProviderSessionEvaluationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceProviderSessionEvaluation{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.Session != nil {
		tempSession, err := m.Session.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Session = &tempSession
	}
	to.Comment = m.Comment
	to.RecommendationRate = m.RecommendationRate
	if posthook, ok := interface{}(m).(ServiceProviderSessionEvaluationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceProviderSessionEvaluation the arg will be the target, the caller the one being converted from

// ServiceProviderSessionEvaluationBeforeToORM called before default ToORM code
type ServiceProviderSessionEvaluationWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceProviderSessionEvaluationORM) error
}

// ServiceProviderSessionEvaluationAfterToORM called after default ToORM code
type ServiceProviderSessionEvaluationWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceProviderSessionEvaluationORM) error
}

// ServiceProviderSessionEvaluationBeforeToPB called before default ToPB code
type ServiceProviderSessionEvaluationWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceProviderSessionEvaluation) error
}

// ServiceProviderSessionEvaluationAfterToPB called after default ToPB code
type ServiceProviderSessionEvaluationWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceProviderSessionEvaluation) error
}

type ServiceSessionORM struct {
	AccountID                          string
	CreatedAt                          *time.Time
	Evaluation                         *ServiceProviderSessionEvaluationORM `gorm:"foreignkey:ServiceSessionId;association_foreignkey:Id"`
	FinishedAt                         *time.Time
	Id                                 string                   `gorm:"type:uuid;primary_key"`
	Notes                              []*ServiceSessionNoteORM `gorm:"foreignkey:ServiceSessionId;association_foreignkey:Id"`
	Offer                              *ServiceOfferORM         `gorm:"foreignkey:ServiceOfferId;association_foreignkey:Id"`
	ScheduledAt                        *time.Time
	ServiceOfferId                     *string
	ServiceProviderSessionEvaluationId *int64
	ServiceSessionNoteId               *string
	UpdatedAt                          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceSessionORM) TableName() string {
	return "service_sessions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceSession) ToORM(ctx context.Context) (ServiceSessionORM, error) {
	to := ServiceSessionORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceSession{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.ScheduledAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.ScheduledAt); err != nil {
			return to, err
		}
		to.ScheduledAt = &t
	}
	if m.FinishedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.FinishedAt); err != nil {
			return to, err
		}
		to.FinishedAt = &t
	}
	if m.Offer != nil {
		tempOffer, err := m.Offer.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Offer = &tempOffer
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if m.Evaluation != nil {
		tempEvaluation, err := m.Evaluation.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Evaluation = &tempEvaluation
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceSessionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceSessionORM) ToPB(ctx context.Context) (ServiceSession, error) {
	to := ServiceSession{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceSession{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.ScheduledAt != nil {
		if to.ScheduledAt, err = ptypes1.TimestampProto(*m.ScheduledAt); err != nil {
			return to, err
		}
	}
	if m.FinishedAt != nil {
		if to.FinishedAt, err = ptypes1.TimestampProto(*m.FinishedAt); err != nil {
			return to, err
		}
	}
	if m.Offer != nil {
		tempOffer, err := m.Offer.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Offer = &tempOffer
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if m.Evaluation != nil {
		tempEvaluation, err := m.Evaluation.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Evaluation = &tempEvaluation
	}
	if posthook, ok := interface{}(m).(ServiceSessionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceSession the arg will be the target, the caller the one being converted from

// ServiceSessionBeforeToORM called before default ToORM code
type ServiceSessionWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceSessionORM) error
}

// ServiceSessionAfterToORM called after default ToORM code
type ServiceSessionWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceSessionORM) error
}

// ServiceSessionBeforeToPB called before default ToPB code
type ServiceSessionWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceSession) error
}

// ServiceSessionAfterToPB called after default ToPB code
type ServiceSessionWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceSession) error
}

type ServiceSessionNoteORM struct {
	AccountID        string
	CreatedAt        *time.Time
	Id               string `gorm:"type:uuid;primary_key"`
	ServiceSessionId *string
	Session          []*ServiceSessionORM `gorm:"foreignkey:ServiceSessionNoteId;association_foreignkey:Id"`
	Text             string
	UpdatedAt        *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ServiceSessionNoteORM) TableName() string {
	return "service_session_notes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ServiceSessionNote) ToORM(ctx context.Context) (ServiceSessionNoteORM, error) {
	to := ServiceSessionNoteORM{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionNoteWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Decode(&ServiceSessionNote{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	for _, v := range m.Session {
		if v != nil {
			if tempSession, cErr := v.ToORM(ctx); cErr == nil {
				to.Session = append(to.Session, &tempSession)
			} else {
				return to, cErr
			}
		} else {
			to.Session = append(to.Session, nil)
		}
	}
	to.Text = m.Text
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(ServiceSessionNoteWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ServiceSessionNoteORM) ToPB(ctx context.Context) (ServiceSessionNote, error) {
	to := ServiceSessionNote{}
	var err error
	if prehook, ok := interface{}(m).(ServiceSessionNoteWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource1.Encode(&ServiceSessionNote{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	for _, v := range m.Session {
		if v != nil {
			if tempSession, cErr := v.ToPB(ctx); cErr == nil {
				to.Session = append(to.Session, &tempSession)
			} else {
				return to, cErr
			}
		} else {
			to.Session = append(to.Session, nil)
		}
	}
	to.Text = m.Text
	if posthook, ok := interface{}(m).(ServiceSessionNoteWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ServiceSessionNote the arg will be the target, the caller the one being converted from

// ServiceSessionNoteBeforeToORM called before default ToORM code
type ServiceSessionNoteWithBeforeToORM interface {
	BeforeToORM(context.Context, *ServiceSessionNoteORM) error
}

// ServiceSessionNoteAfterToORM called after default ToORM code
type ServiceSessionNoteWithAfterToORM interface {
	AfterToORM(context.Context, *ServiceSessionNoteORM) error
}

// ServiceSessionNoteBeforeToPB called before default ToPB code
type ServiceSessionNoteWithBeforeToPB interface {
	BeforeToPB(context.Context, *ServiceSessionNote) error
}

// ServiceSessionNoteAfterToPB called after default ToPB code
type ServiceSessionNoteWithAfterToPB interface {
	AfterToPB(context.Context, *ServiceSessionNote) error
}

// DefaultCreateServiceTag executes a basic gorm create call
func DefaultCreateServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceTagORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceTag executes a basic gorm read call
func DefaultReadServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceTagORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceTagORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceTagORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceTagORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceTagORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceTagSet(ctx context.Context, in []*ServiceTag, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceTagORM{})).(ServiceTagORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceTagORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceTagORM{})).(ServiceTagORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceTagORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceTag, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceTag, *gorm1.DB) error
}

// DefaultStrictUpdateServiceTag clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceTag(ctx context.Context, in *ServiceTag, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceTag")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceTagORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceTagORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceTag executes a basic gorm update call with patch behavior
func DefaultPatchServiceTag(ctx context.Context, in *ServiceTag, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceTag, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceTag
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceTagWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceTag(ctx, &ServiceTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceTagWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceTag(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceTagWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceTag(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceTagWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceTagWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceTagWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceTag, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceTag executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceTag(ctx context.Context, objects []*ServiceTag, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceTag, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceTag, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceTag(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceTag patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceTag(ctx context.Context, patchee *ServiceTag, patcher *ServiceTag, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceTag, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceTag executes a gorm list call
func DefaultListServiceTag(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceTag, error) {
	in := ServiceTag{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceTagORM{}, &ServiceTag{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceTagORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceTagORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceTag{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceTagORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceTagORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceTagORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceTagORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateService executes a basic gorm create call
func DefaultCreateService(ctx context.Context, in *Service, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadService executes a basic gorm read call
func DefaultReadService(ctx context.Context, in *Service, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteService(ctx context.Context, in *Service, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSet(ctx context.Context, in []*Service, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceORM{})).(ServiceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceORM{})).(ServiceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Service, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Service, *gorm1.DB) error
}

// DefaultStrictUpdateService clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateService(ctx context.Context, in *Service, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateService")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchService executes a basic gorm update call with patch behavior
func DefaultPatchService(ctx context.Context, in *Service, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Service, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Service
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskService(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateService(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Service, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetService executes a bulk gorm update call with patch behavior
func DefaultPatchSetService(ctx context.Context, objects []*Service, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Service, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Service, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchService(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskService patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskService(ctx context.Context, patchee *Service, patcher *Service, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Service, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListService executes a gorm list call
func DefaultListService(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*Service, error) {
	in := Service{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceORM{}, &Service{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Service{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceOffer executes a basic gorm create call
func DefaultCreateServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceOfferORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceOffer executes a basic gorm read call
func DefaultReadServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceOfferORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceOfferORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceOfferORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceOfferORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceOfferORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceOfferORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceOfferSet(ctx context.Context, in []*ServiceOffer, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceOfferORM{})).(ServiceOfferORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ServiceOfferORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceOfferORM{})).(ServiceOfferORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceOfferORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceOffer, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceOffer, *gorm1.DB) error
}

// DefaultStrictUpdateServiceOffer clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceOffer(ctx context.Context, in *ServiceOffer, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceOffer")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ServiceOfferORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceOfferORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceOffer executes a basic gorm update call with patch behavior
func DefaultPatchServiceOffer(ctx context.Context, in *ServiceOffer, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceOffer, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceOffer
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceOfferWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceOffer(ctx, &ServiceOffer{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceOfferWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceOffer(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceOfferWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceOffer(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceOfferWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceOfferWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceOfferWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceOffer, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceOffer executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceOffer(ctx context.Context, objects []*ServiceOffer, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceOffer, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceOffer, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceOffer(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceOffer patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceOffer(ctx context.Context, patchee *ServiceOffer, patcher *ServiceOffer, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceOffer, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedService bool
	var updatedProvider bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedService && strings.HasPrefix(f, prefix+"Service.") {
			updatedService = true
			if patcher.Service == nil {
				patchee.Service = nil
				continue
			}
			if patchee.Service == nil {
				patchee.Service = &Service{}
			}
			if o, err := DefaultApplyFieldMaskService(ctx, patchee.Service, patcher.Service, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Service.", db); err != nil {
				return nil, err
			} else {
				patchee.Service = o
			}
			continue
		}
		if f == prefix+"Service" {
			updatedService = true
			patchee.Service = patcher.Service
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedProvider && strings.HasPrefix(f, prefix+"Provider.") {
			updatedProvider = true
			if patcher.Provider == nil {
				patchee.Provider = nil
				continue
			}
			if patchee.Provider == nil {
				patchee.Provider = &ServiceProvider{}
			}
			if o, err := DefaultApplyFieldMaskServiceProvider(ctx, patchee.Provider, patcher.Provider, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Provider.", db); err != nil {
				return nil, err
			} else {
				patchee.Provider = o
			}
			continue
		}
		if f == prefix+"Provider" {
			updatedProvider = true
			patchee.Provider = patcher.Provider
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceOffer executes a gorm list call
func DefaultListServiceOffer(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceOffer, error) {
	in := ServiceOffer{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceOfferORM{}, &ServiceOffer{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceOfferORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceOfferORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceOffer{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceOfferORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceOfferORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceOfferORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceOfferORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceDetailsContact executes a basic gorm create call
func DefaultCreateServiceDetailsContact(ctx context.Context, in *ServiceDetailsContact, db *gorm1.DB) (*ServiceDetailsContact, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceDetailsContactORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceDetailsContact executes a basic gorm read call
func DefaultReadServiceDetailsContact(ctx context.Context, in *ServiceDetailsContact, db *gorm1.DB) (*ServiceDetailsContact, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceDetailsContactORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceDetailsContactORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceDetailsContactORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceDetailsContactORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceDetailsContact(ctx context.Context, in *ServiceDetailsContact, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceDetailsContactORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceDetailsContactORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceDetailsContactSet(ctx context.Context, in []*ServiceDetailsContact, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceDetailsContactORM{})).(ServiceDetailsContactORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceDetailsContactORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceDetailsContactORM{})).(ServiceDetailsContactORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceDetailsContactORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceDetailsContact, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceDetailsContact, *gorm1.DB) error
}

// DefaultStrictUpdateServiceDetailsContact clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceDetailsContact(ctx context.Context, in *ServiceDetailsContact, db *gorm1.DB) (*ServiceDetailsContact, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceDetailsContact")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceDetailsContactORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceDetailsContactORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceDetailsContact executes a basic gorm update call with patch behavior
func DefaultPatchServiceDetailsContact(ctx context.Context, in *ServiceDetailsContact, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceDetailsContact, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceDetailsContact
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceDetailsContactWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceDetailsContact(ctx, &ServiceDetailsContact{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceDetailsContactWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceDetailsContact(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceDetailsContactWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceDetailsContact(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceDetailsContactWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceDetailsContactWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceDetailsContact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceDetailsContact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceDetailsContact, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceDetailsContact, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceDetailsContact executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceDetailsContact(ctx context.Context, objects []*ServiceDetailsContact, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceDetailsContact, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceDetailsContact, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceDetailsContact(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceDetailsContact patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceDetailsContact(ctx context.Context, patchee *ServiceDetailsContact, patcher *ServiceDetailsContact, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceDetailsContact, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Phone" {
			patchee.Phone = patcher.Phone
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceDetailsContact executes a gorm list call
func DefaultListServiceDetailsContact(ctx context.Context, db *gorm1.DB) ([]*ServiceDetailsContact, error) {
	in := ServiceDetailsContact{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceDetailsContactORM{}, &ServiceDetailsContact{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceDetailsContactORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsContactORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceDetailsContact{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceDetailsContactORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsContactORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceDetailsContactORM) error
}

// DefaultCreateServiceDetailsCompany executes a basic gorm create call
func DefaultCreateServiceDetailsCompany(ctx context.Context, in *ServiceDetailsCompany, db *gorm1.DB) (*ServiceDetailsCompany, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceDetailsCompanyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceDetailsCompany executes a basic gorm read call
func DefaultReadServiceDetailsCompany(ctx context.Context, in *ServiceDetailsCompany, db *gorm1.DB) (*ServiceDetailsCompany, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceDetailsCompanyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceDetailsCompanyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceDetailsCompanyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceDetailsCompanyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceDetailsCompany(ctx context.Context, in *ServiceDetailsCompany, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceDetailsCompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceDetailsCompanyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceDetailsCompanySet(ctx context.Context, in []*ServiceDetailsCompany, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceDetailsCompanyORM{})).(ServiceDetailsCompanyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceDetailsCompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceDetailsCompanyORM{})).(ServiceDetailsCompanyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceDetailsCompanyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceDetailsCompany, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceDetailsCompany, *gorm1.DB) error
}

// DefaultStrictUpdateServiceDetailsCompany clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceDetailsCompany(ctx context.Context, in *ServiceDetailsCompany, db *gorm1.DB) (*ServiceDetailsCompany, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceDetailsCompany")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceDetailsCompanyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceDetailsCompanyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceDetailsCompany executes a basic gorm update call with patch behavior
func DefaultPatchServiceDetailsCompany(ctx context.Context, in *ServiceDetailsCompany, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceDetailsCompany, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceDetailsCompany
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceDetailsCompanyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceDetailsCompany(ctx, &ServiceDetailsCompany{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceDetailsCompanyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceDetailsCompany(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceDetailsCompanyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceDetailsCompany(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceDetailsCompanyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceDetailsCompanyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceDetailsCompany, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceDetailsCompany, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceDetailsCompany, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceDetailsCompany, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceDetailsCompany executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceDetailsCompany(ctx context.Context, objects []*ServiceDetailsCompany, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceDetailsCompany, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceDetailsCompany, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceDetailsCompany(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceDetailsCompany patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceDetailsCompany(ctx context.Context, patchee *ServiceDetailsCompany, patcher *ServiceDetailsCompany, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceDetailsCompany, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Phone" {
			patchee.Phone = patcher.Phone
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceDetailsCompany executes a gorm list call
func DefaultListServiceDetailsCompany(ctx context.Context, db *gorm1.DB) ([]*ServiceDetailsCompany, error) {
	in := ServiceDetailsCompany{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceDetailsCompanyORM{}, &ServiceDetailsCompany{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceDetailsCompanyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsCompanyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceDetailsCompany{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceDetailsCompanyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsCompanyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceDetailsCompanyORM) error
}

// DefaultCreateServiceDetails executes a basic gorm create call
func DefaultCreateServiceDetails(ctx context.Context, in *ServiceDetails, db *gorm1.DB) (*ServiceDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceDetails executes a basic gorm read call
func DefaultReadServiceDetails(ctx context.Context, in *ServiceDetails, db *gorm1.DB) (*ServiceDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceDetails(ctx context.Context, in *ServiceDetails, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceDetailsSet(ctx context.Context, in []*ServiceDetails, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceDetailsORM{})).(ServiceDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceDetailsORM{})).(ServiceDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceDetails, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceDetails, *gorm1.DB) error
}

// DefaultStrictUpdateServiceDetails clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceDetails(ctx context.Context, in *ServiceDetails, db *gorm1.DB) (*ServiceDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCompany := ServiceDetailsCompanyORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterCompany.ServiceDetailsId = new(int64)
	*filterCompany.ServiceDetailsId = ormObj.Id
	if err = db.Where(filterCompany).Delete(ServiceDetailsCompanyORM{}).Error; err != nil {
		return nil, err
	}
	filterContact := ServiceDetailsContactORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterContact.ServiceDetailsId = new(int64)
	*filterContact.ServiceDetailsId = ormObj.Id
	if err = db.Where(filterContact).Delete(ServiceDetailsContactORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceDetails executes a basic gorm update call with patch behavior
func DefaultPatchServiceDetails(ctx context.Context, in *ServiceDetails, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceDetails
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceDetails(ctx, &ServiceDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceDetails, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceDetails(ctx context.Context, objects []*ServiceDetails, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceDetails(ctx context.Context, patchee *ServiceDetails, patcher *ServiceDetails, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedCompany bool
	var updatedContact bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedCompany && strings.HasPrefix(f, prefix+"Company.") {
			updatedCompany = true
			if patcher.Company == nil {
				patchee.Company = nil
				continue
			}
			if patchee.Company == nil {
				patchee.Company = &ServiceDetailsCompany{}
			}
			if o, err := DefaultApplyFieldMaskServiceDetailsCompany(ctx, patchee.Company, patcher.Company, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Company.", db); err != nil {
				return nil, err
			} else {
				patchee.Company = o
			}
			continue
		}
		if f == prefix+"Company" {
			updatedCompany = true
			patchee.Company = patcher.Company
			continue
		}
		if !updatedContact && strings.HasPrefix(f, prefix+"Contact.") {
			updatedContact = true
			if patcher.Contact == nil {
				patchee.Contact = nil
				continue
			}
			if patchee.Contact == nil {
				patchee.Contact = &ServiceDetailsContact{}
			}
			if o, err := DefaultApplyFieldMaskServiceDetailsContact(ctx, patchee.Contact, patcher.Contact, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Contact.", db); err != nil {
				return nil, err
			} else {
				patchee.Contact = o
			}
			continue
		}
		if f == prefix+"Contact" {
			updatedContact = true
			patchee.Contact = patcher.Contact
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceDetails executes a gorm list call
func DefaultListServiceDetails(ctx context.Context, db *gorm1.DB) ([]*ServiceDetails, error) {
	in := ServiceDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceDetailsORM{}, &ServiceDetails{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceDetailsORM) error
}

// DefaultCreateServiceApplication executes a basic gorm create call
func DefaultCreateServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceApplication executes a basic gorm read call
func DefaultReadServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceApplicationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceApplicationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceApplicationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceApplicationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplicationSet(ctx context.Context, in []*ServiceApplication, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceApplicationORM{})).(ServiceApplicationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceApplicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceApplicationORM{})).(ServiceApplicationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceApplicationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceApplication, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceApplication, *gorm1.DB) error
}

// DefaultStrictUpdateServiceApplication clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceApplication(ctx context.Context, in *ServiceApplication, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceApplication")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceApplicationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterApprovedBy := ProfileORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterApprovedBy.ServiceApplicationId = new(string)
	*filterApprovedBy.ServiceApplicationId = ormObj.Id
	if err = db.Where(filterApprovedBy).Delete(ProfileORM{}).Error; err != nil {
		return nil, err
	}
	filterFiles := ServiceApplicationFileORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterFiles.ServiceApplicationId = new(string)
	*filterFiles.ServiceApplicationId = ormObj.Id
	if err = db.Where(filterFiles).Delete(ServiceApplicationFileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceApplicationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceApplication executes a basic gorm update call with patch behavior
func DefaultPatchServiceApplication(ctx context.Context, in *ServiceApplication, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceApplication, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceApplication
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceApplicationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceApplication(ctx, &ServiceApplication{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceApplicationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceApplication(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceApplicationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceApplication(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceApplicationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceApplicationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceApplication, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceApplication executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceApplication(ctx context.Context, objects []*ServiceApplication, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceApplication, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceApplication, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceApplication(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceApplication patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceApplication(ctx context.Context, patchee *ServiceApplication, patcher *ServiceApplication, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceApplication, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedProvider bool
	var updatedApprovedBy bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedProvider && strings.HasPrefix(f, prefix+"Provider.") {
			updatedProvider = true
			if patcher.Provider == nil {
				patchee.Provider = nil
				continue
			}
			if patchee.Provider == nil {
				patchee.Provider = &ServiceProvider{}
			}
			if o, err := DefaultApplyFieldMaskServiceProvider(ctx, patchee.Provider, patcher.Provider, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Provider.", db); err != nil {
				return nil, err
			} else {
				patchee.Provider = o
			}
			continue
		}
		if f == prefix+"Provider" {
			updatedProvider = true
			patchee.Provider = patcher.Provider
			continue
		}
		if f == prefix+"Files" {
			patchee.Files = patcher.Files
			continue
		}
		if f == prefix+"AppliedAt" {
			patchee.AppliedAt = patcher.AppliedAt
			continue
		}
		if f == prefix+"ApprovedAt" {
			patchee.ApprovedAt = patcher.ApprovedAt
			continue
		}
		if !updatedApprovedBy && strings.HasPrefix(f, prefix+"ApprovedBy.") {
			updatedApprovedBy = true
			if patcher.ApprovedBy == nil {
				patchee.ApprovedBy = nil
				continue
			}
			if patchee.ApprovedBy == nil {
				patchee.ApprovedBy = &Profile{}
			}
			if o, err := DefaultApplyFieldMaskProfile(ctx, patchee.ApprovedBy, patcher.ApprovedBy, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ApprovedBy.", db); err != nil {
				return nil, err
			} else {
				patchee.ApprovedBy = o
			}
			continue
		}
		if f == prefix+"ApprovedBy" {
			updatedApprovedBy = true
			patchee.ApprovedBy = patcher.ApprovedBy
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceApplication executes a gorm list call
func DefaultListServiceApplication(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceApplication, error) {
	in := ServiceApplication{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceApplicationORM{}, &ServiceApplication{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceApplicationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceApplication{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceApplicationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceApplicationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceApplicationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceApplicationORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceApplicationFile executes a basic gorm create call
func DefaultCreateServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationFileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceApplicationFile executes a basic gorm read call
func DefaultReadServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceApplicationFileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceApplicationFileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceApplicationFileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceApplicationFileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceApplicationFileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceApplicationFileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceApplicationFileSet(ctx context.Context, in []*ServiceApplicationFile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceApplicationFileORM{})).(ServiceApplicationFileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceApplicationFileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceApplicationFileORM{})).(ServiceApplicationFileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceApplicationFileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceApplicationFile, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceApplicationFile, *gorm1.DB) error
}

// DefaultStrictUpdateServiceApplicationFile clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceApplicationFile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceApplicationFileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceApplicationFileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceApplicationFile executes a basic gorm update call with patch behavior
func DefaultPatchServiceApplicationFile(ctx context.Context, in *ServiceApplicationFile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceApplicationFile
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceApplicationFileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceApplicationFile(ctx, &ServiceApplicationFile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceApplicationFileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceApplicationFile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceApplicationFileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceApplicationFile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceApplicationFileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceApplicationFileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceApplicationFile, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceApplicationFile executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceApplicationFile(ctx context.Context, objects []*ServiceApplicationFile, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceApplicationFile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceApplicationFile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceApplicationFile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceApplicationFile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceApplicationFile(ctx context.Context, patchee *ServiceApplicationFile, patcher *ServiceApplicationFile, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceApplicationFile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Url" {
			patchee.Url = patcher.Url
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceApplicationFile executes a gorm list call
func DefaultListServiceApplicationFile(ctx context.Context, db *gorm1.DB) ([]*ServiceApplicationFile, error) {
	in := ServiceApplicationFile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceApplicationFileORM{}, &ServiceApplicationFile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceApplicationFileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceApplicationFileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceApplicationFile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceApplicationFileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceApplicationFileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceApplicationFileORM) error
}

// DefaultCreateServiceProvider executes a basic gorm create call
func DefaultCreateServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceProviderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceProvider executes a basic gorm read call
func DefaultReadServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceProviderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceProviderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceProviderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceProviderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceProviderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceProviderSet(ctx context.Context, in []*ServiceProvider, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceProviderORM{})).(ServiceProviderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceProviderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceProviderORM{})).(ServiceProviderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceProviderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceProvider, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceProvider, *gorm1.DB) error
}

// DefaultStrictUpdateServiceProvider clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceProvider(ctx context.Context, in *ServiceProvider, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceProvider")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceProviderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDetails := ServiceDetailsORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterDetails.ServiceProviderId = new(string)
	*filterDetails.ServiceProviderId = ormObj.Id
	if err = db.Where(filterDetails).Delete(ServiceDetailsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceProviderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceProvider executes a basic gorm update call with patch behavior
func DefaultPatchServiceProvider(ctx context.Context, in *ServiceProvider, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceProvider, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceProvider
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceProviderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceProvider(ctx, &ServiceProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceProviderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceProvider(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceProviderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceProvider(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceProviderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceProviderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceProvider, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceProvider executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceProvider(ctx context.Context, objects []*ServiceProvider, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceProvider, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceProvider, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceProvider(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceProvider patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceProvider(ctx context.Context, patchee *ServiceProvider, patcher *ServiceProvider, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceProvider, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedDetails bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDetails && strings.HasPrefix(f, prefix+"Details.") {
			updatedDetails = true
			if patcher.Details == nil {
				patchee.Details = nil
				continue
			}
			if patchee.Details == nil {
				patchee.Details = &ServiceDetails{}
			}
			if o, err := DefaultApplyFieldMaskServiceDetails(ctx, patchee.Details, patcher.Details, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Details.", db); err != nil {
				return nil, err
			} else {
				patchee.Details = o
			}
			continue
		}
		if f == prefix+"Details" {
			updatedDetails = true
			patchee.Details = patcher.Details
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceProvider executes a gorm list call
func DefaultListServiceProvider(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceProvider, error) {
	in := ServiceProvider{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceProviderORM{}, &ServiceProvider{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceProviderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceProvider{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceProviderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceProviderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceProviderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceProviderORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceProviderSessionEvaluation executes a basic gorm create call
func DefaultCreateServiceProviderSessionEvaluation(ctx context.Context, in *ServiceProviderSessionEvaluation, db *gorm1.DB) (*ServiceProviderSessionEvaluation, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceProviderSessionEvaluationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceProviderSessionEvaluation executes a basic gorm read call
func DefaultReadServiceProviderSessionEvaluation(ctx context.Context, in *ServiceProviderSessionEvaluation, db *gorm1.DB) (*ServiceProviderSessionEvaluation, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceProviderSessionEvaluationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceProviderSessionEvaluationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceProviderSessionEvaluationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceProviderSessionEvaluationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceProviderSessionEvaluation(ctx context.Context, in *ServiceProviderSessionEvaluation, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceProviderSessionEvaluationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceProviderSessionEvaluationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceProviderSessionEvaluationSet(ctx context.Context, in []*ServiceProviderSessionEvaluation, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceProviderSessionEvaluationORM{})).(ServiceProviderSessionEvaluationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceProviderSessionEvaluationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceProviderSessionEvaluationORM{})).(ServiceProviderSessionEvaluationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceProviderSessionEvaluationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceProviderSessionEvaluation, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceProviderSessionEvaluation, *gorm1.DB) error
}

// DefaultStrictUpdateServiceProviderSessionEvaluation clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceProviderSessionEvaluation(ctx context.Context, in *ServiceProviderSessionEvaluation, db *gorm1.DB) (*ServiceProviderSessionEvaluation, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceProviderSessionEvaluation")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceProviderSessionEvaluationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSession := ServiceSessionORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSession.ServiceProviderSessionEvaluationId = new(int64)
	*filterSession.ServiceProviderSessionEvaluationId = ormObj.Id
	if err = db.Where(filterSession).Delete(ServiceSessionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceProviderSessionEvaluationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceProviderSessionEvaluation executes a basic gorm update call with patch behavior
func DefaultPatchServiceProviderSessionEvaluation(ctx context.Context, in *ServiceProviderSessionEvaluation, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceProviderSessionEvaluation, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceProviderSessionEvaluation
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceProviderSessionEvaluationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceProviderSessionEvaluation(ctx, &ServiceProviderSessionEvaluation{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceProviderSessionEvaluationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceProviderSessionEvaluation(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceProviderSessionEvaluationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceProviderSessionEvaluation(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceProviderSessionEvaluationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceProviderSessionEvaluationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceProviderSessionEvaluation, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceProviderSessionEvaluation, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceProviderSessionEvaluation, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceProviderSessionEvaluation, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceProviderSessionEvaluation executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceProviderSessionEvaluation(ctx context.Context, objects []*ServiceProviderSessionEvaluation, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceProviderSessionEvaluation, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceProviderSessionEvaluation, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceProviderSessionEvaluation(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceProviderSessionEvaluation patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceProviderSessionEvaluation(ctx context.Context, patchee *ServiceProviderSessionEvaluation, patcher *ServiceProviderSessionEvaluation, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceProviderSessionEvaluation, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedSession bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedSession && strings.HasPrefix(f, prefix+"Session.") {
			updatedSession = true
			if patcher.Session == nil {
				patchee.Session = nil
				continue
			}
			if patchee.Session == nil {
				patchee.Session = &ServiceSession{}
			}
			if o, err := DefaultApplyFieldMaskServiceSession(ctx, patchee.Session, patcher.Session, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Session.", db); err != nil {
				return nil, err
			} else {
				patchee.Session = o
			}
			continue
		}
		if f == prefix+"Session" {
			updatedSession = true
			patchee.Session = patcher.Session
			continue
		}
		if f == prefix+"Comment" {
			patchee.Comment = patcher.Comment
			continue
		}
		if f == prefix+"RecommendationRate" {
			patchee.RecommendationRate = patcher.RecommendationRate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceProviderSessionEvaluation executes a gorm list call
func DefaultListServiceProviderSessionEvaluation(ctx context.Context, db *gorm1.DB) ([]*ServiceProviderSessionEvaluation, error) {
	in := ServiceProviderSessionEvaluation{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceProviderSessionEvaluationORM{}, &ServiceProviderSessionEvaluation{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceProviderSessionEvaluationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceProviderSessionEvaluationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceProviderSessionEvaluation{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceProviderSessionEvaluationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceProviderSessionEvaluationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceProviderSessionEvaluationORM) error
}

// DefaultCreateServiceSession executes a basic gorm create call
func DefaultCreateServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceSession executes a basic gorm read call
func DefaultReadServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceSessionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceSessionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceSessionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceSessionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceSessionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSessionSet(ctx context.Context, in []*ServiceSession, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceSessionORM{})).(ServiceSessionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceSessionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceSessionORM{})).(ServiceSessionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceSessionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceSession, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceSession, *gorm1.DB) error
}

// DefaultStrictUpdateServiceSession clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceSession(ctx context.Context, in *ServiceSession, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceSession")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceSessionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterEvaluation := ServiceProviderSessionEvaluationORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterEvaluation.ServiceSessionId = new(string)
	*filterEvaluation.ServiceSessionId = ormObj.Id
	if err = db.Where(filterEvaluation).Delete(ServiceProviderSessionEvaluationORM{}).Error; err != nil {
		return nil, err
	}
	filterNotes := ServiceSessionNoteORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterNotes.ServiceSessionId = new(string)
	*filterNotes.ServiceSessionId = ormObj.Id
	if err = db.Where(filterNotes).Delete(ServiceSessionNoteORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceSessionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceSession executes a basic gorm update call with patch behavior
func DefaultPatchServiceSession(ctx context.Context, in *ServiceSession, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceSession, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceSession
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceSessionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceSession(ctx, &ServiceSession{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceSessionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceSession(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceSessionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceSession(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceSessionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceSessionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceSession, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceSession executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceSession(ctx context.Context, objects []*ServiceSession, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceSession, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceSession, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceSession(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceSession patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceSession(ctx context.Context, patchee *ServiceSession, patcher *ServiceSession, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceSession, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedOffer bool
	var updatedEvaluation bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"ScheduledAt" {
			patchee.ScheduledAt = patcher.ScheduledAt
			continue
		}
		if f == prefix+"FinishedAt" {
			patchee.FinishedAt = patcher.FinishedAt
			continue
		}
		if !updatedOffer && strings.HasPrefix(f, prefix+"Offer.") {
			updatedOffer = true
			if patcher.Offer == nil {
				patchee.Offer = nil
				continue
			}
			if patchee.Offer == nil {
				patchee.Offer = &ServiceOffer{}
			}
			if o, err := DefaultApplyFieldMaskServiceOffer(ctx, patchee.Offer, patcher.Offer, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Offer.", db); err != nil {
				return nil, err
			} else {
				patchee.Offer = o
			}
			continue
		}
		if f == prefix+"Offer" {
			updatedOffer = true
			patchee.Offer = patcher.Offer
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if !updatedEvaluation && strings.HasPrefix(f, prefix+"Evaluation.") {
			updatedEvaluation = true
			if patcher.Evaluation == nil {
				patchee.Evaluation = nil
				continue
			}
			if patchee.Evaluation == nil {
				patchee.Evaluation = &ServiceProviderSessionEvaluation{}
			}
			if o, err := DefaultApplyFieldMaskServiceProviderSessionEvaluation(ctx, patchee.Evaluation, patcher.Evaluation, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Evaluation.", db); err != nil {
				return nil, err
			} else {
				patchee.Evaluation = o
			}
			continue
		}
		if f == prefix+"Evaluation" {
			updatedEvaluation = true
			patchee.Evaluation = patcher.Evaluation
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceSession executes a gorm list call
func DefaultListServiceSession(ctx context.Context, db *gorm1.DB, f *query1.Filtering, s *query1.Sorting, p *query1.Pagination, fs *query1.FieldSelection) ([]*ServiceSession, error) {
	in := ServiceSession{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceSessionORM{}, &ServiceSession{}, f, s, p, fs)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceSessionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse, f, s, p, fs); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceSession{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceSessionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceSessionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) (*gorm1.DB, error)
}
type ServiceSessionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceSessionORM, *query1.Filtering, *query1.Sorting, *query1.Pagination, *query1.FieldSelection) error
}

// DefaultCreateServiceSessionNote executes a basic gorm create call
func DefaultCreateServiceSessionNote(ctx context.Context, in *ServiceSessionNote, db *gorm1.DB) (*ServiceSessionNote, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionNoteORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadServiceSessionNote executes a basic gorm read call
func DefaultReadServiceSessionNote(ctx context.Context, in *ServiceSessionNote, db *gorm1.DB) (*ServiceSessionNote, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ServiceSessionNoteORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ServiceSessionNoteORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ServiceSessionNoteORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ServiceSessionNoteORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSessionNote(ctx context.Context, in *ServiceSessionNote, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ServiceSessionNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ServiceSessionNoteORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteServiceSessionNoteSet(ctx context.Context, in []*ServiceSessionNote, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ServiceSessionNoteORM{})).(ServiceSessionNoteORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&ServiceSessionNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ServiceSessionNoteORM{})).(ServiceSessionNoteORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ServiceSessionNoteORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ServiceSessionNote, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ServiceSessionNote, *gorm1.DB) error
}

// DefaultStrictUpdateServiceSessionNote clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateServiceSessionNote(ctx context.Context, in *ServiceSessionNote, db *gorm1.DB) (*ServiceSessionNote, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateServiceSessionNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &ServiceSessionNoteORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSession := ServiceSessionORM{}
	if ormObj.Id == "" {
		return nil, errors1.EmptyIdError
	}
	filterSession.ServiceSessionNoteId = new(string)
	*filterSession.ServiceSessionNoteId = ormObj.Id
	if err = db.Where(filterSession).Delete(ServiceSessionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ServiceSessionNoteORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchServiceSessionNote executes a basic gorm update call with patch behavior
func DefaultPatchServiceSessionNote(ctx context.Context, in *ServiceSessionNote, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*ServiceSessionNote, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj ServiceSessionNote
	var err error
	if hook, ok := interface{}(&pbObj).(ServiceSessionNoteWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadServiceSessionNote(ctx, &ServiceSessionNote{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ServiceSessionNoteWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskServiceSessionNote(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ServiceSessionNoteWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateServiceSessionNote(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ServiceSessionNoteWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ServiceSessionNoteWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ServiceSessionNote, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ServiceSessionNote, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ServiceSessionNote, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ServiceSessionNote, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetServiceSessionNote executes a bulk gorm update call with patch behavior
func DefaultPatchSetServiceSessionNote(ctx context.Context, objects []*ServiceSessionNote, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*ServiceSessionNote, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ServiceSessionNote, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchServiceSessionNote(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskServiceSessionNote patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskServiceSessionNote(ctx context.Context, patchee *ServiceSessionNote, patcher *ServiceSessionNote, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*ServiceSessionNote, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Session" {
			patchee.Session = patcher.Session
			continue
		}
		if f == prefix+"Text" {
			patchee.Text = patcher.Text
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListServiceSessionNote executes a gorm list call
func DefaultListServiceSessionNote(ctx context.Context, db *gorm1.DB) ([]*ServiceSessionNote, error) {
	in := ServiceSessionNote{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ServiceSessionNoteORM{}, &ServiceSessionNote{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ServiceSessionNoteORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ServiceSessionNoteORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ServiceSessionNote{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ServiceSessionNoteORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ServiceSessionNoteORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ServiceSessionNoteORM) error
}
type ServicesDefaultServer struct {
	DB *gorm1.DB
}

// ListService ...
func (m *ServicesDefaultServer) ListService(ctx context.Context, in *ListServiceRequest) (*ListServiceResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeListService); ok {
		var err error
		if db, err = custom.BeforeListService(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListService(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterListService); ok {
		var err error
		if err = custom.AfterListService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeListService called before DefaultListServiceService in the default ListService handler
type ServicesServiceWithBeforeListService interface {
	BeforeListService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterListService called before DefaultListServiceService in the default ListService handler
type ServicesServiceWithAfterListService interface {
	AfterListService(context.Context, *ListServiceResponse, *gorm1.DB) error
}

// CreateService ...
func (m *ServicesDefaultServer) CreateService(ctx context.Context, in *CreateServiceRequest) (*CreateServiceResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeCreateService); ok {
		var err error
		if db, err = custom.BeforeCreateService(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateService(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterCreateService); ok {
		var err error
		if err = custom.AfterCreateService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeCreateService called before DefaultCreateServiceService in the default CreateService handler
type ServicesServiceWithBeforeCreateService interface {
	BeforeCreateService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterCreateService called before DefaultCreateServiceService in the default CreateService handler
type ServicesServiceWithAfterCreateService interface {
	AfterCreateService(context.Context, *CreateServiceResponse, *gorm1.DB) error
}

// ReadService ...
func (m *ServicesDefaultServer) ReadService(ctx context.Context, in *ReadServiceRequest) (*ReadServiceResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeReadService); ok {
		var err error
		if db, err = custom.BeforeReadService(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterReadService); ok {
		var err error
		if err = custom.AfterReadService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeReadService called before DefaultReadServiceService in the default ReadService handler
type ServicesServiceWithBeforeReadService interface {
	BeforeReadService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterReadService called before DefaultReadServiceService in the default ReadService handler
type ServicesServiceWithAfterReadService interface {
	AfterReadService(context.Context, *ReadServiceResponse, *gorm1.DB) error
}

// UpdateService ...
func (m *ServicesDefaultServer) UpdateService(ctx context.Context, in *UpdateServiceRequest) (*UpdateServiceResponse, error) {
	var err error
	var res *Service
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeUpdateService); ok {
		var err error
		if db, err = custom.BeforeUpdateService(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateService(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterUpdateService); ok {
		var err error
		if err = custom.AfterUpdateService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeUpdateService called before DefaultUpdateServiceService in the default UpdateService handler
type ServicesServiceWithBeforeUpdateService interface {
	BeforeUpdateService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterUpdateService called before DefaultUpdateServiceService in the default UpdateService handler
type ServicesServiceWithAfterUpdateService interface {
	AfterUpdateService(context.Context, *UpdateServiceResponse, *gorm1.DB) error
}

// DeleteService ...
func (m *ServicesDefaultServer) DeleteService(ctx context.Context, in *DeleteServiceRequest) (*DeleteServiceResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceWithBeforeDeleteService); ok {
		var err error
		if db, err = custom.BeforeDeleteService(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteService(ctx, &Service{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceResponse{}
	if custom, ok := interface{}(in).(ServicesServiceWithAfterDeleteService); ok {
		var err error
		if err = custom.AfterDeleteService(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceWithBeforeDeleteService called before DefaultDeleteServiceService in the default DeleteService handler
type ServicesServiceWithBeforeDeleteService interface {
	BeforeDeleteService(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceWithAfterDeleteService called before DefaultDeleteServiceService in the default DeleteService handler
type ServicesServiceWithAfterDeleteService interface {
	AfterDeleteService(context.Context, *DeleteServiceResponse, *gorm1.DB) error
}

// ListServiceSession ...
func (m *ServicesDefaultServer) ListServiceSession(ctx context.Context, in *ListServiceSessionRequest) (*ListServiceSessionResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeListServiceSession); ok {
		var err error
		if db, err = custom.BeforeListServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceSession(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceSessionResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterListServiceSession); ok {
		var err error
		if err = custom.AfterListServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeListServiceSession called before DefaultListServiceSessionServiceSession in the default ListServiceSession handler
type ServicesServiceSessionWithBeforeListServiceSession interface {
	BeforeListServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterListServiceSession called before DefaultListServiceSessionServiceSession in the default ListServiceSession handler
type ServicesServiceSessionWithAfterListServiceSession interface {
	AfterListServiceSession(context.Context, *ListServiceSessionResponse, *gorm1.DB) error
}

// CreateServiceSession ...
func (m *ServicesDefaultServer) CreateServiceSession(ctx context.Context, in *CreateServiceSessionRequest) (*CreateServiceSessionResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeCreateServiceSession); ok {
		var err error
		if db, err = custom.BeforeCreateServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceSession(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceSessionResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterCreateServiceSession); ok {
		var err error
		if err = custom.AfterCreateServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeCreateServiceSession called before DefaultCreateServiceSessionServiceSession in the default CreateServiceSession handler
type ServicesServiceSessionWithBeforeCreateServiceSession interface {
	BeforeCreateServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterCreateServiceSession called before DefaultCreateServiceSessionServiceSession in the default CreateServiceSession handler
type ServicesServiceSessionWithAfterCreateServiceSession interface {
	AfterCreateServiceSession(context.Context, *CreateServiceSessionResponse, *gorm1.DB) error
}

// ReadServiceSession ...
func (m *ServicesDefaultServer) ReadServiceSession(ctx context.Context, in *ReadServiceSessionRequest) (*ReadServiceSessionResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeReadServiceSession); ok {
		var err error
		if db, err = custom.BeforeReadServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceSession(ctx, &ServiceSession{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceSessionResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterReadServiceSession); ok {
		var err error
		if err = custom.AfterReadServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeReadServiceSession called before DefaultReadServiceSessionServiceSession in the default ReadServiceSession handler
type ServicesServiceSessionWithBeforeReadServiceSession interface {
	BeforeReadServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterReadServiceSession called before DefaultReadServiceSessionServiceSession in the default ReadServiceSession handler
type ServicesServiceSessionWithAfterReadServiceSession interface {
	AfterReadServiceSession(context.Context, *ReadServiceSessionResponse, *gorm1.DB) error
}

// UpdateServiceSession ...
func (m *ServicesDefaultServer) UpdateServiceSession(ctx context.Context, in *UpdateServiceSessionRequest) (*UpdateServiceSessionResponse, error) {
	var err error
	var res *ServiceSession
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeUpdateServiceSession); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceSession(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceSessionResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterUpdateServiceSession); ok {
		var err error
		if err = custom.AfterUpdateServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeUpdateServiceSession called before DefaultUpdateServiceSessionServiceSession in the default UpdateServiceSession handler
type ServicesServiceSessionWithBeforeUpdateServiceSession interface {
	BeforeUpdateServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterUpdateServiceSession called before DefaultUpdateServiceSessionServiceSession in the default UpdateServiceSession handler
type ServicesServiceSessionWithAfterUpdateServiceSession interface {
	AfterUpdateServiceSession(context.Context, *UpdateServiceSessionResponse, *gorm1.DB) error
}

// DeleteServiceSession ...
func (m *ServicesDefaultServer) DeleteServiceSession(ctx context.Context, in *DeleteServiceSessionRequest) (*DeleteServiceSessionResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceSessionWithBeforeDeleteServiceSession); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceSession(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceSession(ctx, &ServiceSession{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceSessionResponse{}
	if custom, ok := interface{}(in).(ServicesServiceSessionWithAfterDeleteServiceSession); ok {
		var err error
		if err = custom.AfterDeleteServiceSession(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceSessionWithBeforeDeleteServiceSession called before DefaultDeleteServiceSessionServiceSession in the default DeleteServiceSession handler
type ServicesServiceSessionWithBeforeDeleteServiceSession interface {
	BeforeDeleteServiceSession(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceSessionWithAfterDeleteServiceSession called before DefaultDeleteServiceSessionServiceSession in the default DeleteServiceSession handler
type ServicesServiceSessionWithAfterDeleteServiceSession interface {
	AfterDeleteServiceSession(context.Context, *DeleteServiceSessionResponse, *gorm1.DB) error
}

// ListServiceTag ...
func (m *ServicesDefaultServer) ListServiceTag(ctx context.Context, in *ListServiceTagRequest) (*ListServiceTagResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeListServiceTag); ok {
		var err error
		if db, err = custom.BeforeListServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceTag(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceTagResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterListServiceTag); ok {
		var err error
		if err = custom.AfterListServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeListServiceTag called before DefaultListServiceTagServiceTag in the default ListServiceTag handler
type ServicesServiceTagWithBeforeListServiceTag interface {
	BeforeListServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterListServiceTag called before DefaultListServiceTagServiceTag in the default ListServiceTag handler
type ServicesServiceTagWithAfterListServiceTag interface {
	AfterListServiceTag(context.Context, *ListServiceTagResponse, *gorm1.DB) error
}

// CreateServiceTag ...
func (m *ServicesDefaultServer) CreateServiceTag(ctx context.Context, in *CreateServiceTagRequest) (*CreateServiceTagResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeCreateServiceTag); ok {
		var err error
		if db, err = custom.BeforeCreateServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceTag(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceTagResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterCreateServiceTag); ok {
		var err error
		if err = custom.AfterCreateServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeCreateServiceTag called before DefaultCreateServiceTagServiceTag in the default CreateServiceTag handler
type ServicesServiceTagWithBeforeCreateServiceTag interface {
	BeforeCreateServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterCreateServiceTag called before DefaultCreateServiceTagServiceTag in the default CreateServiceTag handler
type ServicesServiceTagWithAfterCreateServiceTag interface {
	AfterCreateServiceTag(context.Context, *CreateServiceTagResponse, *gorm1.DB) error
}

// ReadServiceTag ...
func (m *ServicesDefaultServer) ReadServiceTag(ctx context.Context, in *ReadServiceTagRequest) (*ReadServiceTagResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeReadServiceTag); ok {
		var err error
		if db, err = custom.BeforeReadServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceTag(ctx, &ServiceTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceTagResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterReadServiceTag); ok {
		var err error
		if err = custom.AfterReadServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeReadServiceTag called before DefaultReadServiceTagServiceTag in the default ReadServiceTag handler
type ServicesServiceTagWithBeforeReadServiceTag interface {
	BeforeReadServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterReadServiceTag called before DefaultReadServiceTagServiceTag in the default ReadServiceTag handler
type ServicesServiceTagWithAfterReadServiceTag interface {
	AfterReadServiceTag(context.Context, *ReadServiceTagResponse, *gorm1.DB) error
}

// UpdateServiceTag ...
func (m *ServicesDefaultServer) UpdateServiceTag(ctx context.Context, in *UpdateServiceTagRequest) (*UpdateServiceTagResponse, error) {
	var err error
	var res *ServiceTag
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeUpdateServiceTag); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceTag(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceTagResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterUpdateServiceTag); ok {
		var err error
		if err = custom.AfterUpdateServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeUpdateServiceTag called before DefaultUpdateServiceTagServiceTag in the default UpdateServiceTag handler
type ServicesServiceTagWithBeforeUpdateServiceTag interface {
	BeforeUpdateServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterUpdateServiceTag called before DefaultUpdateServiceTagServiceTag in the default UpdateServiceTag handler
type ServicesServiceTagWithAfterUpdateServiceTag interface {
	AfterUpdateServiceTag(context.Context, *UpdateServiceTagResponse, *gorm1.DB) error
}

// DeleteServiceTag ...
func (m *ServicesDefaultServer) DeleteServiceTag(ctx context.Context, in *DeleteServiceTagRequest) (*DeleteServiceTagResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceTagWithBeforeDeleteServiceTag); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceTag(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceTag(ctx, &ServiceTag{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceTagResponse{}
	if custom, ok := interface{}(in).(ServicesServiceTagWithAfterDeleteServiceTag); ok {
		var err error
		if err = custom.AfterDeleteServiceTag(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceTagWithBeforeDeleteServiceTag called before DefaultDeleteServiceTagServiceTag in the default DeleteServiceTag handler
type ServicesServiceTagWithBeforeDeleteServiceTag interface {
	BeforeDeleteServiceTag(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceTagWithAfterDeleteServiceTag called before DefaultDeleteServiceTagServiceTag in the default DeleteServiceTag handler
type ServicesServiceTagWithAfterDeleteServiceTag interface {
	AfterDeleteServiceTag(context.Context, *DeleteServiceTagResponse, *gorm1.DB) error
}

// ListServiceOffer ...
func (m *ServicesDefaultServer) ListServiceOffer(ctx context.Context, in *ListServiceOfferRequest) (*ListServiceOfferResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeListServiceOffer); ok {
		var err error
		if db, err = custom.BeforeListServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceOffer(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceOfferResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterListServiceOffer); ok {
		var err error
		if err = custom.AfterListServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeListServiceOffer called before DefaultListServiceOfferServiceOffer in the default ListServiceOffer handler
type ServicesServiceOfferWithBeforeListServiceOffer interface {
	BeforeListServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterListServiceOffer called before DefaultListServiceOfferServiceOffer in the default ListServiceOffer handler
type ServicesServiceOfferWithAfterListServiceOffer interface {
	AfterListServiceOffer(context.Context, *ListServiceOfferResponse, *gorm1.DB) error
}

// CreateServiceOffer ...
func (m *ServicesDefaultServer) CreateServiceOffer(ctx context.Context, in *CreateServiceOfferRequest) (*CreateServiceOfferResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeCreateServiceOffer); ok {
		var err error
		if db, err = custom.BeforeCreateServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceOffer(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceOfferResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterCreateServiceOffer); ok {
		var err error
		if err = custom.AfterCreateServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeCreateServiceOffer called before DefaultCreateServiceOfferServiceOffer in the default CreateServiceOffer handler
type ServicesServiceOfferWithBeforeCreateServiceOffer interface {
	BeforeCreateServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterCreateServiceOffer called before DefaultCreateServiceOfferServiceOffer in the default CreateServiceOffer handler
type ServicesServiceOfferWithAfterCreateServiceOffer interface {
	AfterCreateServiceOffer(context.Context, *CreateServiceOfferResponse, *gorm1.DB) error
}

// ReadServiceOffer ...
func (m *ServicesDefaultServer) ReadServiceOffer(ctx context.Context, in *ReadServiceOfferRequest) (*ReadServiceOfferResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeReadServiceOffer); ok {
		var err error
		if db, err = custom.BeforeReadServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceOffer(ctx, &ServiceOffer{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceOfferResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterReadServiceOffer); ok {
		var err error
		if err = custom.AfterReadServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeReadServiceOffer called before DefaultReadServiceOfferServiceOffer in the default ReadServiceOffer handler
type ServicesServiceOfferWithBeforeReadServiceOffer interface {
	BeforeReadServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterReadServiceOffer called before DefaultReadServiceOfferServiceOffer in the default ReadServiceOffer handler
type ServicesServiceOfferWithAfterReadServiceOffer interface {
	AfterReadServiceOffer(context.Context, *ReadServiceOfferResponse, *gorm1.DB) error
}

// UpdateServiceOffer ...
func (m *ServicesDefaultServer) UpdateServiceOffer(ctx context.Context, in *UpdateServiceOfferRequest) (*UpdateServiceOfferResponse, error) {
	var err error
	var res *ServiceOffer
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeUpdateServiceOffer); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceOffer(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceOfferResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterUpdateServiceOffer); ok {
		var err error
		if err = custom.AfterUpdateServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeUpdateServiceOffer called before DefaultUpdateServiceOfferServiceOffer in the default UpdateServiceOffer handler
type ServicesServiceOfferWithBeforeUpdateServiceOffer interface {
	BeforeUpdateServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterUpdateServiceOffer called before DefaultUpdateServiceOfferServiceOffer in the default UpdateServiceOffer handler
type ServicesServiceOfferWithAfterUpdateServiceOffer interface {
	AfterUpdateServiceOffer(context.Context, *UpdateServiceOfferResponse, *gorm1.DB) error
}

// DeleteServiceOffer ...
func (m *ServicesDefaultServer) DeleteServiceOffer(ctx context.Context, in *DeleteServiceOfferRequest) (*DeleteServiceOfferResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceOfferWithBeforeDeleteServiceOffer); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceOffer(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceOffer(ctx, &ServiceOffer{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceOfferResponse{}
	if custom, ok := interface{}(in).(ServicesServiceOfferWithAfterDeleteServiceOffer); ok {
		var err error
		if err = custom.AfterDeleteServiceOffer(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceOfferWithBeforeDeleteServiceOffer called before DefaultDeleteServiceOfferServiceOffer in the default DeleteServiceOffer handler
type ServicesServiceOfferWithBeforeDeleteServiceOffer interface {
	BeforeDeleteServiceOffer(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceOfferWithAfterDeleteServiceOffer called before DefaultDeleteServiceOfferServiceOffer in the default DeleteServiceOffer handler
type ServicesServiceOfferWithAfterDeleteServiceOffer interface {
	AfterDeleteServiceOffer(context.Context, *DeleteServiceOfferResponse, *gorm1.DB) error
}

// ListServiceApplication ...
func (m *ServicesDefaultServer) ListServiceApplication(ctx context.Context, in *ListServiceApplicationRequest) (*ListServiceApplicationResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeListServiceApplication); ok {
		var err error
		if db, err = custom.BeforeListServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceApplication(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceApplicationResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterListServiceApplication); ok {
		var err error
		if err = custom.AfterListServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeListServiceApplication called before DefaultListServiceApplicationServiceApplication in the default ListServiceApplication handler
type ServicesServiceApplicationWithBeforeListServiceApplication interface {
	BeforeListServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterListServiceApplication called before DefaultListServiceApplicationServiceApplication in the default ListServiceApplication handler
type ServicesServiceApplicationWithAfterListServiceApplication interface {
	AfterListServiceApplication(context.Context, *ListServiceApplicationResponse, *gorm1.DB) error
}

// CreateServiceApplication ...
func (m *ServicesDefaultServer) CreateServiceApplication(ctx context.Context, in *CreateServiceApplicationRequest) (*CreateServiceApplicationResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeCreateServiceApplication); ok {
		var err error
		if db, err = custom.BeforeCreateServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceApplication(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterCreateServiceApplication); ok {
		var err error
		if err = custom.AfterCreateServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeCreateServiceApplication called before DefaultCreateServiceApplicationServiceApplication in the default CreateServiceApplication handler
type ServicesServiceApplicationWithBeforeCreateServiceApplication interface {
	BeforeCreateServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterCreateServiceApplication called before DefaultCreateServiceApplicationServiceApplication in the default CreateServiceApplication handler
type ServicesServiceApplicationWithAfterCreateServiceApplication interface {
	AfterCreateServiceApplication(context.Context, *CreateServiceApplicationResponse, *gorm1.DB) error
}

// ReadServiceApplication ...
func (m *ServicesDefaultServer) ReadServiceApplication(ctx context.Context, in *ReadServiceApplicationRequest) (*ReadServiceApplicationResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeReadServiceApplication); ok {
		var err error
		if db, err = custom.BeforeReadServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceApplication(ctx, &ServiceApplication{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterReadServiceApplication); ok {
		var err error
		if err = custom.AfterReadServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeReadServiceApplication called before DefaultReadServiceApplicationServiceApplication in the default ReadServiceApplication handler
type ServicesServiceApplicationWithBeforeReadServiceApplication interface {
	BeforeReadServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterReadServiceApplication called before DefaultReadServiceApplicationServiceApplication in the default ReadServiceApplication handler
type ServicesServiceApplicationWithAfterReadServiceApplication interface {
	AfterReadServiceApplication(context.Context, *ReadServiceApplicationResponse, *gorm1.DB) error
}

// UpdateServiceApplication ...
func (m *ServicesDefaultServer) UpdateServiceApplication(ctx context.Context, in *UpdateServiceApplicationRequest) (*UpdateServiceApplicationResponse, error) {
	var err error
	var res *ServiceApplication
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeUpdateServiceApplication); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceApplication(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceApplicationResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterUpdateServiceApplication); ok {
		var err error
		if err = custom.AfterUpdateServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeUpdateServiceApplication called before DefaultUpdateServiceApplicationServiceApplication in the default UpdateServiceApplication handler
type ServicesServiceApplicationWithBeforeUpdateServiceApplication interface {
	BeforeUpdateServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterUpdateServiceApplication called before DefaultUpdateServiceApplicationServiceApplication in the default UpdateServiceApplication handler
type ServicesServiceApplicationWithAfterUpdateServiceApplication interface {
	AfterUpdateServiceApplication(context.Context, *UpdateServiceApplicationResponse, *gorm1.DB) error
}

// DeleteServiceApplication ...
func (m *ServicesDefaultServer) DeleteServiceApplication(ctx context.Context, in *DeleteServiceApplicationRequest) (*DeleteServiceApplicationResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithBeforeDeleteServiceApplication); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceApplication(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceApplication(ctx, &ServiceApplication{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceApplicationResponse{}
	if custom, ok := interface{}(in).(ServicesServiceApplicationWithAfterDeleteServiceApplication); ok {
		var err error
		if err = custom.AfterDeleteServiceApplication(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceApplicationWithBeforeDeleteServiceApplication called before DefaultDeleteServiceApplicationServiceApplication in the default DeleteServiceApplication handler
type ServicesServiceApplicationWithBeforeDeleteServiceApplication interface {
	BeforeDeleteServiceApplication(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceApplicationWithAfterDeleteServiceApplication called before DefaultDeleteServiceApplicationServiceApplication in the default DeleteServiceApplication handler
type ServicesServiceApplicationWithAfterDeleteServiceApplication interface {
	AfterDeleteServiceApplication(context.Context, *DeleteServiceApplicationResponse, *gorm1.DB) error
}

// ListServiceProvider ...
func (m *ServicesDefaultServer) ListServiceProvider(ctx context.Context, in *ListServiceProviderRequest) (*ListServiceProviderResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeListServiceProvider); ok {
		var err error
		if db, err = custom.BeforeListServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultListServiceProvider(ctx, db, in.Filter, in.OrderBy, in.Paging, in.Fields)
	if err != nil {
		return nil, err
	}
	out := &ListServiceProviderResponse{Results: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterListServiceProvider); ok {
		var err error
		if err = custom.AfterListServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeListServiceProvider called before DefaultListServiceProviderServiceProvider in the default ListServiceProvider handler
type ServicesServiceProviderWithBeforeListServiceProvider interface {
	BeforeListServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterListServiceProvider called before DefaultListServiceProviderServiceProvider in the default ListServiceProvider handler
type ServicesServiceProviderWithAfterListServiceProvider interface {
	AfterListServiceProvider(context.Context, *ListServiceProviderResponse, *gorm1.DB) error
}

// CreateServiceProvider ...
func (m *ServicesDefaultServer) CreateServiceProvider(ctx context.Context, in *CreateServiceProviderRequest) (*CreateServiceProviderResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeCreateServiceProvider); ok {
		var err error
		if db, err = custom.BeforeCreateServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultCreateServiceProvider(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &CreateServiceProviderResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterCreateServiceProvider); ok {
		var err error
		if err = custom.AfterCreateServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeCreateServiceProvider called before DefaultCreateServiceProviderServiceProvider in the default CreateServiceProvider handler
type ServicesServiceProviderWithBeforeCreateServiceProvider interface {
	BeforeCreateServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterCreateServiceProvider called before DefaultCreateServiceProviderServiceProvider in the default CreateServiceProvider handler
type ServicesServiceProviderWithAfterCreateServiceProvider interface {
	AfterCreateServiceProvider(context.Context, *CreateServiceProviderResponse, *gorm1.DB) error
}

// ReadServiceProvider ...
func (m *ServicesDefaultServer) ReadServiceProvider(ctx context.Context, in *ReadServiceProviderRequest) (*ReadServiceProviderResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeReadServiceProvider); ok {
		var err error
		if db, err = custom.BeforeReadServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err := DefaultReadServiceProvider(ctx, &ServiceProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &ReadServiceProviderResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterReadServiceProvider); ok {
		var err error
		if err = custom.AfterReadServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeReadServiceProvider called before DefaultReadServiceProviderServiceProvider in the default ReadServiceProvider handler
type ServicesServiceProviderWithBeforeReadServiceProvider interface {
	BeforeReadServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterReadServiceProvider called before DefaultReadServiceProviderServiceProvider in the default ReadServiceProvider handler
type ServicesServiceProviderWithAfterReadServiceProvider interface {
	AfterReadServiceProvider(context.Context, *ReadServiceProviderResponse, *gorm1.DB) error
}

// UpdateServiceProvider ...
func (m *ServicesDefaultServer) UpdateServiceProvider(ctx context.Context, in *UpdateServiceProviderRequest) (*UpdateServiceProviderResponse, error) {
	var err error
	var res *ServiceProvider
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeUpdateServiceProvider); ok {
		var err error
		if db, err = custom.BeforeUpdateServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	res, err = DefaultStrictUpdateServiceProvider(ctx, in.GetPayload(), db)
	if err != nil {
		return nil, err
	}
	out := &UpdateServiceProviderResponse{Result: res}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterUpdateServiceProvider); ok {
		var err error
		if err = custom.AfterUpdateServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeUpdateServiceProvider called before DefaultUpdateServiceProviderServiceProvider in the default UpdateServiceProvider handler
type ServicesServiceProviderWithBeforeUpdateServiceProvider interface {
	BeforeUpdateServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterUpdateServiceProvider called before DefaultUpdateServiceProviderServiceProvider in the default UpdateServiceProvider handler
type ServicesServiceProviderWithAfterUpdateServiceProvider interface {
	AfterUpdateServiceProvider(context.Context, *UpdateServiceProviderResponse, *gorm1.DB) error
}

// DeleteServiceProvider ...
func (m *ServicesDefaultServer) DeleteServiceProvider(ctx context.Context, in *DeleteServiceProviderRequest) (*DeleteServiceProviderResponse, error) {
	db := m.DB
	if custom, ok := interface{}(in).(ServicesServiceProviderWithBeforeDeleteServiceProvider); ok {
		var err error
		if db, err = custom.BeforeDeleteServiceProvider(ctx, db); err != nil {
			return nil, err
		}
	}
	err := DefaultDeleteServiceProvider(ctx, &ServiceProvider{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	out := &DeleteServiceProviderResponse{}
	if custom, ok := interface{}(in).(ServicesServiceProviderWithAfterDeleteServiceProvider); ok {
		var err error
		if err = custom.AfterDeleteServiceProvider(ctx, out, db); err != nil {
			return nil, err
		}
	}
	return out, nil
}

// ServicesServiceProviderWithBeforeDeleteServiceProvider called before DefaultDeleteServiceProviderServiceProvider in the default DeleteServiceProvider handler
type ServicesServiceProviderWithBeforeDeleteServiceProvider interface {
	BeforeDeleteServiceProvider(context.Context, *gorm1.DB) (*gorm1.DB, error)
}

// ServicesServiceProviderWithAfterDeleteServiceProvider called before DefaultDeleteServiceProviderServiceProvider in the default DeleteServiceProvider handler
type ServicesServiceProviderWithAfterDeleteServiceProvider interface {
	AfterDeleteServiceProvider(context.Context, *DeleteServiceProviderResponse, *gorm1.DB) error
}
